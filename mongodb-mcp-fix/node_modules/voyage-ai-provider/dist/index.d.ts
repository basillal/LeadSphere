import { ProviderV3, EmbeddingModelV3, RerankingModelV3 } from '@ai-sdk/provider';
import { FetchFunction } from '@ai-sdk/provider-utils';
import { z } from 'zod/v4';

type VoyageEmbeddingModelId = 'voyage-3.5' | 'voyage-3.5-lite' | 'voyage-3-large' | 'voyage-3' | 'voyage-3-lite' | 'voyage-code-3' | 'voyage-finance-2' | 'voyage-multilingual-2' | 'voyage-law-2' | 'voyage-code-2' | 'voyage-large-2-instruct' | 'voyage-large-2' | 'voyage-2' | 'voyage-02' | 'voyage-01' | 'voyage-lite-01' | (string & NonNullable<unknown>);
declare const voyageEmbeddingOptions: z.ZodObject<{
    inputType: z.ZodOptional<z.ZodEnum<{
        query: "query";
        document: "document";
    }>>;
    outputDimension: z.ZodOptional<z.ZodNumber>;
    outputDtype: z.ZodOptional<z.ZodEnum<{
        float: "float";
        int8: "int8";
        uint8: "uint8";
        binary: "binary";
        ubinary: "ubinary";
    }>>;
    truncation: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
type VoyageEmbeddingOptions = z.infer<typeof voyageEmbeddingOptions>;

type VoyageMultimodalEmbeddingModelId = 'voyage-multimodal-3' | (string & {});
declare const voyageMultimodalEmbeddingOptions: z.ZodObject<{
    inputType: z.ZodOptional<z.ZodEnum<{
        query: "query";
        document: "document";
    }>>;
    outputEncoding: z.ZodOptional<z.ZodEnum<{
        base64: "base64";
    }>>;
    truncation: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
type VoyageMultimodalEmbeddingOptions = z.infer<typeof voyageMultimodalEmbeddingOptions>;

type VoyageRerankingModelId = 'rerank-2.5' | 'rerank-2.5-lite' | 'rerank-2' | 'rerank-lite-2' | 'rerank-1' | 'rerank-lite-1' | (string & {});
type VoyageRerankingOptions = {
    /**
     * Whether to return the documents in the response. Defaults to false.
     *
     * If false, the API will return a list of {"index", "relevance_score"} where "index" refers to
     * the index of a document within the input list.
     * If true, the API will return a list of {"index", "document", "relevance_score"} where "document"
     * is the corresponding document from the input list.
     *
     * @default false
     */
    returnDocuments?: boolean;
    /**
     * Whether to truncate the input to satisfy the "context length limit" on the query
     * and the documents. Defaults to true.
     *
     * If true, the query and documents will be truncated to fit within the context length limit,
     * before processed by the reranker model.
     *
     * If false, an error will be raised when the query exceeds 8,000 tokens for rerank-2.5
     * and rerank-2.5-lite; 4,000 tokens for rerank-2; 2,000 tokens for rerank-2-lite and rerank-1;
     * and 1,000 tokens for rerank-lite-1, or the sum of the number of tokens in the query and the
     * number of tokens in any single document exceeds 32,000 for rerank-2.5 and rerank-2.5-lite;
     * 16,000 for rerank-2; 8,000 for rerank-2-lite and rerank-1; and 4,000 for rerank-lite-1.
     *
     * @default true
     */
    truncation?: boolean;
};

interface VoyageProvider extends ProviderV3 {
    (modelId: VoyageEmbeddingModelId): EmbeddingModelV3;
    textEmbeddingModel: (modelId: VoyageEmbeddingModelId) => EmbeddingModelV3;
    imageEmbeddingModel: (modelId: VoyageMultimodalEmbeddingModelId) => EmbeddingModelV3;
    multimodalEmbeddingModel: (modelId: VoyageMultimodalEmbeddingModelId) => EmbeddingModelV3;
    reranking: (modelId: VoyageRerankingModelId) => RerankingModelV3;
    rerankingModel: (modelId: VoyageRerankingModelId) => RerankingModelV3;
}
interface VoyageProviderSettings {
    /**
     * Use a different URL prefix for API calls, e.g. to use proxy servers.
     * The default prefix is `https://api.voyageai.com/v1`.
     *
     * @see https://docs.voyageai.com/reference
     */
    baseURL?: string;
    /**
    API key that is being send using the `Authorization` header.
    It defaults to the `VOYAGE_API_KEY` environment variable.
       */
    apiKey?: string;
    /**
    Custom headers to include in the requests.
         */
    headers?: Record<string, string>;
    /**
    Custom fetch implementation. You can use it as a middleware to intercept requests,
    or to provide a custom fetch implementation for e.g. testing.
        */
    fetch?: FetchFunction;
}
/**
  Create a Voyage AI provider instance.
   */
declare function createVoyage(options?: VoyageProviderSettings): VoyageProvider;
/**
  Default Voyage provider instance.
   */
declare const voyage: VoyageProvider;

type VoyageEmbeddingConfig = {
    baseURL: string;
    fetch?: FetchFunction;
    headers: () => Record<string, string | undefined>;
    provider: string;
};
type ImageInput = string;
type TextInput = string;
type ContentItem = {
    type: 'text';
    text: string;
} | {
    type: 'image_url';
    image_url: string;
} | {
    type: 'image_base64';
    image_base64: string;
};
type MultimodalContent = {
    text?: TextInput[];
    image?: ImageInput[];
};
type TextEmbeddingInput = TextInput | TextInput[] | {
    text: TextInput | TextInput[];
};
type ImageEmbeddingInput = ImageInput | ImageInput[] | {
    image: ImageInput | ImageInput[];
};
type MultimodalEmbeddingInput = TextInput | ImageInput | TextInput[] | ImageInput[] | MultimodalContent | {
    text: TextInput | TextInput[];
} | {
    image: ImageInput | ImageInput[];
} | {
    content: ContentItem[];
};
declare class MultimodalEmbeddingModel implements EmbeddingModelV3 {
    readonly specificationVersion = "v3";
    readonly modelId: VoyageMultimodalEmbeddingModelId;
    readonly modelType: 'multimodal' | 'image';
    private readonly config;
    get provider(): string;
    get maxEmbeddingsPerCall(): number;
    get supportsParallelCalls(): boolean;
    constructor(modelId: VoyageMultimodalEmbeddingModelId, config: VoyageEmbeddingConfig, modelType: 'multimodal' | 'image');
    private transformInputs;
    private transformSingleInput;
    private transformArrayInput;
    private transformContentArray;
    private transformMultimodalContent;
    private createTextContent;
    private createImageContent;
    private createImageContentItem;
    private isImageString;
    private isImageUrl;
    private isBase64Image;
    doEmbed({ abortSignal, values, headers, providerOptions, }: Parameters<EmbeddingModelV3['doEmbed']>[0]): Promise<Awaited<ReturnType<EmbeddingModelV3['doEmbed']>>>;
}

export { type ImageEmbeddingInput, type MultimodalEmbeddingInput, MultimodalEmbeddingModel, type TextEmbeddingInput, type VoyageEmbeddingOptions, type VoyageMultimodalEmbeddingOptions, type VoyageProvider, type VoyageProviderSettings, type VoyageRerankingOptions, createVoyage, voyage };
