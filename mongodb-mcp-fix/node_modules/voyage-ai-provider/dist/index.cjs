"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  createVoyage: () => createVoyage,
  voyage: () => voyage
});
module.exports = __toCommonJS(index_exports);

// src/voyage-provider.ts
var import_provider_utils7 = require("@ai-sdk/provider-utils");

// src/voyage-embedding-model.ts
var import_provider = require("@ai-sdk/provider");
var import_provider_utils2 = require("@ai-sdk/provider-utils");
var import_v43 = require("zod/v4");

// src/voyage-embedding-settings.ts
var import_v4 = require("zod/v4");
var voyageEmbeddingOptions = import_v4.z.object({
  /**
   * The input type for the embeddings. Defaults to "query".
   * For query, the prompt is "Represent the query for retrieving supporting documents: ".
   * For document, the prompt is "Represent the document for retrieval: ".
   */
  inputType: import_v4.z.enum(["query", "document"]).optional(),
  // /**
  //  * Format in which the embeddings are encoded. We support two options:
  //  * If not specified (defaults to null): the embeddings are represented as lists of floating-point numbers;
  //  * base64: the embeddings are compressed to base64 encodings.
  //  */
  // encodingFormat?: 'base64';
  /**
   * The number of dimensions for the resulting output embeddings.
   *
   * If not specified (defaults to null), the resulting output embeddings dimension is the default for the model.
   * `voyage-code-3` supports the following `outputDimension` values: 2048, 1024 (default), 512, and 256.
   * `voyage-3-large` supports the following `outputDimension` values: 2048, 1024 (default), 512, and 256.
   *
   * please refer to the model documentation for the supported values.
   * https://docs.voyageai.com/docs/embeddings
   */
  outputDimension: import_v4.z.number().optional(),
  /**
   * The data type for the resulting output embeddings.
   *
   * Defaults to 'float'.
   *
   * Other options: 'int8', 'uint8', 'binary', 'ubinary'.
   * - 'float' is supported by all models.
   * - 'float': Each returned embedding is a list of 32-bit (4-byte) single-precision floating-point numbers.
   * - 'int8', 'uint8', 'binary', and 'ubinary' are supported by 'voyage-code-3'.
   * - 'int8' and 'uint8': Each returned embedding is a list of 8-bit (1-byte) integers ranging from -128 to 127 and 0 to 255, respectively.
   * - 'binary' and 'ubinary': Each returned embedding is a list of 8-bit integers that represent bit-packed, quantized single-bit embedding values:
   *   'int8' for 'binary' and 'uint8' for 'ubinary'.
   *   The length of the returned list of integers is 1/8 of outputDimension (which is the actual dimension of the embedding).
   *   The 'binary' type uses the offset binary method.
   *
   * https://docs.voyageai.com/docs/faq#what-is-quantization-and-output-data-types
   */
  outputDtype: import_v4.z.enum(["float", "int8", "uint8", "binary", "ubinary"]).optional(),
  /**
   *  Whether to truncate the input texts to fit within the context length.
   */
  truncation: import_v4.z.boolean().optional()
});

// src/voyage-error.ts
var import_provider_utils = require("@ai-sdk/provider-utils");
var import_v42 = require("zod/v4");
var voyageErrorDataSchema = import_v42.z.object({
  error: import_v42.z.object({
    code: import_v42.z.string().nullable(),
    message: import_v42.z.string(),
    param: import_v42.z.any().nullable(),
    type: import_v42.z.string()
  })
});
var voyageFailedResponseHandler = (0, import_provider_utils.createJsonErrorResponseHandler)({
  errorSchema: voyageErrorDataSchema,
  errorToMessage: (data) => data.error.message
});

// src/voyage-embedding-model.ts
var VoyageEmbeddingModel = class {
  specificationVersion = "v3";
  modelId;
  config;
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    return 128;
  }
  get supportsParallelCalls() {
    return false;
  }
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
  }
  async doEmbed({
    abortSignal,
    values,
    headers,
    providerOptions
  }) {
    const embeddingOptions = await (0, import_provider_utils2.parseProviderOptions)({
      provider: "voyage",
      providerOptions,
      schema: voyageEmbeddingOptions
    });
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new import_provider.TooManyEmbeddingValuesForCallError({
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        modelId: this.modelId,
        provider: this.provider,
        values
      });
    }
    const {
      responseHeaders,
      value: response,
      rawValue
    } = await (0, import_provider_utils2.postJsonToApi)({
      abortSignal,
      body: {
        input: values,
        model: this.modelId,
        input_type: embeddingOptions?.inputType,
        truncation: embeddingOptions?.truncation,
        output_dimension: embeddingOptions?.outputDimension,
        output_dtype: embeddingOptions?.outputDtype
      },
      failedResponseHandler: voyageFailedResponseHandler,
      fetch: this.config.fetch,
      headers: (0, import_provider_utils2.combineHeaders)(this.config.headers(), headers),
      successfulResponseHandler: (0, import_provider_utils2.createJsonResponseHandler)(
        voyageTextEmbeddingResponseSchema
      ),
      url: `${this.config.baseURL}/embeddings`
    });
    return {
      embeddings: response.data.map((item) => item.embedding),
      usage: response.usage ? { tokens: response.usage.total_tokens } : void 0,
      response: { headers: responseHeaders, body: rawValue },
      warnings: []
    };
  }
};
var voyageTextEmbeddingResponseSchema = import_v43.z.object({
  data: import_v43.z.array(import_v43.z.object({ embedding: import_v43.z.array(import_v43.z.number()) })),
  usage: import_v43.z.object({ total_tokens: import_v43.z.number() }).nullish()
});

// src/voyage-multimodal-embedding-model.ts
var import_provider2 = require("@ai-sdk/provider");
var import_provider_utils3 = require("@ai-sdk/provider-utils");

// src/voyage-multimodal-embedding-settings.ts
var import_v44 = require("zod/v4");
var voyageMultimodalEmbeddingOptions = import_v44.z.object({
  /**
   * Type of the input.
   * Defaults to "query".
   *
   * When input_type is specified as "query" or "document", Voyage automatically prepends a prompt
   * to your inputs before vectorize them, creating vectors more tailored for retrieval/search tasks.
   *
   * For retrieval/search purposes where a query is used to search through documents, we recommend
   * specifying whether your inputs are queries or documents. Since inputs can be multimodal,
   * "queries" and "documents" can be text, images, or an interleaving of both modalities.
   *
   * For transparency, the following prompts are prepended:
   * - For "query": "Represent the query for retrieving supporting documents: "
   * - For "document": "Represent the document for retrieval: "
   */
  inputType: import_v44.z.enum(["query", "document"]).optional(),
  /**
   * The data type for the resulting output embeddings.
   *
   * Defaults to null.
   *
   * - If null, the embeddings are represented as a list of floating-point numbers.
   * - If base64, the embeddings are represented as a Base64-encoded NumPy array of single-precision floats.
   *
   * https://docs.voyageai.com/docs/faq#what-is-quantization-and-output-data-types
   */
  outputEncoding: import_v44.z.enum(["base64"]).optional(),
  /**
   *  Whether to truncate the input texts to fit within the context length.
   *
   *  Defaults to true.
   */
  truncation: import_v44.z.boolean().optional()
});

// src/voyage-multimodal-embedding-model.ts
var import_v45 = require("zod/v4");
var MultimodalEmbeddingModel = class {
  specificationVersion = "v3";
  modelId;
  modelType;
  config;
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    return 128;
  }
  get supportsParallelCalls() {
    return false;
  }
  constructor(modelId, config, modelType) {
    this.modelId = modelId;
    this.config = config;
    this.modelType = modelType;
  }
  transformInputs(values) {
    return values.map((value) => this.transformSingleInput(value));
  }
  transformSingleInput(value) {
    let parsedValue = value;
    try {
      parsedValue = JSON.parse(value);
    } catch {
    }
    if (typeof parsedValue === "string") {
      if (this.modelType === "image") {
        return this.createImageContent(parsedValue);
      }
      if (this.isImageString(parsedValue)) {
        return this.createImageContent(parsedValue);
      }
      return this.createTextContent(parsedValue);
    }
    if (Array.isArray(parsedValue)) {
      return this.transformArrayInput(parsedValue);
    }
    const input = parsedValue;
    if (input.content && Array.isArray(input.content)) {
      return this.transformContentArray(input.content);
    }
    if (input.text || input.image) {
      return this.transformMultimodalContent(input);
    }
    if (this.modelType === "multimodal") {
      return this.createTextContent(String(parsedValue));
    }
    throw new Error(
      `Unsupported input format for ${this.modelType} model: ${JSON.stringify(parsedValue)}`
    );
  }
  transformArrayInput(array) {
    const contentItems = [];
    for (const item of array) {
      if (typeof item === "string") {
        if (this.isImageString(item)) {
          contentItems.push(this.createImageContentItem(item));
        } else {
          if (this.modelType === "image") {
            throw new Error(
              "Text content not supported in image embedding model"
            );
          }
          contentItems.push({ type: "text", text: item });
        }
      } else {
        throw new Error("Array items must be strings");
      }
    }
    return { content: contentItems };
  }
  transformContentArray(content) {
    const contentItems = [];
    for (const item of content) {
      const contentItem = item;
      if (contentItem.type && (contentItem.text || contentItem.image_url || contentItem.image_base64)) {
        contentItems.push(contentItem);
        continue;
      }
      if (contentItem.text && Array.isArray(contentItem.text)) {
        if (this.modelType === "image") {
          throw new Error(
            "Text content not supported in image embedding model"
          );
        }
        for (const textItem of contentItem.text) {
          contentItems.push({ type: "text", text: String(textItem) });
        }
      }
      if (contentItem.image && Array.isArray(contentItem.image)) {
        for (const imageItem of contentItem.image) {
          const imageStr = String(imageItem);
          contentItems.push(this.createImageContentItem(imageStr));
        }
      }
      if (typeof contentItem.text === "string") {
        if (this.modelType === "image") {
          throw new Error(
            "Text content not supported in image embedding model"
          );
        }
        contentItems.push({ type: "text", text: contentItem.text });
      }
      if (typeof contentItem.image === "string") {
        contentItems.push(this.createImageContentItem(contentItem.image));
      }
    }
    return { content: contentItems };
  }
  transformMultimodalContent(input) {
    const contentItems = [];
    if (input.text !== void 0) {
      if (this.modelType === "image") {
        throw new Error("Text content not supported in image embedding model");
      }
      if (Array.isArray(input.text)) {
        for (const textItem of input.text) {
          contentItems.push({ type: "text", text: String(textItem) });
        }
      } else if (typeof input.text === "string") {
        contentItems.push({ type: "text", text: input.text });
      }
    }
    if (input.image !== void 0) {
      if (Array.isArray(input.image)) {
        for (const imageItem of input.image) {
          const imageStr = String(imageItem);
          contentItems.push(this.createImageContentItem(imageStr));
        }
      } else if (typeof input.image === "string") {
        contentItems.push(this.createImageContentItem(input.image));
      }
    }
    return { content: contentItems };
  }
  createTextContent(text) {
    return {
      content: [{ type: "text", text }]
    };
  }
  createImageContent(image) {
    return {
      content: [this.createImageContentItem(image)]
    };
  }
  createImageContentItem(image) {
    return this.isBase64Image(image) ? { type: "image_base64", image_base64: image } : { type: "image_url", image_url: image };
  }
  isImageString(str) {
    return this.isBase64Image(str) || this.isImageUrl(str);
  }
  isImageUrl(str) {
    try {
      const url = new URL(str);
      return /\.(jpg|jpeg|png|gif|bmp|webp|svg)$/i.test(url.pathname);
    } catch {
      return false;
    }
  }
  isBase64Image(image) {
    return image.startsWith("data:image/") && image.includes(";base64,");
  }
  async doEmbed({
    abortSignal,
    values,
    headers,
    providerOptions
  }) {
    const embeddingOptions = await (0, import_provider_utils3.parseProviderOptions)({
      provider: "voyage",
      providerOptions,
      schema: voyageMultimodalEmbeddingOptions
    });
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new import_provider2.TooManyEmbeddingValuesForCallError({
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        modelId: this.modelId,
        provider: this.provider,
        values
      });
    }
    const transformedInputs = this.transformInputs(values);
    const {
      responseHeaders,
      value: response,
      rawValue
    } = await (0, import_provider_utils3.postJsonToApi)({
      abortSignal,
      body: {
        inputs: transformedInputs,
        model: this.modelId,
        input_type: embeddingOptions?.inputType,
        truncation: embeddingOptions?.truncation,
        output_encoding: embeddingOptions?.outputEncoding
      },
      failedResponseHandler: voyageFailedResponseHandler,
      fetch: this.config.fetch,
      headers: (0, import_provider_utils3.combineHeaders)(this.config.headers(), headers),
      successfulResponseHandler: (0, import_provider_utils3.createJsonResponseHandler)(
        voyageMultimodalEmbeddingResponseSchema
      ),
      url: `${this.config.baseURL}/multimodalembeddings`
    });
    return {
      embeddings: response.data.map((item) => item.embedding),
      usage: response.usage ? { tokens: response.usage.total_tokens } : void 0,
      response: { headers: responseHeaders, body: rawValue },
      warnings: []
    };
  }
};
var voyageMultimodalEmbeddingResponseSchema = import_v45.z.object({
  data: import_v45.z.array(
    import_v45.z.object({
      object: import_v45.z.literal("embedding"),
      embedding: import_v45.z.array(import_v45.z.number()),
      index: import_v45.z.number()
    })
  ),
  usage: import_v45.z.object({
    text_tokens: import_v45.z.number().nullish(),
    image_pixels: import_v45.z.number().nullish(),
    total_tokens: import_v45.z.number()
  }),
  model: import_v45.z.string()
});

// src/reranking/voyage-reranking-model.ts
var import_provider_utils6 = require("@ai-sdk/provider-utils");

// src/reranking/voyage-reranking-api.ts
var import_provider_utils4 = require("@ai-sdk/provider-utils");
var import_v46 = require("zod/v4");
var voyageRerankingResponseSchema = (0, import_provider_utils4.lazySchema)(
  () => (0, import_provider_utils4.zodSchema)(
    import_v46.z.object({
      object: import_v46.z.literal("list"),
      data: import_v46.z.array(
        import_v46.z.object({
          relevance_score: import_v46.z.number(),
          index: import_v46.z.number()
        })
      ),
      model: import_v46.z.string(),
      usage: import_v46.z.object({
        total_tokens: import_v46.z.number()
      })
    })
  )
);

// src/reranking/voyage-reranking-options.ts
var import_provider_utils5 = require("@ai-sdk/provider-utils");
var import_v47 = require("zod/v4");
var voyageRerankingOptionsSchema = (0, import_provider_utils5.lazySchema)(
  () => (0, import_provider_utils5.zodSchema)(
    import_v47.z.object({
      returnDocuments: import_v47.z.boolean().optional(),
      truncation: import_v47.z.boolean().optional()
    })
  )
);

// src/reranking/voyage-reranking-model.ts
var VoyageRerankingModel = class {
  specificationVersion = "v3";
  modelId;
  config;
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  // current implementation is based on the API:https://docs.voyageai.com/reference/reranker-api
  async doRerank({
    documents,
    headers,
    query,
    topN,
    abortSignal,
    providerOptions
  }) {
    const rerankingOptions = await (0, import_provider_utils6.parseProviderOptions)({
      provider: "voyage",
      providerOptions,
      schema: voyageRerankingOptionsSchema
    });
    const warnings = [];
    const {
      responseHeaders,
      value: response,
      rawValue
    } = await (0, import_provider_utils6.postJsonToApi)({
      url: `${this.config.baseURL}/rerank`,
      headers: (0, import_provider_utils6.combineHeaders)(this.config.headers(), headers),
      body: {
        model: this.modelId,
        query,
        documents: documents.type === "text" ? documents.values : documents.values.map((value) => JSON.stringify(value)),
        top_k: topN,
        return_documents: rerankingOptions?.returnDocuments ?? false,
        truncation: rerankingOptions?.truncation ?? true
      },
      failedResponseHandler: voyageFailedResponseHandler,
      successfulResponseHandler: (0, import_provider_utils6.createJsonResponseHandler)(
        voyageRerankingResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      ranking: response.data.map((result) => ({
        index: result.index,
        relevanceScore: result.relevance_score
      })),
      warnings: warnings.length > 0 ? warnings : void 0,
      response: {
        headers: responseHeaders,
        body: rawValue
      }
    };
  }
};

// src/voyage-provider.ts
function createVoyage(options = {}) {
  const baseURL = (0, import_provider_utils7.withoutTrailingSlash)(options.baseURL) ?? "https://api.voyageai.com/v1";
  const getHeaders = () => ({
    Authorization: `Bearer ${(0, import_provider_utils7.loadApiKey)({
      apiKey: options.apiKey,
      environmentVariableName: "VOYAGE_API_KEY",
      description: "Voyage"
    })}`,
    ...options.headers
  });
  const createEmbeddingModel = (modelId) => new VoyageEmbeddingModel(modelId, {
    provider: "voyage.embedding",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createImageEmbeddingModel = (modelId) => new MultimodalEmbeddingModel(
    modelId,
    {
      provider: "voyage.image.embedding",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    },
    "image"
  );
  const createMultimodalEmbeddingModel = (modelId) => new MultimodalEmbeddingModel(
    modelId,
    {
      provider: "voyage.multimodal.embedding",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    },
    "multimodal"
  );
  const createRerankingModel = (modelId) => new VoyageRerankingModel(modelId, {
    provider: "voyage.reranking",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Voyage model function cannot be called with the new keyword."
      );
    }
    return createEmbeddingModel(modelId);
  };
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.imageEmbeddingModel = createImageEmbeddingModel;
  provider.multimodalEmbeddingModel = createMultimodalEmbeddingModel;
  provider.chat = provider.languageModel = () => {
    throw new Error("languageModel method is not implemented.");
  };
  provider.imageModel = () => {
    throw new Error("imageModel method is not implemented.");
  };
  provider.reranking = createRerankingModel;
  provider.rerankingModel = createRerankingModel;
  return provider;
}
var voyage = createVoyage();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createVoyage,
  voyage
});
//# sourceMappingURL=index.cjs.map