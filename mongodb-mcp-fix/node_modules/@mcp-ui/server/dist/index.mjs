function g(e, t, n) {
  function r(s, l) {
    var u;
    Object.defineProperty(s, "_zod", {
      value: s._zod ?? {},
      enumerable: !1
    }), (u = s._zod).traits ?? (u.traits = /* @__PURE__ */ new Set()), s._zod.traits.add(e), t(s, l);
    for (const d in o.prototype)
      d in s || Object.defineProperty(s, d, { value: o.prototype[d].bind(s) });
    s._zod.constr = o, s._zod.def = l;
  }
  const i = n?.Parent ?? Object;
  class a extends i {
  }
  Object.defineProperty(a, "name", { value: e });
  function o(s) {
    var l;
    const u = n?.Parent ? new a() : this;
    r(u, s), (l = u._zod).deferred ?? (l.deferred = []);
    for (const d of u._zod.deferred)
      d();
    return u;
  }
  return Object.defineProperty(o, "init", { value: r }), Object.defineProperty(o, Symbol.hasInstance, {
    value: (s) => n?.Parent && s instanceof n.Parent ? !0 : s?._zod?.traits?.has(e)
  }), Object.defineProperty(o, "name", { value: e }), o;
}
class tt extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
const so = {};
function $e(e) {
  return so;
}
function Hm(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, i]) => t.indexOf(+r) === -1).map(([r, i]) => i);
}
function Xm(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function bn(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function _n(e) {
  return e == null;
}
function yn(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function Ym(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, a = Number.parseInt(e.toFixed(i).replace(".", "")), o = Number.parseInt(t.toFixed(i).replace(".", ""));
  return a % o / 10 ** i;
}
function M(e, t, n) {
  Object.defineProperty(e, t, {
    get() {
      {
        const r = n();
        return e[t] = r, r;
      }
    },
    set(r) {
      Object.defineProperty(e, t, {
        value: r
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function oi(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function uo(e = 10) {
  const t = "abcdefghijklmnopqrstuvwxyz";
  let n = "";
  for (let r = 0; r < e; r++)
    n += t[Math.floor(Math.random() * t.length)];
  return n;
}
function He(e) {
  return JSON.stringify(e);
}
const lo = Error.captureStackTrace ? Error.captureStackTrace : (...e) => {
};
function Gt(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const Qm = bn(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function un(e) {
  if (Gt(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(Gt(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
const ep = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function ut(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Ze(e, t, n) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (r._zod.parent = e), r;
}
function I(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function tp(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const ip = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function np(e, t) {
  const n = {}, r = e._zod.def;
  for (const i in t) {
    if (!(i in r.shape))
      throw new Error(`Unrecognized key: "${i}"`);
    t[i] && (n[i] = r.shape[i]);
  }
  return Ze(e, {
    ...e._zod.def,
    shape: n,
    checks: []
  });
}
function rp(e, t) {
  const n = { ...e._zod.def.shape }, r = e._zod.def;
  for (const i in t) {
    if (!(i in r.shape))
      throw new Error(`Unrecognized key: "${i}"`);
    t[i] && delete n[i];
  }
  return Ze(e, {
    ...e._zod.def,
    shape: n,
    checks: []
  });
}
function ap(e, t) {
  const n = {
    ...e._zod.def,
    get shape() {
      const r = { ...e._zod.def.shape, ...t };
      return oi(this, "shape", r), r;
    },
    checks: []
    // delete existing checks
  };
  return Ze(e, n);
}
function op(e, t) {
  return Ze(e, {
    ...e._zod.def,
    get shape() {
      const n = { ...e._zod.def.shape, ...t._zod.def.shape };
      return oi(this, "shape", n), n;
    },
    catchall: t._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function sp(e, t, n) {
  const r = t._zod.def.shape, i = { ...r };
  if (n)
    for (const a in n) {
      if (!(a in r))
        throw new Error(`Unrecognized key: "${a}"`);
      n[a] && (i[a] = e ? new e({
        type: "optional",
        innerType: r[a]
      }) : r[a]);
    }
  else
    for (const a in r)
      i[a] = e ? new e({
        type: "optional",
        innerType: r[a]
      }) : r[a];
  return Ze(t, {
    ...t._zod.def,
    shape: i,
    checks: []
  });
}
function up(e, t, n) {
  const r = t._zod.def.shape, i = { ...r };
  if (n)
    for (const a in n) {
      if (!(a in i))
        throw new Error(`Unrecognized key: "${a}"`);
      n[a] && (i[a] = new e({
        type: "nonoptional",
        innerType: r[a]
      }));
    }
  else
    for (const a in r)
      i[a] = new e({
        type: "nonoptional",
        innerType: r[a]
      });
  return Ze(t, {
    ...t._zod.def,
    shape: i,
    // optional: [],
    checks: []
  });
}
function et(e, t = 0) {
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n].continue !== !0)
      return !0;
  return !1;
}
function xe(e, t) {
  return t.map((n) => {
    var r;
    return (r = n).path ?? (r.path = []), n.path.unshift(e), n;
  });
}
function Mt(e) {
  return typeof e == "string" ? e : e?.message;
}
function Ie(e, t, n) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const i = Mt(e.inst?._zod.def?.error?.(e)) ?? Mt(t?.error?.(e)) ?? Mt(n.customError?.(e)) ?? Mt(n.localeError?.(e)) ?? "Invalid input";
    r.message = i;
  }
  return delete r.inst, delete r.continue, t?.reportInput || delete r.input, r;
}
function $n(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function it(...e) {
  const [t, n, r] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: r
  } : { ...t };
}
const co = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), Object.defineProperty(e, "message", {
    get() {
      return JSON.stringify(t, Xm, 2);
    },
    enumerable: !0
    // configurable: false,
  });
}, mo = g("$ZodError", co), po = g("$ZodError", co, { Parent: Error });
function lp(e, t = (n) => n.message) {
  const n = {}, r = [];
  for (const i of e.issues)
    i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
  return { formErrors: r, fieldErrors: n };
}
function cp(e, t) {
  const n = t || function(a) {
    return a.message;
  }, r = { _errors: [] }, i = (a) => {
    for (const o of a.issues)
      if (o.code === "invalid_union" && o.errors.length)
        o.errors.map((s) => i({ issues: s }));
      else if (o.code === "invalid_key")
        i({ issues: o.issues });
      else if (o.code === "invalid_element")
        i({ issues: o.issues });
      else if (o.path.length === 0)
        r._errors.push(n(o));
      else {
        let s = r, l = 0;
        for (; l < o.path.length; ) {
          const u = o.path[l];
          l === o.path.length - 1 ? (s[u] = s[u] || { _errors: [] }, s[u]._errors.push(n(o))) : s[u] = s[u] || { _errors: [] }, s = s[u], l++;
        }
      }
  };
  return i(e), r;
}
const dp = (e) => (t, n, r, i) => {
  const a = r ? Object.assign(r, { async: !1 }) : { async: !1 }, o = t._zod.run({ value: n, issues: [] }, a);
  if (o instanceof Promise)
    throw new tt();
  if (o.issues.length) {
    const s = new (i?.Err ?? e)(o.issues.map((l) => Ie(l, a, $e())));
    throw lo(s, i?.callee), s;
  }
  return o.value;
}, mp = (e) => async (t, n, r, i) => {
  const a = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let o = t._zod.run({ value: n, issues: [] }, a);
  if (o instanceof Promise && (o = await o), o.issues.length) {
    const s = new (i?.Err ?? e)(o.issues.map((l) => Ie(l, a, $e())));
    throw lo(s, i?.callee), s;
  }
  return o.value;
}, fo = (e) => (t, n, r) => {
  const i = r ? { ...r, async: !1 } : { async: !1 }, a = t._zod.run({ value: n, issues: [] }, i);
  if (a instanceof Promise)
    throw new tt();
  return a.issues.length ? {
    success: !1,
    error: new (e ?? mo)(a.issues.map((o) => Ie(o, i, $e())))
  } : { success: !0, data: a.value };
}, pp = /* @__PURE__ */ fo(po), go = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let a = t._zod.run({ value: n, issues: [] }, i);
  return a instanceof Promise && (a = await a), a.issues.length ? {
    success: !1,
    error: new e(a.issues.map((o) => Ie(o, i, $e())))
  } : { success: !0, data: a.value };
}, fp = /* @__PURE__ */ go(po), gp = /^[cC][^\s-]{8,}$/, hp = /^[0-9a-z]+$/, vp = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, bp = /^[0-9a-vA-V]{20}$/, _p = /^[A-Za-z0-9]{27}$/, yp = /^[a-zA-Z0-9_-]{21}$/, $p = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, Ip = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Sa = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/, kp = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, wp = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Sp() {
  return new RegExp(wp, "u");
}
const zp = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, xp = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/, Op = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Up = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, jp = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, ho = /^[A-Za-z0-9_-]*$/, Pp = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/, Np = /^\+(?:[0-9]){6,14}[0-9]$/, vo = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", Zp = /* @__PURE__ */ new RegExp(`^${vo}$`);
function bo(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function Dp(e) {
  return new RegExp(`^${bo(e)}$`);
}
function Ep(e) {
  const t = bo({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-]\\d{2}:\\d{2})");
  const r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${vo}T(?:${r})$`);
}
const Ap = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, Tp = /^\d+$/, Rp = /^-?\d+(?:\.\d+)?/i, Cp = /true|false/i, Mp = /null/i, Lp = /^[^A-Z]*$/, Fp = /^[^a-z]*$/, re = /* @__PURE__ */ g("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), _o = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, yo = /* @__PURE__ */ g("$ZodCheckLessThan", (e, t) => {
  re.init(e, t);
  const n = _o[typeof t.value];
  e._zod.onattach.push((r) => {
    const i = r._zod.bag, a = (t.inclusive ? i.maximum : i.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < a && (t.inclusive ? i.maximum = t.value : i.exclusiveMaximum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value <= t.value : r.value < t.value) || r.issues.push({
      origin: n,
      code: "too_big",
      maximum: t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), $o = /* @__PURE__ */ g("$ZodCheckGreaterThan", (e, t) => {
  re.init(e, t);
  const n = _o[typeof t.value];
  e._zod.onattach.push((r) => {
    const i = r._zod.bag, a = (t.inclusive ? i.minimum : i.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > a && (t.inclusive ? i.minimum = t.value : i.exclusiveMinimum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value >= t.value : r.value > t.value) || r.issues.push({
      origin: n,
      code: "too_small",
      minimum: t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Jp = /* @__PURE__ */ g("$ZodCheckMultipleOf", (e, t) => {
  re.init(e, t), e._zod.onattach.push((n) => {
    var r;
    (r = n._zod.bag).multipleOf ?? (r.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : Ym(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), qp = /* @__PURE__ */ g("$ZodCheckNumberFormat", (e, t) => {
  re.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), r = n ? "int" : "number", [i, a] = ip[t.format];
  e._zod.onattach.push((o) => {
    const s = o._zod.bag;
    s.format = t.format, s.minimum = i, s.maximum = a, n && (s.pattern = Tp);
  }), e._zod.check = (o) => {
    const s = o.value;
    if (n) {
      if (!Number.isInteger(s)) {
        o.issues.push({
          expected: r,
          format: t.format,
          code: "invalid_type",
          input: s,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(s)) {
        s > 0 ? o.issues.push({
          input: s,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          continue: !t.abort
        }) : o.issues.push({
          input: s,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          continue: !t.abort
        });
        return;
      }
    }
    s < i && o.issues.push({
      origin: "number",
      input: s,
      code: "too_small",
      minimum: i,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), s > a && o.issues.push({
      origin: "number",
      input: s,
      code: "too_big",
      maximum: a,
      inst: e
    });
  };
}), Wp = /* @__PURE__ */ g("$ZodCheckMaxLength", (e, t) => {
  re.init(e, t), e._zod.when = (n) => {
    const r = n.value;
    return !_n(r) && r.length !== void 0;
  }, e._zod.onattach.push((n) => {
    const r = n._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < r && (n._zod.bag.maximum = t.maximum);
  }), e._zod.check = (n) => {
    const r = n.value;
    if (r.length <= t.maximum)
      return;
    const a = $n(r);
    n.issues.push({
      origin: a,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: r,
      inst: e,
      continue: !t.abort
    });
  };
}), Kp = /* @__PURE__ */ g("$ZodCheckMinLength", (e, t) => {
  re.init(e, t), e._zod.when = (n) => {
    const r = n.value;
    return !_n(r) && r.length !== void 0;
  }, e._zod.onattach.push((n) => {
    const r = n._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > r && (n._zod.bag.minimum = t.minimum);
  }), e._zod.check = (n) => {
    const r = n.value;
    if (r.length >= t.minimum)
      return;
    const a = $n(r);
    n.issues.push({
      origin: a,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: r,
      inst: e,
      continue: !t.abort
    });
  };
}), Vp = /* @__PURE__ */ g("$ZodCheckLengthEquals", (e, t) => {
  re.init(e, t), e._zod.when = (n) => {
    const r = n.value;
    return !_n(r) && r.length !== void 0;
  }, e._zod.onattach.push((n) => {
    const r = n._zod.bag;
    r.minimum = t.length, r.maximum = t.length, r.length = t.length;
  }), e._zod.check = (n) => {
    const r = n.value, i = r.length;
    if (i === t.length)
      return;
    const a = $n(r), o = i > t.length;
    n.issues.push({
      origin: a,
      ...o ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), si = /* @__PURE__ */ g("$ZodCheckStringFormat", (e, t) => {
  var n;
  re.init(e, t), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.format = t.format, t.pattern && (i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(t.pattern));
  }), (n = e._zod).check ?? (n.check = (r) => {
    if (!t.pattern)
      throw new Error("Not implemented.");
    t.pattern.lastIndex = 0, !t.pattern.test(r.value) && r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: r.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  });
}), Gp = /* @__PURE__ */ g("$ZodCheckRegex", (e, t) => {
  si.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), Bp = /* @__PURE__ */ g("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = Lp), si.init(e, t);
}), Hp = /* @__PURE__ */ g("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = Fp), si.init(e, t);
}), Xp = /* @__PURE__ */ g("$ZodCheckIncludes", (e, t) => {
  re.init(e, t);
  const n = ut(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = r, e._zod.onattach.push((i) => {
    const a = i._zod.bag;
    a.patterns ?? (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(r);
  }), e._zod.check = (i) => {
    i.value.includes(t.includes, t.position) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Yp = /* @__PURE__ */ g("$ZodCheckStartsWith", (e, t) => {
  re.init(e, t);
  const n = new RegExp(`^${ut(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Qp = /* @__PURE__ */ g("$ZodCheckEndsWith", (e, t) => {
  re.init(e, t);
  const n = new RegExp(`.*${ut(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), ef = /* @__PURE__ */ g("$ZodCheckOverwrite", (e, t) => {
  re.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class tf {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const r = t.split(`
`).filter((o) => o), i = Math.min(...r.map((o) => o.length - o.trimStart().length)), a = r.map((o) => o.slice(i)).map((o) => " ".repeat(this.indent * 2) + o);
    for (const o of a)
      this.content.push(o);
  }
  compile() {
    const t = Function, n = this?.args, i = [...(this?.content ?? [""]).map((a) => `  ${a}`)];
    return new t(...n, i.join(`
`));
  }
}
const nf = {
  major: 4,
  minor: 0,
  patch: 0
}, R = /* @__PURE__ */ g("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), M(e._zod, "id", () => t.type + "_" + uo(10)), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = nf;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const i of r)
    for (const a of i._zod.onattach)
      a(e);
  if (r.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const i = (a, o, s) => {
      let l = et(a), u;
      for (const d of o) {
        if (d._zod.when) {
          if (!d._zod.when(a))
            continue;
        } else if (l)
          continue;
        const f = a.issues.length, h = d._zod.check(a);
        if (h instanceof Promise && s?.async === !1)
          throw new tt();
        if (u || h instanceof Promise)
          u = (u ?? Promise.resolve()).then(async () => {
            await h, a.issues.length !== f && (l || (l = et(a, f)));
          });
        else {
          if (a.issues.length === f)
            continue;
          l || (l = et(a, f));
        }
      }
      return u ? u.then(() => a) : a;
    };
    e._zod.run = (a, o) => {
      const s = e._zod.parse(a, o);
      if (s instanceof Promise) {
        if (o.async === !1)
          throw new tt();
        return s.then((l) => i(l, r, o));
      }
      return i(s, r, o);
    };
  }
  e["~standard"] = {
    validate: (i) => {
      try {
        const a = pp(e, i);
        return a.success ? { value: a.data } : { issues: a.error?.issues };
      } catch {
        return fp(e, i).then((o) => o.success ? { value: o.data } : { issues: o.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), In = /* @__PURE__ */ g("$ZodString", (e, t) => {
  R.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? Ap(e._zod.bag), e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), L = /* @__PURE__ */ g("$ZodStringFormat", (e, t) => {
  si.init(e, t), In.init(e, t);
}), rf = /* @__PURE__ */ g("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = Ip), L.init(e, t);
}), af = /* @__PURE__ */ g("$ZodUUID", (e, t) => {
  if (t.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = Sa(r));
  } else
    t.pattern ?? (t.pattern = Sa());
  L.init(e, t);
}), of = /* @__PURE__ */ g("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = kp), L.init(e, t);
}), sf = /* @__PURE__ */ g("$ZodURL", (e, t) => {
  L.init(e, t), e._zod.check = (n) => {
    try {
      const r = new URL(n.value);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(r.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: Pp.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(r.protocol.endsWith(":") ? r.protocol.slice(0, -1) : r.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      }));
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), uf = /* @__PURE__ */ g("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = Sp()), L.init(e, t);
}), lf = /* @__PURE__ */ g("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = yp), L.init(e, t);
}), cf = /* @__PURE__ */ g("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = gp), L.init(e, t);
}), df = /* @__PURE__ */ g("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = hp), L.init(e, t);
}), mf = /* @__PURE__ */ g("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = vp), L.init(e, t);
}), pf = /* @__PURE__ */ g("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = bp), L.init(e, t);
}), ff = /* @__PURE__ */ g("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = _p), L.init(e, t);
}), gf = /* @__PURE__ */ g("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = Ep(t)), L.init(e, t), e._zod.check;
}), hf = /* @__PURE__ */ g("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = Zp), L.init(e, t);
}), vf = /* @__PURE__ */ g("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = Dp(t)), L.init(e, t), e._zod.check;
}), bf = /* @__PURE__ */ g("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = $p), L.init(e, t);
}), _f = /* @__PURE__ */ g("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = zp), L.init(e, t), e._zod.onattach.push((n) => {
    const r = n._zod.bag;
    r.format = "ipv4";
  });
}), yf = /* @__PURE__ */ g("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = xp), L.init(e, t), e._zod.onattach.push((n) => {
    const r = n._zod.bag;
    r.format = "ipv6";
  }), e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), $f = /* @__PURE__ */ g("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Op), L.init(e, t);
}), If = /* @__PURE__ */ g("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = Up), L.init(e, t), e._zod.check = (n) => {
    const [r, i] = n.value.split("/");
    try {
      if (!i)
        throw new Error();
      const a = Number(i);
      if (`${a}` !== i)
        throw new Error();
      if (a < 0 || a > 128)
        throw new Error();
      new URL(`http://[${r}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function Io(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const kf = /* @__PURE__ */ g("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = jp), L.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64";
  }), e._zod.check = (n) => {
    Io(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function wf(e) {
  if (!ho.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return Io(n);
}
const Sf = /* @__PURE__ */ g("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = ho), L.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64url";
  }), e._zod.check = (n) => {
    wf(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), zf = /* @__PURE__ */ g("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = Np), L.init(e, t);
});
function xf(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [r] = n, i = JSON.parse(atob(r));
    return !("typ" in i && i?.typ !== "JWT" || !i.alg || t && (!("alg" in i) || i.alg !== t));
  } catch {
    return !1;
  }
}
const Of = /* @__PURE__ */ g("$ZodJWT", (e, t) => {
  L.init(e, t), e._zod.check = (n) => {
    xf(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), ko = /* @__PURE__ */ g("$ZodNumber", (e, t) => {
  R.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? Rp, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const i = n.value;
    if (typeof i == "number" && !Number.isNaN(i) && Number.isFinite(i))
      return n;
    const a = typeof i == "number" ? Number.isNaN(i) ? "NaN" : Number.isFinite(i) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: i,
      inst: e,
      ...a ? { received: a } : {}
    }), n;
  };
}), Uf = /* @__PURE__ */ g("$ZodNumber", (e, t) => {
  qp.init(e, t), ko.init(e, t);
}), jf = /* @__PURE__ */ g("$ZodBoolean", (e, t) => {
  R.init(e, t), e._zod.pattern = Cp, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const i = n.value;
    return typeof i == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), Pf = /* @__PURE__ */ g("$ZodNull", (e, t) => {
  R.init(e, t), e._zod.pattern = Mp, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (n, r) => {
    const { value: i } = n;
    return i === null || n.issues.push({
      expected: "null",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), Nf = /* @__PURE__ */ g("$ZodUnknown", (e, t) => {
  R.init(e, t), e._zod.parse = (n) => n;
}), Zf = /* @__PURE__ */ g("$ZodNever", (e, t) => {
  R.init(e, t), e._zod.parse = (n, r) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function za(e, t, n) {
  e.issues.length && t.issues.push(...xe(n, e.issues)), t.value[n] = e.value;
}
const Df = /* @__PURE__ */ g("$ZodArray", (e, t) => {
  R.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value;
    if (!Array.isArray(i))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    n.value = Array(i.length);
    const a = [];
    for (let o = 0; o < i.length; o++) {
      const s = i[o], l = t.element._zod.run({
        value: s,
        issues: []
      }, r);
      l instanceof Promise ? a.push(l.then((u) => za(u, n, o))) : za(l, n, o);
    }
    return a.length ? Promise.all(a).then(() => n) : n;
  };
});
function Lt(e, t, n) {
  e.issues.length && t.issues.push(...xe(n, e.issues)), t.value[n] = e.value;
}
function xa(e, t, n, r) {
  e.issues.length ? r[n] === void 0 ? n in r ? t.value[n] = void 0 : t.value[n] = e.value : t.issues.push(...xe(n, e.issues)) : e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value;
}
const Ef = /* @__PURE__ */ g("$ZodObject", (e, t) => {
  R.init(e, t);
  const n = bn(() => {
    const f = Object.keys(t.shape);
    for (const $ of f)
      if (!(t.shape[$] instanceof R))
        throw new Error(`Invalid element at key "${$}": expected a Zod schema`);
    const h = tp(t.shape);
    return {
      shape: t.shape,
      keys: f,
      keySet: new Set(f),
      numKeys: f.length,
      optionalKeys: new Set(h)
    };
  });
  M(e._zod, "propValues", () => {
    const f = t.shape, h = {};
    for (const $ in f) {
      const P = f[$]._zod;
      if (P.values) {
        h[$] ?? (h[$] = /* @__PURE__ */ new Set());
        for (const ee of P.values)
          h[$].add(ee);
      }
    }
    return h;
  });
  const r = (f) => {
    const h = new tf(["shape", "payload", "ctx"]), { keys: $, optionalKeys: P } = n.value, ee = (Z) => {
      const U = He(Z);
      return `shape[${U}]._zod.run({ value: input[${U}], issues: [] }, ctx)`;
    };
    h.write("const input = payload.value;");
    const ve = /* @__PURE__ */ Object.create(null);
    for (const Z of $)
      ve[Z] = uo(15);
    h.write("const newResult = {}");
    for (const Z of $)
      if (P.has(Z)) {
        const U = ve[Z];
        h.write(`const ${U} = ${ee(Z)};`);
        const T = He(Z);
        h.write(`
        if (${U}.issues.length) {
          if (input[${T}] === undefined) {
            if (${T} in input) {
              newResult[${T}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${U}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${T}, ...iss.path] : [${T}],
              }))
            );
          }
        } else if (${U}.value === undefined) {
          if (${T} in input) newResult[${T}] = undefined;
        } else {
          newResult[${T}] = ${U}.value;
        }
        `);
      } else {
        const U = ve[Z];
        h.write(`const ${U} = ${ee(Z)};`), h.write(`
          if (${U}.issues.length) payload.issues = payload.issues.concat(${U}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${He(Z)}, ...iss.path] : [${He(Z)}]
          })));`), h.write(`newResult[${He(Z)}] = ${U}.value`);
      }
    h.write("payload.value = newResult;"), h.write("return payload;");
    const Te = h.compile();
    return (Z, U) => Te(f, Z, U);
  };
  let i;
  const a = Gt, o = !so.jitless, l = o && Qm.value, { catchall: u } = t;
  let d;
  e._zod.parse = (f, h) => {
    d ?? (d = n.value);
    const $ = f.value;
    if (!a($))
      return f.issues.push({
        expected: "object",
        code: "invalid_type",
        input: $,
        inst: e
      }), f;
    const P = [];
    if (o && l && h?.async === !1 && h.jitless !== !0)
      i || (i = r(t.shape)), f = i(f, h);
    else {
      f.value = {};
      const U = d.shape;
      for (const T of d.keys) {
        const Be = U[T], Ct = Be._zod.run({ value: $[T], issues: [] }, h), ka = Be._zod.optin === "optional" && Be._zod.optout === "optional";
        Ct instanceof Promise ? P.push(Ct.then((wa) => ka ? xa(wa, f, T, $) : Lt(wa, f, T))) : ka ? xa(Ct, f, T, $) : Lt(Ct, f, T);
      }
    }
    if (!u)
      return P.length ? Promise.all(P).then(() => f) : f;
    const ee = [], ve = d.keySet, Te = u._zod, Z = Te.def.type;
    for (const U of Object.keys($)) {
      if (ve.has(U))
        continue;
      if (Z === "never") {
        ee.push(U);
        continue;
      }
      const T = Te.run({ value: $[U], issues: [] }, h);
      T instanceof Promise ? P.push(T.then((Be) => Lt(Be, f, U))) : Lt(T, f, U);
    }
    return ee.length && f.issues.push({
      code: "unrecognized_keys",
      keys: ee,
      input: $,
      inst: e
    }), P.length ? Promise.all(P).then(() => f) : f;
  };
});
function Oa(e, t, n, r) {
  for (const i of e)
    if (i.issues.length === 0)
      return t.value = i.value, t;
  return t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((i) => i.issues.map((a) => Ie(a, r, $e())))
  }), t;
}
const wo = /* @__PURE__ */ g("$ZodUnion", (e, t) => {
  R.init(e, t), M(e._zod, "values", () => {
    if (t.options.every((n) => n._zod.values))
      return new Set(t.options.flatMap((n) => Array.from(n._zod.values)));
  }), M(e._zod, "pattern", () => {
    if (t.options.every((n) => n._zod.pattern)) {
      const n = t.options.map((r) => r._zod.pattern);
      return new RegExp(`^(${n.map((r) => yn(r.source)).join("|")})$`);
    }
  }), e._zod.parse = (n, r) => {
    let i = !1;
    const a = [];
    for (const o of t.options) {
      const s = o._zod.run({
        value: n.value,
        issues: []
      }, r);
      if (s instanceof Promise)
        a.push(s), i = !0;
      else {
        if (s.issues.length === 0)
          return s;
        a.push(s);
      }
    }
    return i ? Promise.all(a).then((o) => Oa(o, n, e, r)) : Oa(a, n, e, r);
  };
}), Af = /* @__PURE__ */ g("$ZodDiscriminatedUnion", (e, t) => {
  wo.init(e, t);
  const n = e._zod.parse;
  M(e._zod, "propValues", () => {
    const i = {};
    for (const a of t.options) {
      const o = a._zod.propValues;
      if (!o || Object.keys(o).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(a)}"`);
      for (const [s, l] of Object.entries(o)) {
        i[s] || (i[s] = /* @__PURE__ */ new Set());
        for (const u of l)
          i[s].add(u);
      }
    }
    return i;
  });
  const r = bn(() => {
    const i = t.options, a = /* @__PURE__ */ new Map();
    for (const o of i) {
      const s = o._zod.propValues[t.discriminator];
      if (!s || s.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(o)}"`);
      for (const l of s) {
        if (a.has(l))
          throw new Error(`Duplicate discriminator value "${String(l)}"`);
        a.set(l, o);
      }
    }
    return a;
  });
  e._zod.parse = (i, a) => {
    const o = i.value;
    if (!Gt(o))
      return i.issues.push({
        code: "invalid_type",
        expected: "object",
        input: o,
        inst: e
      }), i;
    const s = r.value.get(o?.[t.discriminator]);
    return s ? s._zod.run(i, a) : t.unionFallback ? n(i, a) : (i.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input: o,
      path: [t.discriminator],
      inst: e
    }), i);
  };
}), Tf = /* @__PURE__ */ g("$ZodIntersection", (e, t) => {
  R.init(e, t), e._zod.parse = (n, r) => {
    const { value: i } = n, a = t.left._zod.run({ value: i, issues: [] }, r), o = t.right._zod.run({ value: i, issues: [] }, r);
    return a instanceof Promise || o instanceof Promise ? Promise.all([a, o]).then(([l, u]) => Ua(n, l, u)) : Ua(n, a, o);
  };
});
function ln(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (un(e) && un(t)) {
    const n = Object.keys(t), r = Object.keys(e).filter((a) => n.indexOf(a) !== -1), i = { ...e, ...t };
    for (const a of r) {
      const o = ln(e[a], t[a]);
      if (!o.valid)
        return {
          valid: !1,
          mergeErrorPath: [a, ...o.mergeErrorPath]
        };
      i[a] = o.data;
    }
    return { valid: !0, data: i };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const i = e[r], a = t[r], o = ln(i, a);
      if (!o.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...o.mergeErrorPath]
        };
      n.push(o.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function Ua(e, t, n) {
  if (t.issues.length && e.issues.push(...t.issues), n.issues.length && e.issues.push(...n.issues), et(e))
    return e;
  const r = ln(t.value, n.value);
  if (!r.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
  return e.value = r.data, e;
}
const Rf = /* @__PURE__ */ g("$ZodRecord", (e, t) => {
  R.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value;
    if (!un(i))
      return n.issues.push({
        expected: "record",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    const a = [];
    if (t.keyType._zod.values) {
      const o = t.keyType._zod.values;
      n.value = {};
      for (const l of o)
        if (typeof l == "string" || typeof l == "number" || typeof l == "symbol") {
          const u = t.valueType._zod.run({ value: i[l], issues: [] }, r);
          u instanceof Promise ? a.push(u.then((d) => {
            d.issues.length && n.issues.push(...xe(l, d.issues)), n.value[l] = d.value;
          })) : (u.issues.length && n.issues.push(...xe(l, u.issues)), n.value[l] = u.value);
        }
      let s;
      for (const l in i)
        o.has(l) || (s = s ?? [], s.push(l));
      s && s.length > 0 && n.issues.push({
        code: "unrecognized_keys",
        input: i,
        inst: e,
        keys: s
      });
    } else {
      n.value = {};
      for (const o of Reflect.ownKeys(i)) {
        if (o === "__proto__")
          continue;
        const s = t.keyType._zod.run({ value: o, issues: [] }, r);
        if (s instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (s.issues.length) {
          n.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: s.issues.map((u) => Ie(u, r, $e())),
            input: o,
            path: [o],
            inst: e
          }), n.value[s.value] = s.value;
          continue;
        }
        const l = t.valueType._zod.run({ value: i[o], issues: [] }, r);
        l instanceof Promise ? a.push(l.then((u) => {
          u.issues.length && n.issues.push(...xe(o, u.issues)), n.value[s.value] = u.value;
        })) : (l.issues.length && n.issues.push(...xe(o, l.issues)), n.value[s.value] = l.value);
      }
    }
    return a.length ? Promise.all(a).then(() => n) : n;
  };
}), Cf = /* @__PURE__ */ g("$ZodEnum", (e, t) => {
  R.init(e, t);
  const n = Hm(t.entries);
  e._zod.values = new Set(n), e._zod.pattern = new RegExp(`^(${n.filter((r) => ep.has(typeof r)).map((r) => typeof r == "string" ? ut(r) : r.toString()).join("|")})$`), e._zod.parse = (r, i) => {
    const a = r.value;
    return e._zod.values.has(a) || r.issues.push({
      code: "invalid_value",
      values: n,
      input: a,
      inst: e
    }), r;
  };
}), Mf = /* @__PURE__ */ g("$ZodLiteral", (e, t) => {
  R.init(e, t), e._zod.values = new Set(t.values), e._zod.pattern = new RegExp(`^(${t.values.map((n) => typeof n == "string" ? ut(n) : n ? n.toString() : String(n)).join("|")})$`), e._zod.parse = (n, r) => {
    const i = n.value;
    return e._zod.values.has(i) || n.issues.push({
      code: "invalid_value",
      values: t.values,
      input: i,
      inst: e
    }), n;
  };
}), Lf = /* @__PURE__ */ g("$ZodTransform", (e, t) => {
  R.init(e, t), e._zod.parse = (n, r) => {
    const i = t.transform(n.value, n);
    if (r.async)
      return (i instanceof Promise ? i : Promise.resolve(i)).then((o) => (n.value = o, n));
    if (i instanceof Promise)
      throw new tt();
    return n.value = i, n;
  };
}), Ff = /* @__PURE__ */ g("$ZodOptional", (e, t) => {
  R.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", M(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), M(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${yn(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, r) => n.value === void 0 ? n : t.innerType._zod.run(n, r);
}), Jf = /* @__PURE__ */ g("$ZodNullable", (e, t) => {
  R.init(e, t), M(e._zod, "optin", () => t.innerType._zod.optin), M(e._zod, "optout", () => t.innerType._zod.optout), M(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${yn(n.source)}|null)$`) : void 0;
  }), M(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r);
}), qf = /* @__PURE__ */ g("$ZodDefault", (e, t) => {
  R.init(e, t), e._zod.optin = "optional", M(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((a) => ja(a, t)) : ja(i, t);
  };
});
function ja(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const Wf = /* @__PURE__ */ g("$ZodPrefault", (e, t) => {
  R.init(e, t), e._zod.optin = "optional", M(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => (n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, r));
}), Kf = /* @__PURE__ */ g("$ZodNonOptional", (e, t) => {
  R.init(e, t), M(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (n, r) => {
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((a) => Pa(a, e)) : Pa(i, e);
  };
});
function Pa(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const Vf = /* @__PURE__ */ g("$ZodCatch", (e, t) => {
  R.init(e, t), M(e._zod, "optin", () => t.innerType._zod.optin), M(e._zod, "optout", () => t.innerType._zod.optout), M(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((a) => (n.value = a.value, a.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: a.issues.map((o) => Ie(o, r, $e()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = i.value, i.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: i.issues.map((a) => Ie(a, r, $e()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), Gf = /* @__PURE__ */ g("$ZodPipe", (e, t) => {
  R.init(e, t), M(e._zod, "values", () => t.in._zod.values), M(e._zod, "optin", () => t.in._zod.optin), M(e._zod, "optout", () => t.out._zod.optout), e._zod.parse = (n, r) => {
    const i = t.in._zod.run(n, r);
    return i instanceof Promise ? i.then((a) => Na(a, t, r)) : Na(i, t, r);
  };
});
function Na(e, t, n) {
  return et(e) ? e : t.out._zod.run({ value: e.value, issues: e.issues }, n);
}
const Bf = /* @__PURE__ */ g("$ZodReadonly", (e, t) => {
  R.init(e, t), M(e._zod, "propValues", () => t.innerType._zod.propValues), M(e._zod, "optin", () => t.innerType._zod.optin), M(e._zod, "optout", () => t.innerType._zod.optout), e._zod.parse = (n, r) => {
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then(Za) : Za(i);
  };
});
function Za(e) {
  return e.value = Object.freeze(e.value), e;
}
const Hf = /* @__PURE__ */ g("$ZodCustom", (e, t) => {
  re.init(e, t), R.init(e, t), e._zod.parse = (n, r) => n, e._zod.check = (n) => {
    const r = n.value, i = t.fn(r);
    if (i instanceof Promise)
      return i.then((a) => Da(a, n, r, e));
    Da(i, n, r, e);
  };
});
function Da(e, t, n, r) {
  if (!e) {
    const i = {
      code: "custom",
      input: n,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (i.params = r._zod.def.params), t.issues.push(it(i));
  }
}
class Xf {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const r = n[0];
    if (this._map.set(t, r), r && typeof r == "object" && "id" in r) {
      if (this._idmap.has(r.id))
        throw new Error(`ID ${r.id} already exists in the registry`);
      this._idmap.set(r.id, t);
    }
    return this;
  }
  remove(t) {
    return this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const r = { ...this.get(n) ?? {} };
      return delete r.id, { ...r, ...this._map.get(t) };
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function Yf() {
  return new Xf();
}
const Ft = /* @__PURE__ */ Yf();
function Qf(e, t) {
  return new e({
    type: "string",
    ...I(t)
  });
}
function eg(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function Ea(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function tg(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function ig(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...I(t)
  });
}
function ng(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...I(t)
  });
}
function rg(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...I(t)
  });
}
function ag(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function og(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function sg(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function ug(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function lg(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function cg(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function dg(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function mg(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function pg(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function fg(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function gg(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function hg(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function vg(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function bg(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function _g(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function yg(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...I(t)
  });
}
function $g(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...I(t)
  });
}
function Ig(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...I(t)
  });
}
function kg(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...I(t)
  });
}
function wg(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...I(t)
  });
}
function Sg(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...I(t)
  });
}
function zg(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...I(t)
  });
}
function xg(e, t) {
  return new e({
    type: "boolean",
    ...I(t)
  });
}
function Og(e, t) {
  return new e({
    type: "null",
    ...I(t)
  });
}
function Ug(e) {
  return new e({
    type: "unknown"
  });
}
function jg(e, t) {
  return new e({
    type: "never",
    ...I(t)
  });
}
function Aa(e, t) {
  return new yo({
    check: "less_than",
    ...I(t),
    value: e,
    inclusive: !1
  });
}
function on(e, t) {
  return new yo({
    check: "less_than",
    ...I(t),
    value: e,
    inclusive: !0
  });
}
function Ta(e, t) {
  return new $o({
    check: "greater_than",
    ...I(t),
    value: e,
    inclusive: !1
  });
}
function sn(e, t) {
  return new $o({
    check: "greater_than",
    ...I(t),
    value: e,
    inclusive: !0
  });
}
function Ra(e, t) {
  return new Jp({
    check: "multiple_of",
    ...I(t),
    value: e
  });
}
function So(e, t) {
  return new Wp({
    check: "max_length",
    ...I(t),
    maximum: e
  });
}
function Bt(e, t) {
  return new Kp({
    check: "min_length",
    ...I(t),
    minimum: e
  });
}
function zo(e, t) {
  return new Vp({
    check: "length_equals",
    ...I(t),
    length: e
  });
}
function Pg(e, t) {
  return new Gp({
    check: "string_format",
    format: "regex",
    ...I(t),
    pattern: e
  });
}
function Ng(e) {
  return new Bp({
    check: "string_format",
    format: "lowercase",
    ...I(e)
  });
}
function Zg(e) {
  return new Hp({
    check: "string_format",
    format: "uppercase",
    ...I(e)
  });
}
function Dg(e, t) {
  return new Xp({
    check: "string_format",
    format: "includes",
    ...I(t),
    includes: e
  });
}
function Eg(e, t) {
  return new Yp({
    check: "string_format",
    format: "starts_with",
    ...I(t),
    prefix: e
  });
}
function Ag(e, t) {
  return new Qp({
    check: "string_format",
    format: "ends_with",
    ...I(t),
    suffix: e
  });
}
function lt(e) {
  return new ef({
    check: "overwrite",
    tx: e
  });
}
function Tg(e) {
  return lt((t) => t.normalize(e));
}
function Rg() {
  return lt((e) => e.trim());
}
function Cg() {
  return lt((e) => e.toLowerCase());
}
function Mg() {
  return lt((e) => e.toUpperCase());
}
function Lg(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...I(n)
  });
}
function Fg(e, t, n) {
  const r = I(n);
  return r.abort ?? (r.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...r
  });
}
function Jg(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...I(n)
  });
}
const qg = /* @__PURE__ */ g("ZodISODateTime", (e, t) => {
  gf.init(e, t), K.init(e, t);
});
function xo(e) {
  return $g(qg, e);
}
const Wg = /* @__PURE__ */ g("ZodISODate", (e, t) => {
  hf.init(e, t), K.init(e, t);
});
function Kg(e) {
  return Ig(Wg, e);
}
const Vg = /* @__PURE__ */ g("ZodISOTime", (e, t) => {
  vf.init(e, t), K.init(e, t);
});
function Gg(e) {
  return kg(Vg, e);
}
const Bg = /* @__PURE__ */ g("ZodISODuration", (e, t) => {
  bf.init(e, t), K.init(e, t);
});
function Hg(e) {
  return wg(Bg, e);
}
const Xg = (e, t) => {
  mo.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => cp(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => lp(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => e.issues.push(n)
      // enumerable: false,
    },
    addIssues: {
      value: (n) => e.issues.push(...n)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, ui = g("ZodError", Xg, {
  Parent: Error
}), Yg = /* @__PURE__ */ dp(ui), Qg = /* @__PURE__ */ mp(ui), eh = /* @__PURE__ */ fo(ui), th = /* @__PURE__ */ go(ui), W = /* @__PURE__ */ g("ZodType", (e, t) => (R.init(e, t), e.def = t, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(
  {
    ...t,
    checks: [
      ...t.checks ?? [],
      ...n.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
    ]
  }
  // { parent: true }
), e.clone = (n, r) => Ze(e, n, r), e.brand = () => e, e.register = (n, r) => (n.add(e, r), e), e.parse = (n, r) => Yg(e, n, r, { callee: e.parse }), e.safeParse = (n, r) => eh(e, n, r), e.parseAsync = async (n, r) => Qg(e, n, r, { callee: e.parseAsync }), e.safeParseAsync = async (n, r) => th(e, n, r), e.spa = e.safeParseAsync, e.refine = (n, r) => e.check(Wh(n, r)), e.superRefine = (n) => e.check(Kh(n)), e.overwrite = (n) => e.check(lt(n)), e.optional = () => V(e), e.nullable = () => La(e), e.nullish = () => V(La(e)), e.nonoptional = (n) => Th(e, n), e.array = () => j(e), e.or = (n) => C([e, n]), e.and = (n) => kn(e, n), e.transform = (n) => dn(e, Do(n)), e.default = (n) => Dh(e, n), e.prefault = (n) => Ah(e, n), e.catch = (n) => Ch(e, n), e.pipe = (n) => dn(e, n), e.readonly = () => Fh(e), e.describe = (n) => {
  const r = e.clone();
  return Ft.add(r, { description: n }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return Ft.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return Ft.get(e);
  const r = e.clone();
  return Ft.add(r, n[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), Oo = /* @__PURE__ */ g("_ZodString", (e, t) => {
  In.init(e, t), W.init(e, t);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...r) => e.check(Pg(...r)), e.includes = (...r) => e.check(Dg(...r)), e.startsWith = (...r) => e.check(Eg(...r)), e.endsWith = (...r) => e.check(Ag(...r)), e.min = (...r) => e.check(Bt(...r)), e.max = (...r) => e.check(So(...r)), e.length = (...r) => e.check(zo(...r)), e.nonempty = (...r) => e.check(Bt(1, ...r)), e.lowercase = (r) => e.check(Ng(r)), e.uppercase = (r) => e.check(Zg(r)), e.trim = () => e.check(Rg()), e.normalize = (...r) => e.check(Tg(...r)), e.toLowerCase = () => e.check(Cg()), e.toUpperCase = () => e.check(Mg());
}), ih = /* @__PURE__ */ g("ZodString", (e, t) => {
  In.init(e, t), Oo.init(e, t), e.email = (n) => e.check(eg(nh, n)), e.url = (n) => e.check(ag(rh, n)), e.jwt = (n) => e.check(yg(_h, n)), e.emoji = (n) => e.check(og(ah, n)), e.guid = (n) => e.check(Ea(Ca, n)), e.uuid = (n) => e.check(tg(Jt, n)), e.uuidv4 = (n) => e.check(ig(Jt, n)), e.uuidv6 = (n) => e.check(ng(Jt, n)), e.uuidv7 = (n) => e.check(rg(Jt, n)), e.nanoid = (n) => e.check(sg(oh, n)), e.guid = (n) => e.check(Ea(Ca, n)), e.cuid = (n) => e.check(ug(sh, n)), e.cuid2 = (n) => e.check(lg(uh, n)), e.ulid = (n) => e.check(cg(lh, n)), e.base64 = (n) => e.check(vg(hh, n)), e.base64url = (n) => e.check(bg(vh, n)), e.xid = (n) => e.check(dg(ch, n)), e.ksuid = (n) => e.check(mg(dh, n)), e.ipv4 = (n) => e.check(pg(mh, n)), e.ipv6 = (n) => e.check(fg(ph, n)), e.cidrv4 = (n) => e.check(gg(fh, n)), e.cidrv6 = (n) => e.check(hg(gh, n)), e.e164 = (n) => e.check(_g(bh, n)), e.datetime = (n) => e.check(xo(n)), e.date = (n) => e.check(Kg(n)), e.time = (n) => e.check(Gg(n)), e.duration = (n) => e.check(Hg(n));
});
function p(e) {
  return Qf(ih, e);
}
const K = /* @__PURE__ */ g("ZodStringFormat", (e, t) => {
  L.init(e, t), Oo.init(e, t);
}), nh = /* @__PURE__ */ g("ZodEmail", (e, t) => {
  of.init(e, t), K.init(e, t);
}), Ca = /* @__PURE__ */ g("ZodGUID", (e, t) => {
  rf.init(e, t), K.init(e, t);
}), Jt = /* @__PURE__ */ g("ZodUUID", (e, t) => {
  af.init(e, t), K.init(e, t);
}), rh = /* @__PURE__ */ g("ZodURL", (e, t) => {
  sf.init(e, t), K.init(e, t);
}), ah = /* @__PURE__ */ g("ZodEmoji", (e, t) => {
  uf.init(e, t), K.init(e, t);
}), oh = /* @__PURE__ */ g("ZodNanoID", (e, t) => {
  lf.init(e, t), K.init(e, t);
}), sh = /* @__PURE__ */ g("ZodCUID", (e, t) => {
  cf.init(e, t), K.init(e, t);
}), uh = /* @__PURE__ */ g("ZodCUID2", (e, t) => {
  df.init(e, t), K.init(e, t);
}), lh = /* @__PURE__ */ g("ZodULID", (e, t) => {
  mf.init(e, t), K.init(e, t);
}), ch = /* @__PURE__ */ g("ZodXID", (e, t) => {
  pf.init(e, t), K.init(e, t);
}), dh = /* @__PURE__ */ g("ZodKSUID", (e, t) => {
  ff.init(e, t), K.init(e, t);
}), mh = /* @__PURE__ */ g("ZodIPv4", (e, t) => {
  _f.init(e, t), K.init(e, t);
}), ph = /* @__PURE__ */ g("ZodIPv6", (e, t) => {
  yf.init(e, t), K.init(e, t);
}), fh = /* @__PURE__ */ g("ZodCIDRv4", (e, t) => {
  $f.init(e, t), K.init(e, t);
}), gh = /* @__PURE__ */ g("ZodCIDRv6", (e, t) => {
  If.init(e, t), K.init(e, t);
}), hh = /* @__PURE__ */ g("ZodBase64", (e, t) => {
  kf.init(e, t), K.init(e, t);
}), vh = /* @__PURE__ */ g("ZodBase64URL", (e, t) => {
  Sf.init(e, t), K.init(e, t);
}), bh = /* @__PURE__ */ g("ZodE164", (e, t) => {
  zf.init(e, t), K.init(e, t);
}), _h = /* @__PURE__ */ g("ZodJWT", (e, t) => {
  Of.init(e, t), K.init(e, t);
}), Uo = /* @__PURE__ */ g("ZodNumber", (e, t) => {
  ko.init(e, t), W.init(e, t), e.gt = (r, i) => e.check(Ta(r, i)), e.gte = (r, i) => e.check(sn(r, i)), e.min = (r, i) => e.check(sn(r, i)), e.lt = (r, i) => e.check(Aa(r, i)), e.lte = (r, i) => e.check(on(r, i)), e.max = (r, i) => e.check(on(r, i)), e.int = (r) => e.check(Ma(r)), e.safe = (r) => e.check(Ma(r)), e.positive = (r) => e.check(Ta(0, r)), e.nonnegative = (r) => e.check(sn(0, r)), e.negative = (r) => e.check(Aa(0, r)), e.nonpositive = (r) => e.check(on(0, r)), e.multipleOf = (r, i) => e.check(Ra(r, i)), e.step = (r, i) => e.check(Ra(r, i)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function N(e) {
  return Sg(Uo, e);
}
const yh = /* @__PURE__ */ g("ZodNumberFormat", (e, t) => {
  Uf.init(e, t), Uo.init(e, t);
});
function Ma(e) {
  return zg(yh, e);
}
const $h = /* @__PURE__ */ g("ZodBoolean", (e, t) => {
  jf.init(e, t), W.init(e, t);
});
function G(e) {
  return xg($h, e);
}
const Ih = /* @__PURE__ */ g("ZodNull", (e, t) => {
  Pf.init(e, t), W.init(e, t);
});
function jo(e) {
  return Og(Ih, e);
}
const kh = /* @__PURE__ */ g("ZodUnknown", (e, t) => {
  Nf.init(e, t), W.init(e, t);
});
function J() {
  return Ug(kh);
}
const wh = /* @__PURE__ */ g("ZodNever", (e, t) => {
  Zf.init(e, t), W.init(e, t);
});
function Sh(e) {
  return jg(wh, e);
}
const zh = /* @__PURE__ */ g("ZodArray", (e, t) => {
  Df.init(e, t), W.init(e, t), e.element = t.element, e.min = (n, r) => e.check(Bt(n, r)), e.nonempty = (n) => e.check(Bt(1, n)), e.max = (n, r) => e.check(So(n, r)), e.length = (n, r) => e.check(zo(n, r)), e.unwrap = () => e.element;
});
function j(e, t) {
  return Lg(zh, e, t);
}
const Po = /* @__PURE__ */ g("ZodObject", (e, t) => {
  Ef.init(e, t), W.init(e, t), M(e, "shape", () => t.shape), e.keyof = () => ae(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: J() }), e.loose = () => e.clone({ ...e._zod.def, catchall: J() }), e.strict = () => e.clone({ ...e._zod.def, catchall: Sh() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => ap(e, n), e.merge = (n) => op(e, n), e.pick = (n) => np(e, n), e.omit = (n) => rp(e, n), e.partial = (...n) => sp(Eo, e, n[0]), e.required = (...n) => up(Ao, e, n[0]);
});
function y(e, t) {
  const n = {
    type: "object",
    get shape() {
      return oi(this, "shape", { ...e }), this.shape;
    },
    ...I(t)
  };
  return new Po(n);
}
function ne(e, t) {
  return new Po({
    type: "object",
    get shape() {
      return oi(this, "shape", { ...e }), this.shape;
    },
    catchall: J(),
    ...I(t)
  });
}
const No = /* @__PURE__ */ g("ZodUnion", (e, t) => {
  wo.init(e, t), W.init(e, t), e.options = t.options;
});
function C(e, t) {
  return new No({
    type: "union",
    options: e,
    ...I(t)
  });
}
const xh = /* @__PURE__ */ g("ZodDiscriminatedUnion", (e, t) => {
  No.init(e, t), Af.init(e, t);
});
function Zo(e, t, n) {
  return new xh({
    type: "union",
    options: t,
    discriminator: e,
    ...I(n)
  });
}
const Oh = /* @__PURE__ */ g("ZodIntersection", (e, t) => {
  Tf.init(e, t), W.init(e, t);
});
function kn(e, t) {
  return new Oh({
    type: "intersection",
    left: e,
    right: t
  });
}
const Uh = /* @__PURE__ */ g("ZodRecord", (e, t) => {
  Rf.init(e, t), W.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType;
});
function q(e, t, n) {
  return new Uh({
    type: "record",
    keyType: e,
    valueType: t,
    ...I(n)
  });
}
const cn = /* @__PURE__ */ g("ZodEnum", (e, t) => {
  Cf.init(e, t), W.init(e, t), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (r, i) => {
    const a = {};
    for (const o of r)
      if (n.has(o))
        a[o] = t.entries[o];
      else
        throw new Error(`Key ${o} not found in enum`);
    return new cn({
      ...t,
      checks: [],
      ...I(i),
      entries: a
    });
  }, e.exclude = (r, i) => {
    const a = { ...t.entries };
    for (const o of r)
      if (n.has(o))
        delete a[o];
      else
        throw new Error(`Key ${o} not found in enum`);
    return new cn({
      ...t,
      checks: [],
      ...I(i),
      entries: a
    });
  };
});
function ae(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new cn({
    type: "enum",
    entries: n,
    ...I(t)
  });
}
const jh = /* @__PURE__ */ g("ZodLiteral", (e, t) => {
  Mf.init(e, t), W.init(e, t), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function k(e, t) {
  return new jh({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...I(t)
  });
}
const Ph = /* @__PURE__ */ g("ZodTransform", (e, t) => {
  Lf.init(e, t), W.init(e, t), e._zod.parse = (n, r) => {
    n.addIssue = (a) => {
      if (typeof a == "string")
        n.issues.push(it(a, n.value, t));
      else {
        const o = a;
        o.fatal && (o.continue = !1), o.code ?? (o.code = "custom"), o.input ?? (o.input = n.value), o.inst ?? (o.inst = e), o.continue ?? (o.continue = !0), n.issues.push(it(o));
      }
    };
    const i = t.transform(n.value, n);
    return i instanceof Promise ? i.then((a) => (n.value = a, n)) : (n.value = i, n);
  };
});
function Do(e) {
  return new Ph({
    type: "transform",
    transform: e
  });
}
const Eo = /* @__PURE__ */ g("ZodOptional", (e, t) => {
  Ff.init(e, t), W.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function V(e) {
  return new Eo({
    type: "optional",
    innerType: e
  });
}
const Nh = /* @__PURE__ */ g("ZodNullable", (e, t) => {
  Jf.init(e, t), W.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function La(e) {
  return new Nh({
    type: "nullable",
    innerType: e
  });
}
const Zh = /* @__PURE__ */ g("ZodDefault", (e, t) => {
  qf.init(e, t), W.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function Dh(e, t) {
  return new Zh({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
const Eh = /* @__PURE__ */ g("ZodPrefault", (e, t) => {
  Wf.init(e, t), W.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Ah(e, t) {
  return new Eh({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
const Ao = /* @__PURE__ */ g("ZodNonOptional", (e, t) => {
  Kf.init(e, t), W.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Th(e, t) {
  return new Ao({
    type: "nonoptional",
    innerType: e,
    ...I(t)
  });
}
const Rh = /* @__PURE__ */ g("ZodCatch", (e, t) => {
  Vf.init(e, t), W.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function Ch(e, t) {
  return new Rh({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const Mh = /* @__PURE__ */ g("ZodPipe", (e, t) => {
  Gf.init(e, t), W.init(e, t), e.in = t.in, e.out = t.out;
});
function dn(e, t) {
  return new Mh({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const Lh = /* @__PURE__ */ g("ZodReadonly", (e, t) => {
  Bf.init(e, t), W.init(e, t);
});
function Fh(e) {
  return new Lh({
    type: "readonly",
    innerType: e
  });
}
const To = /* @__PURE__ */ g("ZodCustom", (e, t) => {
  Hf.init(e, t), W.init(e, t);
});
function Jh(e, t) {
  const n = new re({
    check: "custom",
    ...I(t)
  });
  return n._zod.check = e, n;
}
function qh(e, t) {
  return Fg(To, e ?? (() => !0), t);
}
function Wh(e, t = {}) {
  return Jg(To, e, t);
}
function Kh(e, t) {
  const n = Jh((r) => (r.addIssue = (i) => {
    if (typeof i == "string")
      r.issues.push(it(i, r.value, n._zod.def));
    else {
      const a = i;
      a.fatal && (a.continue = !1), a.code ?? (a.code = "custom"), a.input ?? (a.input = r.value), a.inst ?? (a.inst = n), a.continue ?? (a.continue = !n._zod.def.abort), r.issues.push(it(a));
    }
  }, e(r.value, r)), t);
  return n;
}
function Ro(e, t) {
  return dn(Do(e), t);
}
const Vh = "io.modelcontextprotocol/related-task", li = "2.0", B = qh((e) => e !== null && (typeof e == "object" || typeof e == "function")), Co = C([p(), N().int()]), Mo = p();
ne({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: C([N(), jo()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: N().optional()
});
const Gh = y({
  ttl: N().optional()
}), Bh = y({
  taskId: p()
}), wn = ne({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: Co.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [Vh]: Bh.optional()
}), oe = y({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: wn.optional()
}), ci = oe.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: Gh.optional()
}), H = y({
  method: p(),
  params: oe.loose().optional()
}), de = y({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: wn.optional()
}), me = y({
  method: p(),
  params: de.loose().optional()
}), X = ne({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: wn.optional()
}), ct = C([p(), N().int()]), Hh = y({
  jsonrpc: k(li),
  id: ct,
  ...H.shape
}).strict(), Xh = y({
  jsonrpc: k(li),
  ...me.shape
}).strict(), Lo = y({
  jsonrpc: k(li),
  id: ct,
  result: X
}).strict();
var Fa;
(function(e) {
  e[e.ConnectionClosed = -32e3] = "ConnectionClosed", e[e.RequestTimeout = -32001] = "RequestTimeout", e[e.ParseError = -32700] = "ParseError", e[e.InvalidRequest = -32600] = "InvalidRequest", e[e.MethodNotFound = -32601] = "MethodNotFound", e[e.InvalidParams = -32602] = "InvalidParams", e[e.InternalError = -32603] = "InternalError", e[e.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
})(Fa || (Fa = {}));
const Fo = y({
  jsonrpc: k(li),
  id: ct.optional(),
  error: y({
    /**
     * The error type that occurred.
     */
    code: N().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: p(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: J().optional()
  })
}).strict();
C([
  Hh,
  Xh,
  Lo,
  Fo
]);
C([Lo, Fo]);
const Jo = X.strict(), Yh = de.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: ct.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: p().optional()
}), qo = me.extend({
  method: k("notifications/cancelled"),
  params: Yh
}), Qh = y({
  /**
   * URL or data URI for the icon.
   */
  src: p(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: p().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: j(p()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: ae(["light", "dark"]).optional()
}), dt = y({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: j(Qh).optional()
}), Re = y({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: p(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: p().optional()
}), di = Re.extend({
  ...Re.shape,
  ...dt.shape,
  version: p(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: p().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: p().optional()
}), ev = kn(y({
  applyDefaults: G().optional()
}), q(p(), J())), tv = Ro((e) => e && typeof e == "object" && !Array.isArray(e) && Object.keys(e).length === 0 ? { form: {} } : e, kn(y({
  form: ev.optional(),
  url: B.optional()
}), q(p(), J()).optional())), iv = ne({
  /**
   * Present if the client supports listing tasks.
   */
  list: B.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: B.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: ne({
    /**
     * Task support for sampling requests.
     */
    sampling: ne({
      createMessage: B.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: ne({
      create: B.optional()
    }).optional()
  }).optional()
}), nv = ne({
  /**
   * Present if the server supports listing tasks.
   */
  list: B.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: B.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: ne({
    /**
     * Task support for tool requests.
     */
    tools: ne({
      call: B.optional()
    }).optional()
  }).optional()
}), rv = y({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: q(p(), B).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: y({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: B.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: B.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: tv.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: y({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: G().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: iv.optional()
}), av = oe.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: p(),
  capabilities: rv,
  clientInfo: di
}), ov = H.extend({
  method: k("initialize"),
  params: av
}), sv = y({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: q(p(), B).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: B.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: B.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: y({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: G().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: y({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: G().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: G().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: y({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: G().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: nv.optional()
}), uv = X.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: p(),
  capabilities: sv,
  serverInfo: di,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: p().optional()
}), lv = me.extend({
  method: k("notifications/initialized"),
  params: de.optional()
}), Wo = H.extend({
  method: k("ping"),
  params: oe.optional()
}), cv = y({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: N(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: V(N()),
  /**
   * An optional message describing the current progress.
   */
  message: V(p())
}), dv = y({
  ...de.shape,
  ...cv.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: Co
}), Ko = me.extend({
  method: k("notifications/progress"),
  params: dv
}), mv = oe.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: Mo.optional()
}), mt = H.extend({
  params: mv.optional()
}), pt = X.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: Mo.optional()
}), pv = ae(["working", "input_required", "completed", "failed", "cancelled"]), ft = y({
  taskId: p(),
  status: pv,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: C([N(), jo()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: p(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: p(),
  pollInterval: V(N()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: V(p())
}), Vo = X.extend({
  task: ft
}), fv = de.merge(ft), Go = me.extend({
  method: k("notifications/tasks/status"),
  params: fv
}), Bo = H.extend({
  method: k("tasks/get"),
  params: oe.extend({
    taskId: p()
  })
}), Ho = X.merge(ft), Xo = H.extend({
  method: k("tasks/result"),
  params: oe.extend({
    taskId: p()
  })
});
X.loose();
const Yo = mt.extend({
  method: k("tasks/list")
}), Qo = pt.extend({
  tasks: j(ft)
}), es = H.extend({
  method: k("tasks/cancel"),
  params: oe.extend({
    taskId: p()
  })
});
X.merge(ft);
const ts = y({
  /**
   * The URI of this resource.
   */
  uri: p(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: V(p()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), is = ts.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: p()
}), Sn = p().refine((e) => {
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}, { message: "Invalid Base64 string" }), ns = ts.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Sn
}), gt = ae(["user", "assistant"]), Ve = y({
  /**
   * Intended audience(s) for the resource.
   */
  audience: j(gt).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: N().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: xo({ offset: !0 }).optional()
}), rs = y({
  ...Re.shape,
  ...dt.shape,
  /**
   * The URI of this resource.
   */
  uri: p(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: V(p()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: V(p()),
  /**
   * Optional annotations for the client.
   */
  annotations: Ve.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: V(ne({}))
}), gv = y({
  ...Re.shape,
  ...dt.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: p(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: V(p()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: V(p()),
  /**
   * Optional annotations for the client.
   */
  annotations: Ve.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: V(ne({}))
}), hv = mt.extend({
  method: k("resources/list")
}), vv = pt.extend({
  resources: j(rs)
}), bv = mt.extend({
  method: k("resources/templates/list")
}), _v = pt.extend({
  resourceTemplates: j(gv)
}), zn = oe.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: p()
}), yv = zn, $v = H.extend({
  method: k("resources/read"),
  params: yv
}), Iv = X.extend({
  contents: j(C([is, ns]))
}), kv = me.extend({
  method: k("notifications/resources/list_changed"),
  params: de.optional()
}), wv = zn, Sv = H.extend({
  method: k("resources/subscribe"),
  params: wv
}), zv = zn, xv = H.extend({
  method: k("resources/unsubscribe"),
  params: zv
}), Ov = de.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: p()
}), Uv = me.extend({
  method: k("notifications/resources/updated"),
  params: Ov
}), jv = y({
  /**
   * The name of the argument.
   */
  name: p(),
  /**
   * A human-readable description of the argument.
   */
  description: V(p()),
  /**
   * Whether this argument must be provided.
   */
  required: V(G())
}), Pv = y({
  ...Re.shape,
  ...dt.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: V(p()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: V(j(jv)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: V(ne({}))
}), Nv = mt.extend({
  method: k("prompts/list")
}), Zv = pt.extend({
  prompts: j(Pv)
}), Dv = oe.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: p(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: q(p(), p()).optional()
}), Ev = H.extend({
  method: k("prompts/get"),
  params: Dv
}), xn = y({
  type: k("text"),
  /**
   * The text content of the message.
   */
  text: p(),
  /**
   * Optional annotations for the client.
   */
  annotations: Ve.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), On = y({
  type: k("image"),
  /**
   * The base64-encoded image data.
   */
  data: Sn,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: p(),
  /**
   * Optional annotations for the client.
   */
  annotations: Ve.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), Un = y({
  type: k("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Sn,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: p(),
  /**
   * Optional annotations for the client.
   */
  annotations: Ve.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), Av = y({
  type: k("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: p(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: p(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: q(p(), J()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), Tv = y({
  type: k("resource"),
  resource: C([is, ns]),
  /**
   * Optional annotations for the client.
   */
  annotations: Ve.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), Rv = rs.extend({
  type: k("resource_link")
}), mi = C([
  xn,
  On,
  Un,
  Rv,
  Tv
]), Cv = y({
  role: gt,
  content: mi
}), Mv = X.extend({
  /**
   * An optional description for the prompt.
   */
  description: p().optional(),
  messages: j(Cv)
}), Lv = me.extend({
  method: k("notifications/prompts/list_changed"),
  params: de.optional()
}), Fv = y({
  /**
   * A human-readable title for the tool.
   */
  title: p().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: G().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: G().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: G().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: G().optional()
}), Jv = y({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: ae(["required", "optional", "forbidden"]).optional()
}), jn = y({
  ...Re.shape,
  ...dt.shape,
  /**
   * A human-readable description of the tool.
   */
  description: p().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: y({
    type: k("object"),
    properties: q(p(), B).optional(),
    required: j(p()).optional()
  }).catchall(J()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: y({
    type: k("object"),
    properties: q(p(), B).optional(),
    required: j(p()).optional()
  }).catchall(J()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: Fv.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: Jv.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), qv = mt.extend({
  method: k("tools/list")
}), Wv = pt.extend({
  tools: j(jn)
}), Pn = X.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: j(mi).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: q(p(), J()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: G().optional()
});
Pn.or(X.extend({
  toolResult: J()
}));
const Kv = ci.extend({
  /**
   * The name of the tool to call.
   */
  name: p(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: q(p(), J()).optional()
}), Vv = H.extend({
  method: k("tools/call"),
  params: Kv
}), Gv = me.extend({
  method: k("notifications/tools/list_changed"),
  params: de.optional()
});
y({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: G().default(!0),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: N().int().nonnegative().default(300)
});
const as = ae(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]), Bv = oe.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: as
}), Hv = H.extend({
  method: k("logging/setLevel"),
  params: Bv
}), Xv = de.extend({
  /**
   * The severity of this log message.
   */
  level: as,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: p().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: J()
}), Yv = me.extend({
  method: k("notifications/message"),
  params: Xv
}), Qv = y({
  /**
   * A hint for a model name.
   */
  name: p().optional()
}), eb = y({
  /**
   * Optional hints to use for model selection.
   */
  hints: j(Qv).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: N().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: N().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: N().min(0).max(1).optional()
}), tb = y({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: ae(["auto", "required", "none"]).optional()
}), ib = y({
  type: k("tool_result"),
  toolUseId: p().describe("The unique identifier for the corresponding tool call."),
  content: j(mi).default([]),
  structuredContent: y({}).loose().optional(),
  isError: G().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), nb = Zo("type", [xn, On, Un]), Ht = Zo("type", [
  xn,
  On,
  Un,
  Av,
  ib
]), rb = y({
  role: gt,
  content: C([Ht, j(Ht)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), ab = ci.extend({
  messages: j(rb),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: eb.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: p().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: ae(["none", "thisServer", "allServers"]).optional(),
  temperature: N().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: N().int(),
  stopSequences: j(p()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: B.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: j(jn).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: tb.optional()
}), ob = H.extend({
  method: k("sampling/createMessage"),
  params: ab
}), sb = X.extend({
  /**
   * The name of the model that generated the message.
   */
  model: p(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: V(ae(["endTurn", "stopSequence", "maxTokens"]).or(p())),
  role: gt,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: nb
}), ub = X.extend({
  /**
   * The name of the model that generated the message.
   */
  model: p(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: V(ae(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(p())),
  role: gt,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: C([Ht, j(Ht)])
}), lb = y({
  type: k("boolean"),
  title: p().optional(),
  description: p().optional(),
  default: G().optional()
}), cb = y({
  type: k("string"),
  title: p().optional(),
  description: p().optional(),
  minLength: N().optional(),
  maxLength: N().optional(),
  format: ae(["email", "uri", "date", "date-time"]).optional(),
  default: p().optional()
}), db = y({
  type: ae(["number", "integer"]),
  title: p().optional(),
  description: p().optional(),
  minimum: N().optional(),
  maximum: N().optional(),
  default: N().optional()
}), mb = y({
  type: k("string"),
  title: p().optional(),
  description: p().optional(),
  enum: j(p()),
  default: p().optional()
}), pb = y({
  type: k("string"),
  title: p().optional(),
  description: p().optional(),
  oneOf: j(y({
    const: p(),
    title: p()
  })),
  default: p().optional()
}), fb = y({
  type: k("string"),
  title: p().optional(),
  description: p().optional(),
  enum: j(p()),
  enumNames: j(p()).optional(),
  default: p().optional()
}), gb = C([mb, pb]), hb = y({
  type: k("array"),
  title: p().optional(),
  description: p().optional(),
  minItems: N().optional(),
  maxItems: N().optional(),
  items: y({
    type: k("string"),
    enum: j(p())
  }),
  default: j(p()).optional()
}), vb = y({
  type: k("array"),
  title: p().optional(),
  description: p().optional(),
  minItems: N().optional(),
  maxItems: N().optional(),
  items: y({
    anyOf: j(y({
      const: p(),
      title: p()
    }))
  }),
  default: j(p()).optional()
}), bb = C([hb, vb]), _b = C([fb, gb, bb]), yb = C([_b, lb, cb, db]), $b = ci.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: k("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: p(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: y({
    type: k("object"),
    properties: q(p(), yb),
    required: j(p()).optional()
  })
}), Ib = ci.extend({
  /**
   * The elicitation mode.
   */
  mode: k("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: p(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: p(),
  /**
   * The URL that the user should navigate to.
   */
  url: p().url()
}), kb = C([$b, Ib]), wb = H.extend({
  method: k("elicitation/create"),
  params: kb
}), Sb = de.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: p()
}), zb = me.extend({
  method: k("notifications/elicitation/complete"),
  params: Sb
}), xb = X.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: ae(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: Ro((e) => e === null ? void 0 : e, q(p(), C([p(), N(), G(), j(p())])).optional())
}), Ob = y({
  type: k("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: p()
}), Ub = y({
  type: k("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: p()
}), jb = oe.extend({
  ref: C([Ub, Ob]),
  /**
   * The argument's information
   */
  argument: y({
    /**
     * The name of the argument
     */
    name: p(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: p()
  }),
  context: y({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: q(p(), p()).optional()
  }).optional()
}), Pb = H.extend({
  method: k("completion/complete"),
  params: jb
}), Nb = X.extend({
  completion: ne({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: j(p()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: V(N().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: V(G())
  })
}), Zb = y({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: p().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: p().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: q(p(), J()).optional()
}), Db = H.extend({
  method: k("roots/list"),
  params: oe.optional()
}), Eb = X.extend({
  roots: j(Zb)
}), Ab = me.extend({
  method: k("notifications/roots/list_changed"),
  params: de.optional()
});
C([
  Wo,
  ov,
  Pb,
  Hv,
  Ev,
  Nv,
  hv,
  bv,
  $v,
  Sv,
  xv,
  Vv,
  qv,
  Bo,
  Xo,
  Yo,
  es
]);
C([
  qo,
  Ko,
  lv,
  Ab,
  Go
]);
C([
  Jo,
  sb,
  ub,
  xb,
  Eb,
  Ho,
  Qo,
  Vo
]);
C([
  Wo,
  ob,
  wb,
  Db,
  Bo,
  Xo,
  Yo,
  es
]);
C([
  qo,
  Ko,
  Yv,
  Uv,
  kv,
  Gv,
  Lv,
  Go,
  zb
]);
C([
  Jo,
  uv,
  Nb,
  Mv,
  Zv,
  vv,
  _v,
  Iv,
  Pn,
  Wv,
  Ho,
  Qo,
  Vo
]);
new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
var Tb = Object.defineProperty, _e = (e, t) => {
  for (var n in t) Tb(e, n, { get: t[n], enumerable: !0, configurable: !0, set: (r) => t[n] = () => r });
}, c = {};
_e(c, { xor: () => wm, xid: () => Vd, void: () => bm, uuidv7: () => Cd, uuidv6: () => Rd, uuidv4: () => Td, uuid: () => Ad, util: () => x, url: () => Md, uppercase: () => Ii, unknown: () => Ne, union: () => Yi, undefined: () => hm, ulid: () => Kd, uint64: () => fm, uint32: () => dm, tuple: () => Hr, trim: () => Oi, treeifyError: () => ys, transform: () => en, toUpperCase: () => ji, toLowerCase: () => Ui, toJSONSchema: () => fd, templateLiteral: () => Tm, symbol: () => gm, superRefine: () => $a, success: () => Dm, stringbool: () => qm, stringFormat: () => rm, string: () => ni, strictObject: () => Im, startsWith: () => wi, slugify: () => Pi, size: () => _i, setErrorMap: () => sI, set: () => Um, safeParseAsync: () => Sd, safeParse: () => wd, safeEncodeAsync: () => Nd, safeEncode: () => jd, safeDecodeAsync: () => Zd, safeDecode: () => Pd, registry: () => tr, regexes: () => Ee, regex: () => yi, refine: () => ya, record: () => Xr, readonly: () => fa, property: () => zr, promise: () => Rm, prettifyError: () => Is, preprocess: () => Km, prefault: () => sa, positive: () => Ir, pipe: () => st, partialRecord: () => zm, parseAsync: () => kd, parse: () => Id, overwrite: () => ye, optional: () => at, object: () => $m, number: () => Dr, nullish: () => Zm, nullable: () => ot, null: () => Cr, normalize: () => xi, nonpositive: () => wr, nonoptional: () => ua, nonnegative: () => Sr, never: () => Hi, negative: () => kr, nativeEnum: () => jm, nanoid: () => Jd, nan: () => Em, multipleOf: () => Le, minSize: () => Fe, minLength: () => Pe, mime: () => zi, meta: () => Fm, maxSize: () => St, maxLength: () => zt, map: () => Om, mac: () => Hd, lte: () => le, lt: () => ke, lowercase: () => $i, looseRecord: () => xm, looseObject: () => km, locales: () => er, literal: () => Pm, length: () => xt, lazy: () => va, ksuid: () => Gd, keyof: () => ym, jwt: () => nm, json: () => Wm, iso: () => Or, ipv6: () => Xd, ipv4: () => Bd, intersection: () => Gr, int64: () => pm, int32: () => cm, int: () => ri, instanceof: () => Jm, includes: () => ki, httpUrl: () => Ld, hostname: () => am, hex: () => om, hash: () => sm, guid: () => Ed, gte: () => ie, gt: () => we, globalRegistry: () => ge, getErrorMap: () => uI, function: () => ai, fromJSONSchema: () => dI, formatError: () => An, float64: () => lm, float32: () => um, flattenError: () => En, file: () => Nm, enum: () => Qi, endsWith: () => Si, encodeAsync: () => Od, encode: () => zd, emoji: () => Fd, email: () => Dd, e164: () => im, discriminatedUnion: () => Sm, describe: () => Lm, decodeAsync: () => Ud, decode: () => xd, date: () => _m, custom: () => Mm, cuid2: () => Wd, cuid: () => qd, core: () => os, config: () => Q, coerce: () => Gm, codec: () => Am, clone: () => pe, cidrv6: () => Qd, cidrv4: () => Yd, check: () => Cm, catch: () => da, boolean: () => Er, bigint: () => mm, base64url: () => tm, base64: () => em, array: () => Dt, any: () => vm, _function: () => ai, _default: () => aa, _ZodString: () => Ni, ZodXor: () => Wr, ZodXID: () => Ci, ZodVoid: () => Jr, ZodUnknown: () => Lr, ZodUnion: () => At, ZodUndefined: () => Tr, ZodUUID: () => he, ZodURL: () => jt, ZodULID: () => Ri, ZodType: () => z, ZodTuple: () => Br, ZodTransform: () => ia, ZodTemplateLiteral: () => ga, ZodSymbol: () => Ar, ZodSuccess: () => la, ZodStringFormat: () => A, ZodString: () => Ut, ZodSet: () => Qr, ZodRecord: () => Tt, ZodRealError: () => ue, ZodReadonly: () => pa, ZodPromise: () => ba, ZodPrefault: () => oa, ZodPipe: () => rn, ZodOptional: () => tn, ZodObject: () => Et, ZodNumberFormat: () => Ae, ZodNumber: () => Pt, ZodNullable: () => na, ZodNull: () => Rr, ZodNonOptional: () => nn, ZodNever: () => Fr, ZodNanoID: () => Ei, ZodNaN: () => ma, ZodMap: () => Yr, ZodMAC: () => Zr, ZodLiteral: () => ea, ZodLazy: () => ha, ZodKSUID: () => Mi, ZodJWT: () => Gi, ZodIssueCode: () => oI, ZodIntersection: () => Vr, ZodISOTime: () => Pr, ZodISODuration: () => Nr, ZodISODateTime: () => Ur, ZodISODate: () => jr, ZodIPv6: () => Fi, ZodIPv4: () => Li, ZodGUID: () => rt, ZodFunction: () => _a, ZodFirstPartyTypeKind: () => vn, ZodFile: () => ta, ZodError: () => aI, ZodEnum: () => Ke, ZodEmoji: () => Di, ZodEmail: () => Zi, ZodE164: () => Vi, ZodDiscriminatedUnion: () => Kr, ZodDefault: () => ra, ZodDate: () => Xi, ZodCustomStringFormat: () => Ge, ZodCustom: () => Rt, ZodCodec: () => an, ZodCatch: () => ca, ZodCUID2: () => Ti, ZodCUID: () => Ai, ZodCIDRv6: () => qi, ZodCIDRv4: () => Ji, ZodBoolean: () => Nt, ZodBigIntFormat: () => Bi, ZodBigInt: () => Zt, ZodBase64URL: () => Ki, ZodBase64: () => Wi, ZodArray: () => qr, ZodAny: () => Mr, TimePrecision: () => Kl, NEVER: () => ss, $output: () => Ml, $input: () => Ll, $brand: () => us });
var os = {};
_e(os, { version: () => ku, util: () => x, treeifyError: () => ys, toJSONSchema: () => fd, toDotPath: () => $s, safeParseAsync: () => ws, safeParse: () => ks, safeEncodeAsync: () => h_, safeEncode: () => f_, safeDecodeAsync: () => v_, safeDecode: () => g_, registry: () => tr, regexes: () => Ee, process: () => D, prettifyError: () => Is, parseAsync: () => fn, parse: () => pn, meta: () => xc, locales: () => er, isValidJWT: () => Gu, isValidBase64URL: () => Wu, isValidBase64: () => Gn, initializeContext: () => Je, globalRegistry: () => ge, globalConfig: () => Xt, formatError: () => An, flattenError: () => En, finalize: () => We, extractDefs: () => qe, encodeAsync: () => m_, encode: () => c_, describe: () => zc, decodeAsync: () => p_, decode: () => d_, createToJSONSchemaMethod: () => Uc, createStandardJSONSchemaMethod: () => nt, config: () => Q, clone: () => pe, _xor: () => D$, _xid: () => mr, _void: () => hc, _uuidv7: () => or, _uuidv6: () => ar, _uuidv4: () => rr, _uuid: () => nr, _url: () => bi, _uppercase: () => Ii, _unknown: () => fc, _union: () => Z$, _undefined: () => dc, _ulid: () => dr, _uint64: () => lc, _uint32: () => nc, _tuple: () => T$, _trim: () => Oi, _transform: () => q$, _toUpperCase: () => ji, _toLowerCase: () => Ui, _templateLiteral: () => Q$, _symbol: () => cc, _superRefine: () => wc, _success: () => B$, _stringbool: () => Oc, _stringFormat: () => Ot, _string: () => Jl, _startsWith: () => wi, _slugify: () => Pi, _size: () => _i, _set: () => M$, _safeParseAsync: () => yt, _safeParse: () => _t, _safeEncodeAsync: () => Jn, _safeEncode: () => Ln, _safeDecodeAsync: () => qn, _safeDecode: () => Fn, _regex: () => yi, _refine: () => kc, _record: () => R$, _readonly: () => Y$, _property: () => zr, _promise: () => tI, _positive: () => Ir, _pipe: () => X$, _parseAsync: () => bt, _parse: () => vt, _overwrite: () => ye, _optional: () => W$, _number: () => Xl, _nullable: () => K$, _null: () => mc, _normalize: () => xi, _nonpositive: () => wr, _nonoptional: () => G$, _nonnegative: () => Sr, _never: () => gc, _negative: () => kr, _nativeEnum: () => F$, _nanoid: () => ur, _nan: () => _c, _multipleOf: () => Le, _minSize: () => Fe, _minLength: () => Pe, _min: () => ie, _mime: () => zi, _maxSize: () => St, _maxLength: () => zt, _max: () => le, _map: () => C$, _mac: () => Wl, _lte: () => le, _lt: () => ke, _lowercase: () => $i, _literal: () => J$, _length: () => xt, _lazy: () => eI, _ksuid: () => pr, _jwt: () => $r, _isoTime: () => Bl, _isoDuration: () => Hl, _isoDateTime: () => Vl, _isoDate: () => Gl, _ipv6: () => gr, _ipv4: () => fr, _intersection: () => A$, _int64: () => uc, _int32: () => ic, _int: () => Ql, _includes: () => ki, _guid: () => ii, _gte: () => ie, _gt: () => we, _float64: () => tc, _float32: () => ec, _file: () => $c, _enum: () => L$, _endsWith: () => Si, _encodeAsync: () => Cn, _encode: () => Tn, _emoji: () => sr, _email: () => ir, _e164: () => yr, _discriminatedUnion: () => E$, _default: () => V$, _decodeAsync: () => Mn, _decode: () => Rn, _date: () => vc, _custom: () => Ic, _cuid2: () => cr, _cuid: () => lr, _coercedString: () => ql, _coercedNumber: () => Yl, _coercedDate: () => bc, _coercedBoolean: () => ac, _coercedBigint: () => sc, _cidrv6: () => vr, _cidrv4: () => hr, _check: () => Sc, _catch: () => H$, _boolean: () => rc, _bigint: () => oc, _base64url: () => _r, _base64: () => br, _array: () => yc, _any: () => pc, TimePrecision: () => Kl, NEVER: () => ss, JSONSchemaGenerator: () => nI, JSONSchema: () => rI, Doc: () => Iu, $output: () => Ml, $input: () => Ll, $constructor: () => m, $brand: () => us, $ZodXor: () => ml, $ZodXID: () => Zu, $ZodVoid: () => al, $ZodUnknown: () => nl, $ZodUnion: () => vi, $ZodUndefined: () => el, $ZodUUID: () => Su, $ZodURL: () => xu, $ZodULID: () => Nu, $ZodType: () => S, $ZodTuple: () => Yn, $ZodTransform: () => $l, $ZodTemplateLiteral: () => Nl, $ZodSymbol: () => Qu, $ZodSuccess: () => xl, $ZodStringFormat: () => E, $ZodString: () => wt, $ZodSet: () => vl, $ZodRegistry: () => Fl, $ZodRecord: () => gl, $ZodRealError: () => se, $ZodReadonly: () => Pl, $ZodPromise: () => Dl, $ZodPrefault: () => Sl, $ZodPipe: () => jl, $ZodOptional: () => Il, $ZodObjectJIT: () => dl, $ZodObject: () => cl, $ZodNumberFormat: () => Xu, $ZodNumber: () => Bn, $ZodNullable: () => kl, $ZodNull: () => tl, $ZodNonOptional: () => zl, $ZodNever: () => rl, $ZodNanoID: () => Uu, $ZodNaN: () => Ul, $ZodMap: () => hl, $ZodMAC: () => Lu, $ZodLiteral: () => _l, $ZodLazy: () => El, $ZodKSUID: () => Du, $ZodJWT: () => Bu, $ZodIntersection: () => fl, $ZodISOTime: () => Tu, $ZodISODuration: () => Ru, $ZodISODateTime: () => Eu, $ZodISODate: () => Au, $ZodIPv6: () => Mu, $ZodIPv4: () => Cu, $ZodGUID: () => wu, $ZodFunction: () => Zl, $ZodFile: () => yl, $ZodError: () => Dn, $ZodEnum: () => bl, $ZodEncodeError: () => pi, $ZodEmoji: () => Ou, $ZodEmail: () => zu, $ZodE164: () => Vu, $ZodDiscriminatedUnion: () => pl, $ZodDefault: () => wl, $ZodDate: () => ol, $ZodCustomStringFormat: () => Hu, $ZodCustom: () => Al, $ZodCodec: () => Qn, $ZodCheckUpperCase: () => gu, $ZodCheckStringFormat: () => kt, $ZodCheckStartsWith: () => vu, $ZodCheckSizeEquals: () => lu, $ZodCheckRegex: () => pu, $ZodCheckProperty: () => _u, $ZodCheckOverwrite: () => $u, $ZodCheckNumberFormat: () => au, $ZodCheckMultipleOf: () => ru, $ZodCheckMinSize: () => uu, $ZodCheckMinLength: () => du, $ZodCheckMimeType: () => yu, $ZodCheckMaxSize: () => su, $ZodCheckMaxLength: () => cu, $ZodCheckLowerCase: () => fu, $ZodCheckLessThan: () => Kn, $ZodCheckLengthEquals: () => mu, $ZodCheckIncludes: () => hu, $ZodCheckGreaterThan: () => Vn, $ZodCheckEndsWith: () => bu, $ZodCheckBigIntFormat: () => ou, $ZodCheck: () => F, $ZodCatch: () => Ol, $ZodCUID2: () => Pu, $ZodCUID: () => ju, $ZodCIDRv6: () => Ju, $ZodCIDRv4: () => Fu, $ZodBoolean: () => Hn, $ZodBigIntFormat: () => Yu, $ZodBigInt: () => Xn, $ZodBase64URL: () => Ku, $ZodBase64: () => qu, $ZodAsyncError: () => Ue, $ZodArray: () => sl, $ZodAny: () => il });
var ss = Object.freeze({ status: "aborted" });
function m(e, t, n) {
  function r(s, l) {
    if (s._zod || Object.defineProperty(s, "_zod", { value: { def: l, constr: o, traits: /* @__PURE__ */ new Set() }, enumerable: !1 }), s._zod.traits.has(e)) return;
    s._zod.traits.add(e), t(s, l);
    let u = o.prototype, d = Object.keys(u);
    for (let f = 0; f < d.length; f++) {
      let h = d[f];
      h in s || (s[h] = u[h].bind(s));
    }
  }
  let i = n?.Parent ?? Object;
  class a extends i {
  }
  Object.defineProperty(a, "name", { value: e });
  function o(s) {
    var l;
    let u = n?.Parent ? new a() : this;
    r(u, s), (l = u._zod).deferred ?? (l.deferred = []);
    for (let d of u._zod.deferred) d();
    return u;
  }
  return Object.defineProperty(o, "init", { value: r }), Object.defineProperty(o, Symbol.hasInstance, { value: (s) => n?.Parent && s instanceof n.Parent ? !0 : s?._zod?.traits?.has(e) }), Object.defineProperty(o, "name", { value: e }), o;
}
var us = Symbol("zod_brand");
class Ue extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class pi extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
var Xt = {};
function Q(e) {
  return e && Object.assign(Xt, e), Xt;
}
var x = {};
_e(x, { unwrapMessage: () => Ye, uint8ArrayToHex: () => u_, uint8ArrayToBase64url: () => o_, uint8ArrayToBase64: () => bs, stringifyPrimitive: () => w, slugify: () => cs, shallowClone: () => ms, safeExtend: () => e_, required: () => n_, randomString: () => Vb, propertyKeyTypes: () => Qt, promiseAllObject: () => Kb, primitiveTypes: () => ps, prefixIssues: () => fe, pick: () => Xb, partial: () => i_, optionalKeys: () => fs, omit: () => Yb, objectClone: () => Jb, numKeys: () => Gb, nullish: () => De, normalizeParams: () => b, mergeDefs: () => ze, merge: () => t_, jsonStringifyReplacer: () => Yt, joinValues: () => v, issue: () => ei, isPlainObject: () => je, isObject: () => Ce, hexToUint8Array: () => s_, getSizableOrigin: () => gi, getParsedType: () => Bb, getLengthableOrigin: () => hi, getEnumValues: () => Nn, getElementAtPath: () => Wb, floatSafeRemainder: () => ls, finalizeIssue: () => ce, extend: () => Qb, escapeRegex: () => be, esc: () => mn, defineLazy: () => O, createTransparentProxy: () => Hb, cloneDef: () => qb, clone: () => pe, cleanRegex: () => fi, cleanEnum: () => r_, captureStackTrace: () => Zn, cached: () => ht, base64urlToUint8Array: () => a_, base64ToUint8Array: () => vs, assignProp: () => Se, assertNotEqual: () => Cb, assertNever: () => Lb, assertIs: () => Mb, assertEqual: () => Rb, assert: () => Fb, allowsEval: () => ds, aborted: () => Oe, NUMBER_FORMAT_RANGES: () => gs, Class: () => l_, BIGINT_FORMAT_RANGES: () => hs });
function Rb(e) {
  return e;
}
function Cb(e) {
  return e;
}
function Mb(e) {
}
function Lb(e) {
  throw Error("Unexpected value in exhaustive check");
}
function Fb(e) {
}
function Nn(e) {
  let t = Object.values(e).filter((n) => typeof n == "number");
  return Object.entries(e).filter(([n, r]) => t.indexOf(+n) === -1).map(([n, r]) => r);
}
function v(e, t = "|") {
  return e.map((n) => w(n)).join(t);
}
function Yt(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function ht(e) {
  return { get value() {
    {
      let t = e();
      return Object.defineProperty(this, "value", { value: t }), t;
    }
  } };
}
function De(e) {
  return e == null;
}
function fi(e) {
  let t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function ls(e, t) {
  let n = (e.toString().split(".")[1] || "").length, r = t.toString(), i = (r.split(".")[1] || "").length;
  if (i === 0 && /\d?e-\d?/.test(r)) {
    let l = r.match(/\d?e-(\d?)/);
    l?.[1] && (i = Number.parseInt(l[1]));
  }
  let a = n > i ? n : i, o = Number.parseInt(e.toFixed(a).replace(".", "")), s = Number.parseInt(t.toFixed(a).replace(".", ""));
  return o % s / 10 ** a;
}
var Ja = Symbol("evaluating");
function O(e, t, n) {
  let r;
  Object.defineProperty(e, t, { get() {
    if (r !== Ja)
      return r === void 0 && (r = Ja, r = n()), r;
  }, set(i) {
    Object.defineProperty(e, t, { value: i });
  }, configurable: !0 });
}
function Jb(e) {
  return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
}
function Se(e, t, n) {
  Object.defineProperty(e, t, { value: n, writable: !0, enumerable: !0, configurable: !0 });
}
function ze(...e) {
  let t = {};
  for (let n of e) {
    let r = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function qb(e) {
  return ze(e._zod.def);
}
function Wb(e, t) {
  return t ? t.reduce((n, r) => n?.[r], e) : e;
}
function Kb(e) {
  let t = Object.keys(e), n = t.map((r) => e[r]);
  return Promise.all(n).then((r) => {
    let i = {};
    for (let a = 0; a < t.length; a++) i[t[a]] = r[a];
    return i;
  });
}
function Vb(e = 10) {
  let t = "";
  for (let n = 0; n < e; n++) t += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return t;
}
function mn(e) {
  return JSON.stringify(e);
}
function cs(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var Zn = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function Ce(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
var ds = ht(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return !1;
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
});
function je(e) {
  if (Ce(e) === !1) return !1;
  let t = e.constructor;
  if (t === void 0 || typeof t != "function") return !0;
  let n = t.prototype;
  return !(Ce(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function ms(e) {
  return je(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
function Gb(e) {
  let t = 0;
  for (let n in e) Object.prototype.hasOwnProperty.call(e, n) && t++;
  return t;
}
var Bb = (e) => {
  let t = typeof e;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(e) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(e) ? "array" : e === null ? "null" : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? "promise" : typeof Map < "u" && e instanceof Map ? "map" : typeof Set < "u" && e instanceof Set ? "set" : typeof Date < "u" && e instanceof Date ? "date" : typeof File < "u" && e instanceof File ? "file" : "object";
    default:
      throw Error(`Unknown data type: ${t}`);
  }
}, Qt = /* @__PURE__ */ new Set(["string", "number", "symbol"]), ps = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function be(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function pe(e, t, n) {
  let r = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (r._zod.parent = e), r;
}
function b(e) {
  let t = e;
  if (!t) return {};
  if (typeof t == "string") return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0) throw Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function Hb(e) {
  let t;
  return new Proxy({}, { get(n, r, i) {
    return t ?? (t = e()), Reflect.get(t, r, i);
  }, set(n, r, i, a) {
    return t ?? (t = e()), Reflect.set(t, r, i, a);
  }, has(n, r) {
    return t ?? (t = e()), Reflect.has(t, r);
  }, deleteProperty(n, r) {
    return t ?? (t = e()), Reflect.deleteProperty(t, r);
  }, ownKeys(n) {
    return t ?? (t = e()), Reflect.ownKeys(t);
  }, getOwnPropertyDescriptor(n, r) {
    return t ?? (t = e()), Reflect.getOwnPropertyDescriptor(t, r);
  }, defineProperty(n, r, i) {
    return t ?? (t = e()), Reflect.defineProperty(t, r, i);
  } });
}
function w(e) {
  return typeof e == "bigint" ? e.toString() + "n" : typeof e == "string" ? `"${e}"` : `${e}`;
}
function fs(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
var gs = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] }, hs = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function Xb(e, t) {
  let n = e._zod.def, r = ze(e._zod.def, { get shape() {
    let i = {};
    for (let a in t) {
      if (!(a in n.shape)) throw Error(`Unrecognized key: "${a}"`);
      t[a] && (i[a] = n.shape[a]);
    }
    return Se(this, "shape", i), i;
  }, checks: [] });
  return pe(e, r);
}
function Yb(e, t) {
  let n = e._zod.def, r = ze(e._zod.def, { get shape() {
    let i = { ...e._zod.def.shape };
    for (let a in t) {
      if (!(a in n.shape)) throw Error(`Unrecognized key: "${a}"`);
      t[a] && delete i[a];
    }
    return Se(this, "shape", i), i;
  }, checks: [] });
  return pe(e, r);
}
function Qb(e, t) {
  if (!je(t)) throw Error("Invalid input to extend: expected a plain object");
  let n = e._zod.def.checks;
  if (n && n.length > 0) throw Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  let r = ze(e._zod.def, { get shape() {
    let i = { ...e._zod.def.shape, ...t };
    return Se(this, "shape", i), i;
  }, checks: [] });
  return pe(e, r);
}
function e_(e, t) {
  if (!je(t)) throw Error("Invalid input to safeExtend: expected a plain object");
  let n = { ...e._zod.def, get shape() {
    let r = { ...e._zod.def.shape, ...t };
    return Se(this, "shape", r), r;
  }, checks: e._zod.def.checks };
  return pe(e, n);
}
function t_(e, t) {
  let n = ze(e._zod.def, { get shape() {
    let r = { ...e._zod.def.shape, ...t._zod.def.shape };
    return Se(this, "shape", r), r;
  }, get catchall() {
    return t._zod.def.catchall;
  }, checks: [] });
  return pe(e, n);
}
function i_(e, t, n) {
  let r = ze(t._zod.def, { get shape() {
    let i = t._zod.def.shape, a = { ...i };
    if (n) for (let o in n) {
      if (!(o in i)) throw Error(`Unrecognized key: "${o}"`);
      n[o] && (a[o] = e ? new e({ type: "optional", innerType: i[o] }) : i[o]);
    }
    else for (let o in i) a[o] = e ? new e({ type: "optional", innerType: i[o] }) : i[o];
    return Se(this, "shape", a), a;
  }, checks: [] });
  return pe(t, r);
}
function n_(e, t, n) {
  let r = ze(t._zod.def, { get shape() {
    let i = t._zod.def.shape, a = { ...i };
    if (n) for (let o in n) {
      if (!(o in a)) throw Error(`Unrecognized key: "${o}"`);
      n[o] && (a[o] = new e({ type: "nonoptional", innerType: i[o] }));
    }
    else for (let o in i) a[o] = new e({ type: "nonoptional", innerType: i[o] });
    return Se(this, "shape", a), a;
  }, checks: [] });
  return pe(t, r);
}
function Oe(e, t = 0) {
  if (e.aborted === !0) return !0;
  for (let n = t; n < e.issues.length; n++) if (e.issues[n]?.continue !== !0) return !0;
  return !1;
}
function fe(e, t) {
  return t.map((n) => {
    var r;
    return (r = n).path ?? (r.path = []), n.path.unshift(e), n;
  });
}
function Ye(e) {
  return typeof e == "string" ? e : e?.message;
}
function ce(e, t, n) {
  let r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    let i = Ye(e.inst?._zod.def?.error?.(e)) ?? Ye(t?.error?.(e)) ?? Ye(n.customError?.(e)) ?? Ye(n.localeError?.(e)) ?? "Invalid input";
    r.message = i;
  }
  return delete r.inst, delete r.continue, !t?.reportInput && delete r.input, r;
}
function gi(e) {
  return e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof File ? "file" : "unknown";
}
function hi(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function ei(...e) {
  let [t, n, r] = e;
  return typeof t == "string" ? { message: t, code: "custom", input: n, inst: r } : { ...t };
}
function r_(e) {
  return Object.entries(e).filter(([t, n]) => Number.isNaN(Number.parseInt(t, 10))).map((t) => t[1]);
}
function vs(e) {
  let t = atob(e), n = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++) n[r] = t.charCodeAt(r);
  return n;
}
function bs(e) {
  let t = "";
  for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
  return btoa(t);
}
function a_(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/"), n = "=".repeat((4 - t.length % 4) % 4);
  return vs(t + n);
}
function o_(e) {
  return bs(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function s_(e) {
  let t = e.replace(/^0x/, "");
  if (t.length % 2 !== 0) throw Error("Invalid hex string length");
  let n = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2) n[r / 2] = Number.parseInt(t.slice(r, r + 2), 16);
  return n;
}
function u_(e) {
  return Array.from(e).map((t) => t.toString(16).padStart(2, "0")).join("");
}
class l_ {
  constructor(...t) {
  }
}
var _s = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", { value: e._zod, enumerable: !1 }), Object.defineProperty(e, "issues", { value: t, enumerable: !1 }), e.message = JSON.stringify(t, Yt, 2), Object.defineProperty(e, "toString", { value: () => e.message, enumerable: !1 });
}, Dn = m("$ZodError", _s), se = m("$ZodError", _s, { Parent: Error });
function En(e, t = (n) => n.message) {
  let n = {}, r = [];
  for (let i of e.issues) i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
  return { formErrors: r, fieldErrors: n };
}
function An(e, t = (n) => n.message) {
  let n = { _errors: [] }, r = (i) => {
    for (let a of i.issues) if (a.code === "invalid_union" && a.errors.length) a.errors.map((o) => r({ issues: o }));
    else if (a.code === "invalid_key") r({ issues: a.issues });
    else if (a.code === "invalid_element") r({ issues: a.issues });
    else if (a.path.length === 0) n._errors.push(t(a));
    else {
      let o = n, s = 0;
      for (; s < a.path.length; ) {
        let l = a.path[s];
        s !== a.path.length - 1 ? o[l] = o[l] || { _errors: [] } : (o[l] = o[l] || { _errors: [] }, o[l]._errors.push(t(a))), o = o[l], s++;
      }
    }
  };
  return r(e), n;
}
function ys(e, t = (n) => n.message) {
  let n = { errors: [] }, r = (i, a = []) => {
    var o, s;
    for (let l of i.issues) if (l.code === "invalid_union" && l.errors.length) l.errors.map((u) => r({ issues: u }, l.path));
    else if (l.code === "invalid_key") r({ issues: l.issues }, l.path);
    else if (l.code === "invalid_element") r({ issues: l.issues }, l.path);
    else {
      let u = [...a, ...l.path];
      if (u.length === 0) {
        n.errors.push(t(l));
        continue;
      }
      let d = n, f = 0;
      for (; f < u.length; ) {
        let h = u[f], $ = f === u.length - 1;
        typeof h == "string" ? (d.properties ?? (d.properties = {}), (o = d.properties)[h] ?? (o[h] = { errors: [] }), d = d.properties[h]) : (d.items ?? (d.items = []), (s = d.items)[h] ?? (s[h] = { errors: [] }), d = d.items[h]), $ && d.errors.push(t(l)), f++;
      }
    }
  };
  return r(e), n;
}
function $s(e) {
  let t = [], n = e.map((r) => typeof r == "object" ? r.key : r);
  for (let r of n) typeof r == "number" ? t.push(`[${r}]`) : typeof r == "symbol" ? t.push(`[${JSON.stringify(String(r))}]`) : /[^\w$]/.test(r) ? t.push(`[${JSON.stringify(r)}]`) : (t.length && t.push("."), t.push(r));
  return t.join("");
}
function Is(e) {
  let t = [], n = [...e.issues].sort((r, i) => (r.path ?? []).length - (i.path ?? []).length);
  for (let r of n) t.push(` ${r.message}`), r.path?.length && t.push(`   at ${$s(r.path)}`);
  return t.join(`
`);
}
var vt = (e) => (t, n, r, i) => {
  let a = r ? Object.assign(r, { async: !1 }) : { async: !1 }, o = t._zod.run({ value: n, issues: [] }, a);
  if (o instanceof Promise) throw new Ue();
  if (o.issues.length) {
    let s = new (i?.Err ?? e)(o.issues.map((l) => ce(l, a, Q())));
    throw Zn(s, i?.callee), s;
  }
  return o.value;
}, pn = vt(se), bt = (e) => async (t, n, r, i) => {
  let a = r ? Object.assign(r, { async: !0 }) : { async: !0 }, o = t._zod.run({ value: n, issues: [] }, a);
  if (o instanceof Promise && (o = await o), o.issues.length) {
    let s = new (i?.Err ?? e)(o.issues.map((l) => ce(l, a, Q())));
    throw Zn(s, i?.callee), s;
  }
  return o.value;
}, fn = bt(se), _t = (e) => (t, n, r) => {
  let i = r ? { ...r, async: !1 } : { async: !1 }, a = t._zod.run({ value: n, issues: [] }, i);
  if (a instanceof Promise) throw new Ue();
  return a.issues.length ? { success: !1, error: new (e ?? Dn)(a.issues.map((o) => ce(o, i, Q()))) } : { success: !0, data: a.value };
}, ks = _t(se), yt = (e) => async (t, n, r) => {
  let i = r ? Object.assign(r, { async: !0 }) : { async: !0 }, a = t._zod.run({ value: n, issues: [] }, i);
  return a instanceof Promise && (a = await a), a.issues.length ? { success: !1, error: new e(a.issues.map((o) => ce(o, i, Q()))) } : { success: !0, data: a.value };
}, ws = yt(se), Tn = (e) => (t, n, r) => {
  let i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return vt(e)(t, n, i);
}, c_ = Tn(se), Rn = (e) => (t, n, r) => vt(e)(t, n, r), d_ = Rn(se), Cn = (e) => async (t, n, r) => {
  let i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return bt(e)(t, n, i);
}, m_ = Cn(se), Mn = (e) => async (t, n, r) => bt(e)(t, n, r), p_ = Mn(se), Ln = (e) => (t, n, r) => {
  let i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return _t(e)(t, n, i);
}, f_ = Ln(se), Fn = (e) => (t, n, r) => _t(e)(t, n, r), g_ = Fn(se), Jn = (e) => async (t, n, r) => {
  let i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return yt(e)(t, n, i);
}, h_ = Jn(se), qn = (e) => async (t, n, r) => yt(e)(t, n, r), v_ = qn(se), Ee = {};
_e(Ee, { xid: () => Os, uuid7: () => $_, uuid6: () => y_, uuid4: () => __, uuid: () => Me, uppercase: () => iu, unicodeEmail: () => Ds, undefined: () => eu, ulid: () => xs, time: () => Ks, string: () => Gs, sha512_hex: () => F_, sha512_base64url: () => q_, sha512_base64: () => J_, sha384_hex: () => C_, sha384_base64url: () => L_, sha384_base64: () => M_, sha256_hex: () => A_, sha256_base64url: () => R_, sha256_base64: () => T_, sha1_hex: () => Z_, sha1_base64url: () => E_, sha1_base64: () => D_, rfc5322Email: () => k_, number: () => Xs, null: () => Qs, nanoid: () => js, md5_hex: () => j_, md5_base64url: () => N_, md5_base64: () => P_, mac: () => Rs, lowercase: () => tu, ksuid: () => Us, ipv6: () => Ts, ipv4: () => As, integer: () => Hs, idnEmail: () => w_, html5Email: () => I_, hostname: () => x_, hex: () => U_, guid: () => Ns, extendedDuration: () => b_, emoji: () => Es, email: () => Zs, e164: () => Fs, duration: () => Ps, domain: () => O_, datetime: () => Vs, date: () => qs, cuid2: () => zs, cuid: () => Ss, cidrv6: () => Ms, cidrv4: () => Cs, browserEmail: () => S_, boolean: () => Ys, bigint: () => Bs, base64url: () => Wn, base64: () => Ls });
var Ss = /^[cC][^\s-]{8,}$/, zs = /^[0-9a-z]+$/, xs = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Os = /^[0-9a-vA-V]{20}$/, Us = /^[A-Za-z0-9]{27}$/, js = /^[a-zA-Z0-9_-]{21}$/, Ps = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, b_ = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Ns = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Me = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, __ = Me(4), y_ = Me(6), $_ = Me(7), Zs = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, I_ = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, k_ = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, Ds = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, w_ = Ds, S_ = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, z_ = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Es() {
  return new RegExp(z_, "u");
}
var As = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ts = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Rs = (e) => {
  let t = be(e ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${t}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${t}){5}[0-9a-f]{2}$`);
}, Cs = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Ms = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Ls = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Wn = /^[A-Za-z0-9_-]*$/, x_ = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, O_ = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, Fs = /^\+(?:[0-9]){6,14}[0-9]$/, Js = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", qs = new RegExp(`^${Js}$`);
function Ws(e) {
  return typeof e.precision == "number" ? e.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : e.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${e.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function Ks(e) {
  return new RegExp(`^${Ws(e)}$`);
}
function Vs(e) {
  let t = Ws({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${Js}T(?:${r})$`);
}
var Gs = (e) => {
  let t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, Bs = /^-?\d+n?$/, Hs = /^-?\d+$/, Xs = /^-?\d+(?:\.\d+)?/, Ys = /^(?:true|false)$/i, Qs = /^null$/i, eu = /^undefined$/i, tu = /^[^A-Z]*$/, iu = /^[^a-z]*$/, U_ = /^[0-9a-fA-F]*$/;
function $t(e, t) {
  return new RegExp(`^[A-Za-z0-9+/]{${e}}${t}$`);
}
function It(e) {
  return new RegExp(`^[A-Za-z0-9_-]{${e}}$`);
}
var j_ = /^[0-9a-fA-F]{32}$/, P_ = $t(22, "=="), N_ = It(22), Z_ = /^[0-9a-fA-F]{40}$/, D_ = $t(27, "="), E_ = It(27), A_ = /^[0-9a-fA-F]{64}$/, T_ = $t(43, "="), R_ = It(43), C_ = /^[0-9a-fA-F]{96}$/, M_ = $t(64, ""), L_ = It(64), F_ = /^[0-9a-fA-F]{128}$/, J_ = $t(86, "=="), q_ = It(86), F = m("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), nu = { number: "number", bigint: "bigint", object: "date" }, Kn = m("$ZodCheckLessThan", (e, t) => {
  F.init(e, t);
  let n = nu[typeof t.value];
  e._zod.onattach.push((r) => {
    let i = r._zod.bag, a = (t.inclusive ? i.maximum : i.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < a && (t.inclusive ? i.maximum = t.value : i.exclusiveMaximum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value <= t.value : r.value < t.value) || r.issues.push({ origin: n, code: "too_big", maximum: t.value, input: r.value, inclusive: t.inclusive, inst: e, continue: !t.abort });
  };
}), Vn = m("$ZodCheckGreaterThan", (e, t) => {
  F.init(e, t);
  let n = nu[typeof t.value];
  e._zod.onattach.push((r) => {
    let i = r._zod.bag, a = (t.inclusive ? i.minimum : i.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > a && (t.inclusive ? i.minimum = t.value : i.exclusiveMinimum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value >= t.value : r.value > t.value) || r.issues.push({ origin: n, code: "too_small", minimum: t.value, input: r.value, inclusive: t.inclusive, inst: e, continue: !t.abort });
  };
}), ru = m("$ZodCheckMultipleOf", (e, t) => {
  F.init(e, t), e._zod.onattach.push((n) => {
    var r;
    (r = n._zod.bag).multipleOf ?? (r.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : ls(n.value, t.value) === 0) || n.issues.push({ origin: typeof n.value, code: "not_multiple_of", divisor: t.value, input: n.value, inst: e, continue: !t.abort });
  };
}), au = m("$ZodCheckNumberFormat", (e, t) => {
  F.init(e, t), t.format = t.format || "float64";
  let n = t.format?.includes("int"), r = n ? "int" : "number", [i, a] = gs[t.format];
  e._zod.onattach.push((o) => {
    let s = o._zod.bag;
    s.format = t.format, s.minimum = i, s.maximum = a, n && (s.pattern = Hs);
  }), e._zod.check = (o) => {
    let s = o.value;
    if (n) {
      if (!Number.isInteger(s)) {
        o.issues.push({ expected: r, format: t.format, code: "invalid_type", continue: !1, input: s, inst: e });
        return;
      }
      if (!Number.isSafeInteger(s)) {
        s > 0 ? o.issues.push({ input: s, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: r, continue: !t.abort }) : o.issues.push({ input: s, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: r, continue: !t.abort });
        return;
      }
    }
    s < i && o.issues.push({ origin: "number", input: s, code: "too_small", minimum: i, inclusive: !0, inst: e, continue: !t.abort }), s > a && o.issues.push({ origin: "number", input: s, code: "too_big", maximum: a, inst: e });
  };
}), ou = m("$ZodCheckBigIntFormat", (e, t) => {
  F.init(e, t);
  let [n, r] = hs[t.format];
  e._zod.onattach.push((i) => {
    let a = i._zod.bag;
    a.format = t.format, a.minimum = n, a.maximum = r;
  }), e._zod.check = (i) => {
    let a = i.value;
    a < n && i.issues.push({ origin: "bigint", input: a, code: "too_small", minimum: n, inclusive: !0, inst: e, continue: !t.abort }), a > r && i.issues.push({ origin: "bigint", input: a, code: "too_big", maximum: r, inst: e });
  };
}), su = m("$ZodCheckMaxSize", (e, t) => {
  var n;
  F.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    let i = r.value;
    return !De(i) && i.size !== void 0;
  }), e._zod.onattach.push((r) => {
    let i = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < i && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    let i = r.value;
    i.size <= t.maximum || r.issues.push({ origin: gi(i), code: "too_big", maximum: t.maximum, inclusive: !0, input: i, inst: e, continue: !t.abort });
  };
}), uu = m("$ZodCheckMinSize", (e, t) => {
  var n;
  F.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    let i = r.value;
    return !De(i) && i.size !== void 0;
  }), e._zod.onattach.push((r) => {
    let i = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > i && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    let i = r.value;
    i.size >= t.minimum || r.issues.push({ origin: gi(i), code: "too_small", minimum: t.minimum, inclusive: !0, input: i, inst: e, continue: !t.abort });
  };
}), lu = m("$ZodCheckSizeEquals", (e, t) => {
  var n;
  F.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    let i = r.value;
    return !De(i) && i.size !== void 0;
  }), e._zod.onattach.push((r) => {
    let i = r._zod.bag;
    i.minimum = t.size, i.maximum = t.size, i.size = t.size;
  }), e._zod.check = (r) => {
    let i = r.value, a = i.size;
    if (a === t.size) return;
    let o = a > t.size;
    r.issues.push({ origin: gi(i), ...o ? { code: "too_big", maximum: t.size } : { code: "too_small", minimum: t.size }, inclusive: !0, exact: !0, input: r.value, inst: e, continue: !t.abort });
  };
}), cu = m("$ZodCheckMaxLength", (e, t) => {
  var n;
  F.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    let i = r.value;
    return !De(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    let i = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < i && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    let i = r.value;
    if (i.length <= t.maximum) return;
    let a = hi(i);
    r.issues.push({ origin: a, code: "too_big", maximum: t.maximum, inclusive: !0, input: i, inst: e, continue: !t.abort });
  };
}), du = m("$ZodCheckMinLength", (e, t) => {
  var n;
  F.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    let i = r.value;
    return !De(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    let i = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > i && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    let i = r.value;
    if (i.length >= t.minimum) return;
    let a = hi(i);
    r.issues.push({ origin: a, code: "too_small", minimum: t.minimum, inclusive: !0, input: i, inst: e, continue: !t.abort });
  };
}), mu = m("$ZodCheckLengthEquals", (e, t) => {
  var n;
  F.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    let i = r.value;
    return !De(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    let i = r._zod.bag;
    i.minimum = t.length, i.maximum = t.length, i.length = t.length;
  }), e._zod.check = (r) => {
    let i = r.value, a = i.length;
    if (a === t.length) return;
    let o = hi(i), s = a > t.length;
    r.issues.push({ origin: o, ...s ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length }, inclusive: !0, exact: !0, input: r.value, inst: e, continue: !t.abort });
  };
}), kt = m("$ZodCheckStringFormat", (e, t) => {
  var n, r;
  F.init(e, t), e._zod.onattach.push((i) => {
    let a = i._zod.bag;
    a.format = t.format, t.pattern && (a.patterns ?? (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (i) => {
    t.pattern.lastIndex = 0, !t.pattern.test(i.value) && i.issues.push({ origin: "string", code: "invalid_format", format: t.format, input: i.value, ...t.pattern ? { pattern: t.pattern.toString() } : {}, inst: e, continue: !t.abort });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), pu = m("$ZodCheckRegex", (e, t) => {
  kt.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: n.value, pattern: t.pattern.toString(), inst: e, continue: !t.abort });
  };
}), fu = m("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = tu), kt.init(e, t);
}), gu = m("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = iu), kt.init(e, t);
}), hu = m("$ZodCheckIncludes", (e, t) => {
  F.init(e, t);
  let n = be(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = r, e._zod.onattach.push((i) => {
    let a = i._zod.bag;
    a.patterns ?? (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(r);
  }), e._zod.check = (i) => {
    i.value.includes(t.includes, t.position) || i.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: t.includes, input: i.value, inst: e, continue: !t.abort });
  };
}), vu = m("$ZodCheckStartsWith", (e, t) => {
  F.init(e, t);
  let n = new RegExp(`^${be(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    let i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: t.prefix, input: r.value, inst: e, continue: !t.abort });
  };
}), bu = m("$ZodCheckEndsWith", (e, t) => {
  F.init(e, t);
  let n = new RegExp(`.*${be(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    let i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: t.suffix, input: r.value, inst: e, continue: !t.abort });
  };
});
function qa(e, t, n) {
  e.issues.length && t.issues.push(...fe(n, e.issues));
}
var _u = m("$ZodCheckProperty", (e, t) => {
  F.init(e, t), e._zod.check = (n) => {
    let r = t.schema._zod.run({ value: n.value[t.property], issues: [] }, {});
    if (r instanceof Promise) return r.then((i) => qa(i, n, t.property));
    qa(r, n, t.property);
  };
}), yu = m("$ZodCheckMimeType", (e, t) => {
  F.init(e, t);
  let n = new Set(t.mime);
  e._zod.onattach.push((r) => {
    r._zod.bag.mime = t.mime;
  }), e._zod.check = (r) => {
    n.has(r.value.type) || r.issues.push({ code: "invalid_value", values: t.mime, input: r.value.type, inst: e, continue: !t.abort });
  };
}), $u = m("$ZodCheckOverwrite", (e, t) => {
  F.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class Iu {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    let n = t.split(`
`).filter((a) => a), r = Math.min(...n.map((a) => a.length - a.trimStart().length)), i = n.map((a) => a.slice(r)).map((a) => " ".repeat(this.indent * 2) + a);
    for (let a of i) this.content.push(a);
  }
  compile() {
    let t = Function, n = this?.args, r = [...(this?.content ?? [""]).map((i) => `  ${i}`)];
    return new t(...n, r.join(`
`));
  }
}
var ku = { major: 4, minor: 2, patch: 1 }, S = m("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = ku;
  let r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (let i of r) for (let a of i._zod.onattach) a(e);
  if (r.length === 0) (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
    e._zod.run = e._zod.parse;
  });
  else {
    let i = (o, s, l) => {
      let u = Oe(o), d;
      for (let f of s) {
        if (f._zod.def.when) {
          if (!f._zod.def.when(o)) continue;
        } else if (u) continue;
        let h = o.issues.length, $ = f._zod.check(o);
        if ($ instanceof Promise && l?.async === !1) throw new Ue();
        if (d || $ instanceof Promise) d = (d ?? Promise.resolve()).then(async () => {
          await $, o.issues.length !== h && (u || (u = Oe(o, h)));
        });
        else {
          if (o.issues.length === h) continue;
          u || (u = Oe(o, h));
        }
      }
      return d ? d.then(() => o) : o;
    }, a = (o, s, l) => {
      if (Oe(o)) return o.aborted = !0, o;
      let u = i(s, r, l);
      if (u instanceof Promise) {
        if (l.async === !1) throw new Ue();
        return u.then((d) => e._zod.parse(d, l));
      }
      return e._zod.parse(u, l);
    };
    e._zod.run = (o, s) => {
      if (s.skipChecks) return e._zod.parse(o, s);
      if (s.direction === "backward") {
        let u = e._zod.parse({ value: o.value, issues: [] }, { ...s, skipChecks: !0 });
        return u instanceof Promise ? u.then((d) => a(d, o, s)) : a(u, o, s);
      }
      let l = e._zod.parse(o, s);
      if (l instanceof Promise) {
        if (s.async === !1) throw new Ue();
        return l.then((u) => i(u, r, s));
      }
      return i(l, r, s);
    };
  }
  e["~standard"] = { validate: (i) => {
    try {
      let a = ks(e, i);
      return a.success ? { value: a.data } : { issues: a.error?.issues };
    } catch {
      return ws(e, i).then((o) => o.success ? { value: o.data } : { issues: o.error?.issues });
    }
  }, vendor: "zod", version: 1 };
}), wt = m("$ZodString", (e, t) => {
  S.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? Gs(e._zod.bag), e._zod.parse = (n, r) => {
    if (t.coerce) try {
      n.value = String(n.value);
    } catch {
    }
    return typeof n.value == "string" || n.issues.push({ expected: "string", code: "invalid_type", input: n.value, inst: e }), n;
  };
}), E = m("$ZodStringFormat", (e, t) => {
  kt.init(e, t), wt.init(e, t);
}), wu = m("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = Ns), E.init(e, t);
}), Su = m("$ZodUUID", (e, t) => {
  if (t.version) {
    let n = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[t.version];
    if (n === void 0) throw Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = Me(n));
  } else t.pattern ?? (t.pattern = Me());
  E.init(e, t);
}), zu = m("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = Zs), E.init(e, t);
}), xu = m("$ZodURL", (e, t) => {
  E.init(e, t), e._zod.check = (n) => {
    try {
      let r = n.value.trim(), i = new URL(r);
      t.hostname && (t.hostname.lastIndex = 0, !t.hostname.test(i.hostname) && n.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: t.hostname.source, input: n.value, inst: e, continue: !t.abort })), t.protocol && (t.protocol.lastIndex = 0, !t.protocol.test(i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol) && n.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: t.protocol.source, input: n.value, inst: e, continue: !t.abort })), t.normalize ? n.value = i.href : n.value = r;
      return;
    } catch {
      n.issues.push({ code: "invalid_format", format: "url", input: n.value, inst: e, continue: !t.abort });
    }
  };
}), Ou = m("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = Es()), E.init(e, t);
}), Uu = m("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = js), E.init(e, t);
}), ju = m("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = Ss), E.init(e, t);
}), Pu = m("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = zs), E.init(e, t);
}), Nu = m("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = xs), E.init(e, t);
}), Zu = m("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = Os), E.init(e, t);
}), Du = m("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = Us), E.init(e, t);
}), Eu = m("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = Vs(t)), E.init(e, t);
}), Au = m("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = qs), E.init(e, t);
}), Tu = m("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = Ks(t)), E.init(e, t);
}), Ru = m("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = Ps), E.init(e, t);
}), Cu = m("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = As), E.init(e, t), e._zod.bag.format = "ipv4";
}), Mu = m("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = Ts), E.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({ code: "invalid_format", format: "ipv6", input: n.value, inst: e, continue: !t.abort });
    }
  };
}), Lu = m("$ZodMAC", (e, t) => {
  t.pattern ?? (t.pattern = Rs(t.delimiter)), E.init(e, t), e._zod.bag.format = "mac";
}), Fu = m("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Cs), E.init(e, t);
}), Ju = m("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = Ms), E.init(e, t), e._zod.check = (n) => {
    let r = n.value.split("/");
    try {
      if (r.length !== 2) throw Error();
      let [i, a] = r;
      if (!a) throw Error();
      let o = Number(a);
      if (`${o}` !== a || o < 0 || o > 128) throw Error();
      new URL(`http://[${i}]`);
    } catch {
      n.issues.push({ code: "invalid_format", format: "cidrv6", input: n.value, inst: e, continue: !t.abort });
    }
  };
});
function Gn(e) {
  if (e === "") return !0;
  if (e.length % 4 !== 0) return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
var qu = m("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = Ls), E.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (n) => {
    Gn(n.value) || n.issues.push({ code: "invalid_format", format: "base64", input: n.value, inst: e, continue: !t.abort });
  };
});
function Wu(e) {
  if (!Wn.test(e)) return !1;
  let t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return Gn(n);
}
var Ku = m("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = Wn), E.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (n) => {
    Wu(n.value) || n.issues.push({ code: "invalid_format", format: "base64url", input: n.value, inst: e, continue: !t.abort });
  };
}), Vu = m("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = Fs), E.init(e, t);
});
function Gu(e, t = null) {
  try {
    let n = e.split(".");
    if (n.length !== 3) return !1;
    let [r] = n;
    if (!r) return !1;
    let i = JSON.parse(atob(r));
    return !("typ" in i && i?.typ !== "JWT" || !i.alg || t && (!("alg" in i) || i.alg !== t));
  } catch {
    return !1;
  }
}
var Bu = m("$ZodJWT", (e, t) => {
  E.init(e, t), e._zod.check = (n) => {
    Gu(n.value, t.alg) || n.issues.push({ code: "invalid_format", format: "jwt", input: n.value, inst: e, continue: !t.abort });
  };
}), Hu = m("$ZodCustomStringFormat", (e, t) => {
  E.init(e, t), e._zod.check = (n) => {
    t.fn(n.value) || n.issues.push({ code: "invalid_format", format: t.format, input: n.value, inst: e, continue: !t.abort });
  };
}), Bn = m("$ZodNumber", (e, t) => {
  S.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? Xs, e._zod.parse = (n, r) => {
    if (t.coerce) try {
      n.value = Number(n.value);
    } catch {
    }
    let i = n.value;
    if (typeof i == "number" && !Number.isNaN(i) && Number.isFinite(i)) return n;
    let a = typeof i == "number" ? Number.isNaN(i) ? "NaN" : Number.isFinite(i) ? void 0 : "Infinity" : void 0;
    return n.issues.push({ expected: "number", code: "invalid_type", input: i, inst: e, ...a ? { received: a } : {} }), n;
  };
}), Xu = m("$ZodNumberFormat", (e, t) => {
  au.init(e, t), Bn.init(e, t);
}), Hn = m("$ZodBoolean", (e, t) => {
  S.init(e, t), e._zod.pattern = Ys, e._zod.parse = (n, r) => {
    if (t.coerce) try {
      n.value = !!n.value;
    } catch {
    }
    let i = n.value;
    return typeof i == "boolean" || n.issues.push({ expected: "boolean", code: "invalid_type", input: i, inst: e }), n;
  };
}), Xn = m("$ZodBigInt", (e, t) => {
  S.init(e, t), e._zod.pattern = Bs, e._zod.parse = (n, r) => {
    if (t.coerce) try {
      n.value = BigInt(n.value);
    } catch {
    }
    return typeof n.value == "bigint" || n.issues.push({ expected: "bigint", code: "invalid_type", input: n.value, inst: e }), n;
  };
}), Yu = m("$ZodBigIntFormat", (e, t) => {
  ou.init(e, t), Xn.init(e, t);
}), Qu = m("$ZodSymbol", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    let i = n.value;
    return typeof i == "symbol" || n.issues.push({ expected: "symbol", code: "invalid_type", input: i, inst: e }), n;
  };
}), el = m("$ZodUndefined", (e, t) => {
  S.init(e, t), e._zod.pattern = eu, e._zod.values = /* @__PURE__ */ new Set([void 0]), e._zod.optin = "optional", e._zod.optout = "optional", e._zod.parse = (n, r) => {
    let i = n.value;
    return typeof i > "u" || n.issues.push({ expected: "undefined", code: "invalid_type", input: i, inst: e }), n;
  };
}), tl = m("$ZodNull", (e, t) => {
  S.init(e, t), e._zod.pattern = Qs, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (n, r) => {
    let i = n.value;
    return i === null || n.issues.push({ expected: "null", code: "invalid_type", input: i, inst: e }), n;
  };
}), il = m("$ZodAny", (e, t) => {
  S.init(e, t), e._zod.parse = (n) => n;
}), nl = m("$ZodUnknown", (e, t) => {
  S.init(e, t), e._zod.parse = (n) => n;
}), rl = m("$ZodNever", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => (n.issues.push({ expected: "never", code: "invalid_type", input: n.value, inst: e }), n);
}), al = m("$ZodVoid", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    let i = n.value;
    return typeof i > "u" || n.issues.push({ expected: "void", code: "invalid_type", input: i, inst: e }), n;
  };
}), ol = m("$ZodDate", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    if (t.coerce) try {
      n.value = new Date(n.value);
    } catch {
    }
    let i = n.value, a = i instanceof Date;
    return a && !Number.isNaN(i.getTime()) || n.issues.push({ expected: "date", code: "invalid_type", input: i, ...a ? { received: "Invalid Date" } : {}, inst: e }), n;
  };
});
function Wa(e, t, n) {
  e.issues.length && t.issues.push(...fe(n, e.issues)), t.value[n] = e.value;
}
var sl = m("$ZodArray", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    let i = n.value;
    if (!Array.isArray(i)) return n.issues.push({ expected: "array", code: "invalid_type", input: i, inst: e }), n;
    n.value = Array(i.length);
    let a = [];
    for (let o = 0; o < i.length; o++) {
      let s = i[o], l = t.element._zod.run({ value: s, issues: [] }, r);
      l instanceof Promise ? a.push(l.then((u) => Wa(u, n, o))) : Wa(l, n, o);
    }
    return a.length ? Promise.all(a).then(() => n) : n;
  };
});
function ti(e, t, n, r) {
  e.issues.length && t.issues.push(...fe(n, e.issues)), e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value;
}
function ul(e) {
  let t = Object.keys(e.shape);
  for (let r of t) if (!e.shape?.[r]?._zod?.traits?.has("$ZodType")) throw Error(`Invalid element at key "${r}": expected a Zod schema`);
  let n = fs(e.shape);
  return { ...e, keys: t, keySet: new Set(t), numKeys: t.length, optionalKeys: new Set(n) };
}
function ll(e, t, n, r, i, a) {
  let o = [], s = i.keySet, l = i.catchall._zod, u = l.def.type;
  for (let d in t) {
    if (s.has(d)) continue;
    if (u === "never") {
      o.push(d);
      continue;
    }
    let f = l.run({ value: t[d], issues: [] }, r);
    f instanceof Promise ? e.push(f.then((h) => ti(h, n, d, t))) : ti(f, n, d, t);
  }
  return o.length && n.issues.push({ code: "unrecognized_keys", keys: o, input: t, inst: a }), e.length ? Promise.all(e).then(() => n) : n;
}
var cl = m("$ZodObject", (e, t) => {
  if (S.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    let o = t.shape;
    Object.defineProperty(t, "shape", { get: () => {
      let s = { ...o };
      return Object.defineProperty(t, "shape", { value: s }), s;
    } });
  }
  let n = ht(() => ul(t));
  O(e._zod, "propValues", () => {
    let o = t.shape, s = {};
    for (let l in o) {
      let u = o[l]._zod;
      if (u.values) {
        s[l] ?? (s[l] = /* @__PURE__ */ new Set());
        for (let d of u.values) s[l].add(d);
      }
    }
    return s;
  });
  let r = Ce, i = t.catchall, a;
  e._zod.parse = (o, s) => {
    a ?? (a = n.value);
    let l = o.value;
    if (!r(l)) return o.issues.push({ expected: "object", code: "invalid_type", input: l, inst: e }), o;
    o.value = {};
    let u = [], d = a.shape;
    for (let f of a.keys) {
      let h = d[f]._zod.run({ value: l[f], issues: [] }, s);
      h instanceof Promise ? u.push(h.then(($) => ti($, o, f, l))) : ti(h, o, f, l);
    }
    return i ? ll(u, l, o, s, n.value, e) : u.length ? Promise.all(u).then(() => o) : o;
  };
}), dl = m("$ZodObjectJIT", (e, t) => {
  cl.init(e, t);
  let n = e._zod.parse, r = ht(() => ul(t)), i = (f) => {
    let h = new Iu(["shape", "payload", "ctx"]), $ = r.value, P = (Z) => {
      let U = mn(Z);
      return `shape[${U}]._zod.run({ value: input[${U}], issues: [] }, ctx)`;
    };
    h.write("const input = payload.value;");
    let ee = /* @__PURE__ */ Object.create(null), ve = 0;
    for (let Z of $.keys) ee[Z] = `key_${ve++}`;
    h.write("const newResult = {};");
    for (let Z of $.keys) {
      let U = ee[Z], T = mn(Z);
      h.write(`const ${U} = ${P(Z)};`), h.write(`
        if (${U}.issues.length) {
          payload.issues = payload.issues.concat(${U}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${T}, ...iss.path] : [${T}]
          })));
        }
        
        
        if (${U}.value === undefined) {
          if (${T} in input) {
            newResult[${T}] = undefined;
          }
        } else {
          newResult[${T}] = ${U}.value;
        }
        
      `);
    }
    h.write("payload.value = newResult;"), h.write("return payload;");
    let Te = h.compile();
    return (Z, U) => Te(f, Z, U);
  }, a, o = Ce, s = !Xt.jitless, l = s && ds.value, u = t.catchall, d;
  e._zod.parse = (f, h) => {
    d ?? (d = r.value);
    let $ = f.value;
    return o($) ? s && l && h?.async === !1 && h.jitless !== !0 ? (a || (a = i(t.shape)), f = a(f, h), u ? ll([], $, f, h, d, e) : f) : n(f, h) : (f.issues.push({ expected: "object", code: "invalid_type", input: $, inst: e }), f);
  };
});
function Ka(e, t, n, r) {
  for (let a of e) if (a.issues.length === 0) return t.value = a.value, t;
  let i = e.filter((a) => !Oe(a));
  return i.length === 1 ? (t.value = i[0].value, i[0]) : (t.issues.push({ code: "invalid_union", input: t.value, inst: n, errors: e.map((a) => a.issues.map((o) => ce(o, r, Q()))) }), t);
}
var vi = m("$ZodUnion", (e, t) => {
  S.init(e, t), O(e._zod, "optin", () => t.options.some((i) => i._zod.optin === "optional") ? "optional" : void 0), O(e._zod, "optout", () => t.options.some((i) => i._zod.optout === "optional") ? "optional" : void 0), O(e._zod, "values", () => {
    if (t.options.every((i) => i._zod.values)) return new Set(t.options.flatMap((i) => Array.from(i._zod.values)));
  }), O(e._zod, "pattern", () => {
    if (t.options.every((i) => i._zod.pattern)) {
      let i = t.options.map((a) => a._zod.pattern);
      return new RegExp(`^(${i.map((a) => fi(a.source)).join("|")})$`);
    }
  });
  let n = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (i, a) => {
    if (n) return r(i, a);
    let o = !1, s = [];
    for (let l of t.options) {
      let u = l._zod.run({ value: i.value, issues: [] }, a);
      if (u instanceof Promise) s.push(u), o = !0;
      else {
        if (u.issues.length === 0) return u;
        s.push(u);
      }
    }
    return o ? Promise.all(s).then((l) => Ka(l, i, e, a)) : Ka(s, i, e, a);
  };
});
function Va(e, t, n, r) {
  let i = e.filter((a) => a.issues.length === 0);
  return i.length === 1 ? (t.value = i[0].value, t) : (i.length === 0 ? t.issues.push({ code: "invalid_union", input: t.value, inst: n, errors: e.map((a) => a.issues.map((o) => ce(o, r, Q()))) }) : t.issues.push({ code: "invalid_union", input: t.value, inst: n, errors: [], inclusive: !1 }), t);
}
var ml = m("$ZodXor", (e, t) => {
  vi.init(e, t), t.inclusive = !1;
  let n = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (i, a) => {
    if (n) return r(i, a);
    let o = !1, s = [];
    for (let l of t.options) {
      let u = l._zod.run({ value: i.value, issues: [] }, a);
      u instanceof Promise ? (s.push(u), o = !0) : s.push(u);
    }
    return o ? Promise.all(s).then((l) => Va(l, i, e, a)) : Va(s, i, e, a);
  };
}), pl = m("$ZodDiscriminatedUnion", (e, t) => {
  t.inclusive = !1, vi.init(e, t);
  let n = e._zod.parse;
  O(e._zod, "propValues", () => {
    let i = {};
    for (let a of t.options) {
      let o = a._zod.propValues;
      if (!o || Object.keys(o).length === 0) throw Error(`Invalid discriminated union option at index "${t.options.indexOf(a)}"`);
      for (let [s, l] of Object.entries(o)) {
        i[s] || (i[s] = /* @__PURE__ */ new Set());
        for (let u of l) i[s].add(u);
      }
    }
    return i;
  });
  let r = ht(() => {
    let i = t.options, a = /* @__PURE__ */ new Map();
    for (let o of i) {
      let s = o._zod.propValues?.[t.discriminator];
      if (!s || s.size === 0) throw Error(`Invalid discriminated union option at index "${t.options.indexOf(o)}"`);
      for (let l of s) {
        if (a.has(l)) throw Error(`Duplicate discriminator value "${String(l)}"`);
        a.set(l, o);
      }
    }
    return a;
  });
  e._zod.parse = (i, a) => {
    let o = i.value;
    if (!Ce(o)) return i.issues.push({ code: "invalid_type", expected: "object", input: o, inst: e }), i;
    let s = r.value.get(o?.[t.discriminator]);
    return s ? s._zod.run(i, a) : t.unionFallback ? n(i, a) : (i.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: t.discriminator, input: o, path: [t.discriminator], inst: e }), i);
  };
}), fl = m("$ZodIntersection", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    let i = n.value, a = t.left._zod.run({ value: i, issues: [] }, r), o = t.right._zod.run({ value: i, issues: [] }, r);
    return a instanceof Promise || o instanceof Promise ? Promise.all([a, o]).then(([s, l]) => Ga(n, s, l)) : Ga(n, a, o);
  };
});
function gn(e, t) {
  if (e === t) return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t) return { valid: !0, data: e };
  if (je(e) && je(t)) {
    let n = Object.keys(t), r = Object.keys(e).filter((a) => n.indexOf(a) !== -1), i = { ...e, ...t };
    for (let a of r) {
      let o = gn(e[a], t[a]);
      if (!o.valid) return { valid: !1, mergeErrorPath: [a, ...o.mergeErrorPath] };
      i[a] = o.data;
    }
    return { valid: !0, data: i };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length) return { valid: !1, mergeErrorPath: [] };
    let n = [];
    for (let r = 0; r < e.length; r++) {
      let i = e[r], a = t[r], o = gn(i, a);
      if (!o.valid) return { valid: !1, mergeErrorPath: [r, ...o.mergeErrorPath] };
      n.push(o.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function Ga(e, t, n) {
  if (t.issues.length && e.issues.push(...t.issues), n.issues.length && e.issues.push(...n.issues), Oe(e)) return e;
  let r = gn(t.value, n.value);
  if (!r.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
  return e.value = r.data, e;
}
var Yn = m("$ZodTuple", (e, t) => {
  S.init(e, t);
  let n = t.items;
  e._zod.parse = (r, i) => {
    let a = r.value;
    if (!Array.isArray(a)) return r.issues.push({ input: a, inst: e, expected: "tuple", code: "invalid_type" }), r;
    r.value = [];
    let o = [], s = [...n].reverse().findIndex((d) => d._zod.optin !== "optional"), l = s === -1 ? 0 : n.length - s;
    if (!t.rest) {
      let d = a.length > n.length, f = a.length < l - 1;
      if (d || f) return r.issues.push({ ...d ? { code: "too_big", maximum: n.length } : { code: "too_small", minimum: n.length }, input: a, inst: e, origin: "array" }), r;
    }
    let u = -1;
    for (let d of n) {
      if (u++, u >= a.length && u >= l)
        continue;
      let f = d._zod.run({ value: a[u], issues: [] }, i);
      f instanceof Promise ? o.push(f.then((h) => qt(h, r, u))) : qt(f, r, u);
    }
    if (t.rest) {
      let d = a.slice(n.length);
      for (let f of d) {
        u++;
        let h = t.rest._zod.run({ value: f, issues: [] }, i);
        h instanceof Promise ? o.push(h.then(($) => qt($, r, u))) : qt(h, r, u);
      }
    }
    return o.length ? Promise.all(o).then(() => r) : r;
  };
});
function qt(e, t, n) {
  e.issues.length && t.issues.push(...fe(n, e.issues)), t.value[n] = e.value;
}
var gl = m("$ZodRecord", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    let i = n.value;
    if (!je(i)) return n.issues.push({ expected: "record", code: "invalid_type", input: i, inst: e }), n;
    let a = [], o = t.keyType._zod.values;
    if (o) {
      n.value = {};
      let s = /* @__PURE__ */ new Set();
      for (let u of o) if (typeof u == "string" || typeof u == "number" || typeof u == "symbol") {
        s.add(typeof u == "number" ? u.toString() : u);
        let d = t.valueType._zod.run({ value: i[u], issues: [] }, r);
        d instanceof Promise ? a.push(d.then((f) => {
          f.issues.length && n.issues.push(...fe(u, f.issues)), n.value[u] = f.value;
        })) : (d.issues.length && n.issues.push(...fe(u, d.issues)), n.value[u] = d.value);
      }
      let l;
      for (let u in i) s.has(u) || (l = l ?? [], l.push(u));
      l && l.length > 0 && n.issues.push({ code: "unrecognized_keys", input: i, inst: e, keys: l });
    } else {
      n.value = {};
      for (let s of Reflect.ownKeys(i)) {
        if (s === "__proto__") continue;
        let l = t.keyType._zod.run({ value: s, issues: [] }, r);
        if (l instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (l.issues.length) {
          t.mode === "loose" ? n.value[s] = i[s] : n.issues.push({ code: "invalid_key", origin: "record", issues: l.issues.map((d) => ce(d, r, Q())), input: s, path: [s], inst: e });
          continue;
        }
        let u = t.valueType._zod.run({ value: i[s], issues: [] }, r);
        u instanceof Promise ? a.push(u.then((d) => {
          d.issues.length && n.issues.push(...fe(s, d.issues)), n.value[l.value] = d.value;
        })) : (u.issues.length && n.issues.push(...fe(s, u.issues)), n.value[l.value] = u.value);
      }
    }
    return a.length ? Promise.all(a).then(() => n) : n;
  };
}), hl = m("$ZodMap", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    let i = n.value;
    if (!(i instanceof Map)) return n.issues.push({ expected: "map", code: "invalid_type", input: i, inst: e }), n;
    let a = [];
    n.value = /* @__PURE__ */ new Map();
    for (let [o, s] of i) {
      let l = t.keyType._zod.run({ value: o, issues: [] }, r), u = t.valueType._zod.run({ value: s, issues: [] }, r);
      l instanceof Promise || u instanceof Promise ? a.push(Promise.all([l, u]).then(([d, f]) => {
        Ba(d, f, n, o, i, e, r);
      })) : Ba(l, u, n, o, i, e, r);
    }
    return a.length ? Promise.all(a).then(() => n) : n;
  };
});
function Ba(e, t, n, r, i, a, o) {
  e.issues.length && (Qt.has(typeof r) ? n.issues.push(...fe(r, e.issues)) : n.issues.push({ code: "invalid_key", origin: "map", input: i, inst: a, issues: e.issues.map((s) => ce(s, o, Q())) })), t.issues.length && (Qt.has(typeof r) ? n.issues.push(...fe(r, t.issues)) : n.issues.push({ origin: "map", code: "invalid_element", input: i, inst: a, key: r, issues: t.issues.map((s) => ce(s, o, Q())) })), n.value.set(e.value, t.value);
}
var vl = m("$ZodSet", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    let i = n.value;
    if (!(i instanceof Set)) return n.issues.push({ input: i, inst: e, expected: "set", code: "invalid_type" }), n;
    let a = [];
    n.value = /* @__PURE__ */ new Set();
    for (let o of i) {
      let s = t.valueType._zod.run({ value: o, issues: [] }, r);
      s instanceof Promise ? a.push(s.then((l) => Ha(l, n))) : Ha(s, n);
    }
    return a.length ? Promise.all(a).then(() => n) : n;
  };
});
function Ha(e, t) {
  e.issues.length && t.issues.push(...e.issues), t.value.add(e.value);
}
var bl = m("$ZodEnum", (e, t) => {
  S.init(e, t);
  let n = Nn(t.entries), r = new Set(n);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${n.filter((i) => Qt.has(typeof i)).map((i) => typeof i == "string" ? be(i) : i.toString()).join("|")})$`), e._zod.parse = (i, a) => {
    let o = i.value;
    return r.has(o) || i.issues.push({ code: "invalid_value", values: n, input: o, inst: e }), i;
  };
}), _l = m("$ZodLiteral", (e, t) => {
  if (S.init(e, t), t.values.length === 0) throw Error("Cannot create literal schema with no valid values");
  let n = new Set(t.values);
  e._zod.values = n, e._zod.pattern = new RegExp(`^(${t.values.map((r) => typeof r == "string" ? be(r) : r ? be(r.toString()) : String(r)).join("|")})$`), e._zod.parse = (r, i) => {
    let a = r.value;
    return n.has(a) || r.issues.push({ code: "invalid_value", values: t.values, input: a, inst: e }), r;
  };
}), yl = m("$ZodFile", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    let i = n.value;
    return i instanceof File || n.issues.push({ expected: "file", code: "invalid_type", input: i, inst: e }), n;
  };
}), $l = m("$ZodTransform", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    if (r.direction === "backward") throw new pi(e.constructor.name);
    let i = t.transform(n.value, n);
    if (r.async) return (i instanceof Promise ? i : Promise.resolve(i)).then((a) => (n.value = a, n));
    if (i instanceof Promise) throw new Ue();
    return n.value = i, n;
  };
});
function Xa(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
var Il = m("$ZodOptional", (e, t) => {
  S.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", O(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), O(e._zod, "pattern", () => {
    let n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${fi(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, r) => {
    if (t.innerType._zod.optin === "optional") {
      let i = t.innerType._zod.run(n, r);
      return i instanceof Promise ? i.then((a) => Xa(a, n.value)) : Xa(i, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, r);
  };
}), kl = m("$ZodNullable", (e, t) => {
  S.init(e, t), O(e._zod, "optin", () => t.innerType._zod.optin), O(e._zod, "optout", () => t.innerType._zod.optout), O(e._zod, "pattern", () => {
    let n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${fi(n.source)}|null)$`) : void 0;
  }), O(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r);
}), wl = m("$ZodDefault", (e, t) => {
  S.init(e, t), e._zod.optin = "optional", O(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward") return t.innerType._zod.run(n, r);
    if (n.value === void 0) return n.value = t.defaultValue, n;
    let i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((a) => Ya(a, t)) : Ya(i, t);
  };
});
function Ya(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
var Sl = m("$ZodPrefault", (e, t) => {
  S.init(e, t), e._zod.optin = "optional", O(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => (r.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, r));
}), zl = m("$ZodNonOptional", (e, t) => {
  S.init(e, t), O(e._zod, "values", () => {
    let n = t.innerType._zod.values;
    return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (n, r) => {
    let i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((a) => Qa(a, e)) : Qa(i, e);
  };
});
function Qa(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({ code: "invalid_type", expected: "nonoptional", input: e.value, inst: t }), e;
}
var xl = m("$ZodSuccess", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => {
    if (r.direction === "backward") throw new pi("ZodSuccess");
    let i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((a) => (n.value = a.issues.length === 0, n)) : (n.value = i.issues.length === 0, n);
  };
}), Ol = m("$ZodCatch", (e, t) => {
  S.init(e, t), O(e._zod, "optin", () => t.innerType._zod.optin), O(e._zod, "optout", () => t.innerType._zod.optout), O(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward") return t.innerType._zod.run(n, r);
    let i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((a) => (n.value = a.value, a.issues.length && (n.value = t.catchValue({ ...n, error: { issues: a.issues.map((o) => ce(o, r, Q())) }, input: n.value }), n.issues = []), n)) : (n.value = i.value, i.issues.length && (n.value = t.catchValue({ ...n, error: { issues: i.issues.map((a) => ce(a, r, Q())) }, input: n.value }), n.issues = []), n);
  };
}), Ul = m("$ZodNaN", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => ((typeof n.value != "number" || !Number.isNaN(n.value)) && n.issues.push({ input: n.value, inst: e, expected: "nan", code: "invalid_type" }), n);
}), jl = m("$ZodPipe", (e, t) => {
  S.init(e, t), O(e._zod, "values", () => t.in._zod.values), O(e._zod, "optin", () => t.in._zod.optin), O(e._zod, "optout", () => t.out._zod.optout), O(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, r) => {
    if (r.direction === "backward") {
      let a = t.out._zod.run(n, r);
      return a instanceof Promise ? a.then((o) => Wt(o, t.in, r)) : Wt(a, t.in, r);
    }
    let i = t.in._zod.run(n, r);
    return i instanceof Promise ? i.then((a) => Wt(a, t.out, r)) : Wt(i, t.out, r);
  };
});
function Wt(e, t, n) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n);
}
var Qn = m("$ZodCodec", (e, t) => {
  S.init(e, t), O(e._zod, "values", () => t.in._zod.values), O(e._zod, "optin", () => t.in._zod.optin), O(e._zod, "optout", () => t.out._zod.optout), O(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, r) => {
    if ((r.direction || "forward") === "forward") {
      let i = t.in._zod.run(n, r);
      return i instanceof Promise ? i.then((a) => Kt(a, t, r)) : Kt(i, t, r);
    } else {
      let i = t.out._zod.run(n, r);
      return i instanceof Promise ? i.then((a) => Kt(a, t, r)) : Kt(i, t, r);
    }
  };
});
function Kt(e, t, n) {
  if (e.issues.length) return e.aborted = !0, e;
  if ((n.direction || "forward") === "forward") {
    let r = t.transform(e.value, e);
    return r instanceof Promise ? r.then((i) => Vt(e, i, t.out, n)) : Vt(e, r, t.out, n);
  } else {
    let r = t.reverseTransform(e.value, e);
    return r instanceof Promise ? r.then((i) => Vt(e, i, t.in, n)) : Vt(e, r, t.in, n);
  }
}
function Vt(e, t, n, r) {
  return e.issues.length ? (e.aborted = !0, e) : n._zod.run({ value: t, issues: e.issues }, r);
}
var Pl = m("$ZodReadonly", (e, t) => {
  S.init(e, t), O(e._zod, "propValues", () => t.innerType._zod.propValues), O(e._zod, "values", () => t.innerType._zod.values), O(e._zod, "optin", () => t.innerType?._zod?.optin), O(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (n, r) => {
    if (r.direction === "backward") return t.innerType._zod.run(n, r);
    let i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then(eo) : eo(i);
  };
});
function eo(e) {
  return e.value = Object.freeze(e.value), e;
}
var Nl = m("$ZodTemplateLiteral", (e, t) => {
  S.init(e, t);
  let n = [];
  for (let r of t.parts) if (typeof r == "object" && r !== null) {
    if (!r._zod.pattern) throw Error(`Invalid template literal part, no pattern found: ${[...r._zod.traits].shift()}`);
    let i = r._zod.pattern instanceof RegExp ? r._zod.pattern.source : r._zod.pattern;
    if (!i) throw Error(`Invalid template literal part: ${r._zod.traits}`);
    let a = i.startsWith("^") ? 1 : 0, o = i.endsWith("$") ? i.length - 1 : i.length;
    n.push(i.slice(a, o));
  } else if (r === null || ps.has(typeof r)) n.push(be(`${r}`));
  else throw Error(`Invalid template literal part: ${r}`);
  e._zod.pattern = new RegExp(`^${n.join("")}$`), e._zod.parse = (r, i) => typeof r.value != "string" ? (r.issues.push({ input: r.value, inst: e, expected: "template_literal", code: "invalid_type" }), r) : (e._zod.pattern.lastIndex = 0, e._zod.pattern.test(r.value) || r.issues.push({ input: r.value, inst: e, code: "invalid_format", format: t.format ?? "template_literal", pattern: e._zod.pattern.source }), r);
}), Zl = m("$ZodFunction", (e, t) => (S.init(e, t), e._def = t, e._zod.def = t, e.implement = (n) => {
  if (typeof n != "function") throw Error("implement() must be called with a function");
  return function(...r) {
    let i = e._def.input ? pn(e._def.input, r) : r, a = Reflect.apply(n, this, i);
    return e._def.output ? pn(e._def.output, a) : a;
  };
}, e.implementAsync = (n) => {
  if (typeof n != "function") throw Error("implementAsync() must be called with a function");
  return async function(...r) {
    let i = e._def.input ? await fn(e._def.input, r) : r, a = await Reflect.apply(n, this, i);
    return e._def.output ? await fn(e._def.output, a) : a;
  };
}, e._zod.parse = (n, r) => typeof n.value != "function" ? (n.issues.push({ code: "invalid_type", expected: "function", input: n.value, inst: e }), n) : (e._def.output && e._def.output._zod.def.type === "promise" ? n.value = e.implementAsync(n.value) : n.value = e.implement(n.value), n), e.input = (...n) => {
  let r = e.constructor;
  return Array.isArray(n[0]) ? new r({ type: "function", input: new Yn({ type: "tuple", items: n[0], rest: n[1] }), output: e._def.output }) : new r({ type: "function", input: n[0], output: e._def.output });
}, e.output = (n) => new e.constructor({ type: "function", input: e._def.input, output: n }), e)), Dl = m("$ZodPromise", (e, t) => {
  S.init(e, t), e._zod.parse = (n, r) => Promise.resolve(n.value).then((i) => t.innerType._zod.run({ value: i, issues: [] }, r));
}), El = m("$ZodLazy", (e, t) => {
  S.init(e, t), O(e._zod, "innerType", () => t.getter()), O(e._zod, "pattern", () => e._zod.innerType?._zod?.pattern), O(e._zod, "propValues", () => e._zod.innerType?._zod?.propValues), O(e._zod, "optin", () => e._zod.innerType?._zod?.optin ?? void 0), O(e._zod, "optout", () => e._zod.innerType?._zod?.optout ?? void 0), e._zod.parse = (n, r) => e._zod.innerType._zod.run(n, r);
}), Al = m("$ZodCustom", (e, t) => {
  F.init(e, t), S.init(e, t), e._zod.parse = (n, r) => n, e._zod.check = (n) => {
    let r = n.value, i = t.fn(r);
    if (i instanceof Promise) return i.then((a) => to(a, n, r, e));
    to(i, n, r, e);
  };
});
function to(e, t, n, r) {
  if (!e) {
    let i = { code: "custom", input: n, inst: r, path: [...r._zod.def.path ?? []], continue: !r._zod.def.abort };
    r._zod.def.params && (i.params = r._zod.def.params), t.issues.push(ei(i));
  }
}
var er = {};
_e(er, { zhTW: () => j$, zhCN: () => O$, yo: () => N$, vi: () => z$, ur: () => w$, uk: () => Cl, ua: () => I$, tr: () => y$, th: () => v$, ta: () => g$, sv: () => p$, sl: () => d$, ru: () => l$, pt: () => s$, ps: () => n$, pl: () => a$, ota: () => t$, no: () => Qy, nl: () => Xy, ms: () => By, mk: () => Vy, lt: () => Wy, ko: () => Fy, km: () => Rl, kh: () => My, ka: () => Ry, ja: () => Ey, it: () => Zy, is: () => Py, id: () => Oy, hu: () => zy, he: () => wy, frCA: () => Iy, fr: () => yy, fi: () => by, fa: () => hy, es: () => fy, eo: () => my, en: () => Tl, de: () => sy, da: () => ay, cs: () => ny, ca: () => ty, bg: () => Q_, be: () => H_, az: () => G_, ar: () => K_ });
var W_ = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: " ", url: "", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: "  ISO", time: "  ISO", duration: "  ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: "   IPv4", cidrv6: "   IPv6", base64: "  base64-encoded", base64url: "  base64url-encoded", json_string: "   JSON", e164: "   E.164", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `  :   ${i.expected}    ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `  :   ${w(i.values[0])}` : `  :     : ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `   :    ${i.origin ?? ""} ${a} ${i.maximum.toString()} ${o.unit ?? ""}` : `  :    ${i.origin ?? ""} ${a} ${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `  :   ${i.origin}   ${a} ${i.minimum.toString()} ${o.unit}` : `  :   ${i.origin}   ${a} ${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `  :     "${i.prefix}"` : a.format === "ends_with" ? `  :     "${a.suffix}"` : a.format === "includes" ? `  :    "${a.includes}"` : a.format === "regex" ? `  :     ${a.pattern}` : `${r[a.format] ?? i.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${i.divisor}`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "" : ""} ${i.keys.length > 1 ? "" : ""}: ${v(i.keys, " ")}`;
      case "invalid_key":
        return `    ${i.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${i.origin}`;
      default:
        return "  ";
    }
  };
};
function K_() {
  return { localeError: W_() };
}
var V_ = () => {
  let e = { string: { unit: "simvol", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "element", verb: "olmaldr" }, set: { unit: "element", verb: "olmaldr" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Yanl dyr: gzlniln ${i.expected}, daxil olan ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Yanl dyr: gzlniln ${w(i.values[0])}` : `Yanl seim: aadaklardan biri olmaldr: ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `ox byk: gzlniln ${i.origin ?? "dyr"} ${a}${i.maximum.toString()} ${o.unit ?? "element"}` : `ox byk: gzlniln ${i.origin ?? "dyr"} ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `ox kiik: gzlniln ${i.origin} ${a}${i.minimum.toString()} ${o.unit}` : `ox kiik: gzlniln ${i.origin} ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Yanl mtn: "${a.prefix}" il balamaldr` : a.format === "ends_with" ? `Yanl mtn: "${a.suffix}" il bitmlidir` : a.format === "includes" ? `Yanl mtn: "${a.includes}" daxil olmaldr` : a.format === "regex" ? `Yanl mtn: ${a.pattern} ablonuna uyun olmaldr` : `Yanl ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${i.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${i.keys.length > 1 ? "lar" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${i.origin} daxilind yanl dyr`;
      default:
        return "Yanl dyr";
    }
  };
};
function G_() {
  return { localeError: V_() };
}
function io(e, t, n, r) {
  let i = Math.abs(e), a = i % 10, o = i % 100;
  return o >= 11 && o <= 19 ? r : a === 1 ? t : a >= 2 && a <= 4 ? n : r;
}
var B_ = () => {
  let e = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return ` :  ${i.expected},  ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? ` :  ${w(i.values[0])}` : ` :    ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        if (o) {
          let s = Number(i.maximum), l = io(s, o.unit.one, o.unit.few, o.unit.many);
          return ` : ,  ${i.origin ?? ""}  ${o.verb} ${a}${i.maximum.toString()} ${l}`;
        }
        return ` : ,  ${i.origin ?? ""}   ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        if (o) {
          let s = Number(i.minimum), l = io(s, o.unit.one, o.unit.few, o.unit.many);
          return ` : ,  ${i.origin}  ${o.verb} ${a}${i.minimum.toString()} ${l}`;
        }
        return ` : ,  ${i.origin}   ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` :    "${a.prefix}"` : a.format === "ends_with" ? ` :    "${a.suffix}"` : a.format === "includes" ? ` :   "${a.includes}"` : a.format === "regex" ? ` :    ${a.pattern}` : ` ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return ` :    ${i.divisor}`;
      case "unrecognized_keys":
        return ` ${i.keys.length > 1 ? "" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `   ${i.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${i.origin}`;
      default:
        return " ";
    }
  };
};
function H_() {
  return { localeError: B_() };
}
var X_ = (e) => {
  let t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "";
    case "object": {
      if (Array.isArray(e)) return "";
      if (e === null) return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name;
    }
  }
  return t;
}, Y_ = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(r) {
    return e[r] ?? null;
  }
  let n = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` :  ${r.expected},  ${X_(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? ` :  ${w(r.values[0])}` : ` :    ${v(r.values, "|")}`;
      case "too_big": {
        let i = r.inclusive ? "<=" : "<", a = t(r.origin);
        return a ? ` :   ${r.origin ?? ""}   ${i}${r.maximum.toString()} ${a.unit ?? ""}` : ` :   ${r.origin ?? ""}   ${i}${r.maximum.toString()}`;
      }
      case "too_small": {
        let i = r.inclusive ? ">=" : ">", a = t(r.origin);
        return a ? ` :   ${r.origin}   ${i}${r.minimum.toString()} ${a.unit}` : ` :   ${r.origin}   ${i}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        let i = r;
        if (i.format === "starts_with") return ` :     "${i.prefix}"`;
        if (i.format === "ends_with") return ` :     "${i.suffix}"`;
        if (i.format === "includes") return ` :    "${i.includes}"`;
        if (i.format === "regex") return ` :     ${i.pattern}`;
        let a = "";
        return i.format === "emoji" && (a = ""), i.format === "datetime" && (a = ""), i.format === "date" && (a = ""), i.format === "time" && (a = ""), i.format === "duration" && (a = ""), `${a} ${n[i.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` :      ${r.divisor}`;
      case "unrecognized_keys":
        return `${r.keys.length > 1 ? "" : ""} ${r.keys.length > 1 ? "" : ""}: ${v(r.keys, ", ")}`;
      case "invalid_key":
        return `   ${r.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${r.origin}`;
      default:
        return " ";
    }
  };
};
function Q_() {
  return { localeError: Y_() };
}
var ey = () => {
  let e = { string: { unit: "carcters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "entrada", email: "adrea electrnica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adrea IPv4", ipv6: "adrea IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Tipus invlid: s'esperava ${i.expected}, s'ha rebut ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Valor invlid: s'esperava ${w(i.values[0])}` : `Opci invlida: s'esperava una de ${v(i.values, " o ")}`;
      case "too_big": {
        let a = i.inclusive ? "com a mxim" : "menys de", o = t(i.origin);
        return o ? `Massa gran: s'esperava que ${i.origin ?? "el valor"} contingus ${a} ${i.maximum.toString()} ${o.unit ?? "elements"}` : `Massa gran: s'esperava que ${i.origin ?? "el valor"} fos ${a} ${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? "com a mnim" : "ms de", o = t(i.origin);
        return o ? `Massa petit: s'esperava que ${i.origin} contingus ${a} ${i.minimum.toString()} ${o.unit}` : `Massa petit: s'esperava que ${i.origin} fos ${a} ${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Format invlid: ha de comenar amb "${a.prefix}"` : a.format === "ends_with" ? `Format invlid: ha d'acabar amb "${a.suffix}"` : a.format === "includes" ? `Format invlid: ha d'incloure "${a.includes}"` : a.format === "regex" ? `Format invlid: ha de coincidir amb el patr ${a.pattern}` : `Format invlid per a ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${i.divisor}`;
      case "unrecognized_keys":
        return `Clau${i.keys.length > 1 ? "s" : ""} no reconeguda${i.keys.length > 1 ? "s" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${i.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${i.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function ty() {
  return { localeError: ey() };
}
var iy = () => {
  let e = { string: { unit: "znak", verb: "mt" }, file: { unit: "bajt", verb: "mt" }, array: { unit: "prvk", verb: "mt" }, set: { unit: "prvk", verb: "mt" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "slo";
      case "string":
        return "etzec";
      case "boolean":
        return "boolean";
      case "bigint":
        return "bigint";
      case "function":
        return "funkce";
      case "symbol":
        return "symbol";
      case "undefined":
        return "undefined";
      case "object": {
        if (Array.isArray(i)) return "pole";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "regulrn vraz", email: "e-mailov adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a as ve formtu ISO", date: "datum ve formtu ISO", time: "as ve formtu ISO", duration: "doba trvn ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "etzec zakdovan ve formtu base64", base64url: "etzec zakdovan ve formtu base64url", json_string: "etzec ve formtu JSON", e164: "slo E.164", jwt: "JWT", template_literal: "vstup" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Neplatn vstup: oekvno ${i.expected}, obdreno ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Neplatn vstup: oekvno ${w(i.values[0])}` : `Neplatn monost: oekvna jedna z hodnot ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Hodnota je pli velk: ${i.origin ?? "hodnota"} mus mt ${a}${i.maximum.toString()} ${o.unit ?? "prvk"}` : `Hodnota je pli velk: ${i.origin ?? "hodnota"} mus bt ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Hodnota je pli mal: ${i.origin ?? "hodnota"} mus mt ${a}${i.minimum.toString()} ${o.unit ?? "prvk"}` : `Hodnota je pli mal: ${i.origin ?? "hodnota"} mus bt ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Neplatn etzec: mus zanat na "${a.prefix}"` : a.format === "ends_with" ? `Neplatn etzec: mus konit na "${a.suffix}"` : a.format === "includes" ? `Neplatn etzec: mus obsahovat "${a.includes}"` : a.format === "regex" ? `Neplatn etzec: mus odpovdat vzoru ${a.pattern}` : `Neplatn formt ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${i.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${i.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${i.origin}`;
      default:
        return "Neplatn vstup";
    }
  };
};
function ny() {
  return { localeError: iy() };
}
var ry = () => {
  let e = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } }, t = { string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "st", file: "fil" };
  function n(o) {
    return e[o] ?? null;
  }
  function r(o) {
    return t[o] ?? o;
  }
  let i = (o) => {
    let s = typeof o;
    switch (s) {
      case "number":
        return Number.isNaN(o) ? "NaN" : "tal";
      case "object":
        return Array.isArray(o) ? "liste" : o === null ? "null" : Object.getPrototypeOf(o) !== Object.prototype && o.constructor ? o.constructor.name : "objekt";
    }
    return s;
  }, a = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslt", date: "ISO-dato", time: "ISO-klokkeslt", duration: "ISO-varighed", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" };
  return (o) => {
    switch (o.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${r(o.expected)}, fik ${r(i(o.input))}`;
      case "invalid_value":
        return o.values.length === 1 ? `Ugyldig vrdi: forventede ${w(o.values[0])}` : `Ugyldigt valg: forventede en af flgende ${v(o.values, "|")}`;
      case "too_big": {
        let s = o.inclusive ? "<=" : "<", l = n(o.origin), u = r(o.origin);
        return l ? `For stor: forventede ${u ?? "value"} ${l.verb} ${s} ${o.maximum.toString()} ${l.unit ?? "elementer"}` : `For stor: forventede ${u ?? "value"} havde ${s} ${o.maximum.toString()}`;
      }
      case "too_small": {
        let s = o.inclusive ? ">=" : ">", l = n(o.origin), u = r(o.origin);
        return l ? `For lille: forventede ${u} ${l.verb} ${s} ${o.minimum.toString()} ${l.unit}` : `For lille: forventede ${u} havde ${s} ${o.minimum.toString()}`;
      }
      case "invalid_format": {
        let s = o;
        return s.format === "starts_with" ? `Ugyldig streng: skal starte med "${s.prefix}"` : s.format === "ends_with" ? `Ugyldig streng: skal ende med "${s.suffix}"` : s.format === "includes" ? `Ugyldig streng: skal indeholde "${s.includes}"` : s.format === "regex" ? `Ugyldig streng: skal matche mnsteret ${s.pattern}` : `Ugyldig ${a[s.format] ?? o.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${o.divisor}`;
      case "unrecognized_keys":
        return `${o.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${v(o.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${o.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${o.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function ay() {
  return { localeError: ry() };
}
var oy = () => {
  let e = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "Zahl";
      case "object": {
        if (Array.isArray(i)) return "Array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Ungltige Eingabe: erwartet ${i.expected}, erhalten ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Ungltige Eingabe: erwartet ${w(i.values[0])}` : `Ungltige Option: erwartet eine von ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Zu gro: erwartet, dass ${i.origin ?? "Wert"} ${a}${i.maximum.toString()} ${o.unit ?? "Elemente"} hat` : `Zu gro: erwartet, dass ${i.origin ?? "Wert"} ${a}${i.maximum.toString()} ist`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Zu klein: erwartet, dass ${i.origin} ${a}${i.minimum.toString()} ${o.unit} hat` : `Zu klein: erwartet, dass ${i.origin} ${a}${i.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Ungltiger String: muss mit "${a.prefix}" beginnen` : a.format === "ends_with" ? `Ungltiger String: muss mit "${a.suffix}" enden` : a.format === "includes" ? `Ungltiger String: muss "${a.includes}" enthalten` : a.format === "regex" ? `Ungltiger String: muss dem Muster ${a.pattern} entsprechen` : `Ungltig: ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${i.divisor} sein`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${i.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${i.origin}`;
      default:
        return "Ungltige Eingabe";
    }
  };
};
function sy() {
  return { localeError: oy() };
}
var uy = (e) => {
  let t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(e)) return "array";
      if (e === null) return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name;
    }
  }
  return t;
}, ly = () => {
  let e = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } };
  function t(r) {
    return e[r] ?? null;
  }
  let n = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", mac: "MAC address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Invalid input: expected ${r.expected}, received ${uy(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Invalid input: expected ${w(r.values[0])}` : `Invalid option: expected one of ${v(r.values, "|")}`;
      case "too_big": {
        let i = r.inclusive ? "<=" : "<", a = t(r.origin);
        return a ? `Too big: expected ${r.origin ?? "value"} to have ${i}${r.maximum.toString()} ${a.unit ?? "elements"}` : `Too big: expected ${r.origin ?? "value"} to be ${i}${r.maximum.toString()}`;
      }
      case "too_small": {
        let i = r.inclusive ? ">=" : ">", a = t(r.origin);
        return a ? `Too small: expected ${r.origin} to have ${i}${r.minimum.toString()} ${a.unit}` : `Too small: expected ${r.origin} to be ${i}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        let i = r;
        return i.format === "starts_with" ? `Invalid string: must start with "${i.prefix}"` : i.format === "ends_with" ? `Invalid string: must end with "${i.suffix}"` : i.format === "includes" ? `Invalid string: must include "${i.includes}"` : i.format === "regex" ? `Invalid string: must match pattern ${i.pattern}` : `Invalid ${n[i.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${r.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${r.keys.length > 1 ? "s" : ""}: ${v(r.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${r.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${r.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function Tl() {
  return { localeError: ly() };
}
var cy = (e) => {
  let t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "nombro";
    case "object": {
      if (Array.isArray(e)) return "tabelo";
      if (e === null) return "senvalora";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name;
    }
  }
  return t;
}, dy = () => {
  let e = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } };
  function t(r) {
    return e[r] ?? null;
  }
  let n = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiis ${r.expected}, riceviis ${cy(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Nevalida enigo: atendiis ${w(r.values[0])}` : `Nevalida opcio: atendiis unu el ${v(r.values, "|")}`;
      case "too_big": {
        let i = r.inclusive ? "<=" : "<", a = t(r.origin);
        return a ? `Tro granda: atendiis ke ${r.origin ?? "valoro"} havu ${i}${r.maximum.toString()} ${a.unit ?? "elementojn"}` : `Tro granda: atendiis ke ${r.origin ?? "valoro"} havu ${i}${r.maximum.toString()}`;
      }
      case "too_small": {
        let i = r.inclusive ? ">=" : ">", a = t(r.origin);
        return a ? `Tro malgranda: atendiis ke ${r.origin} havu ${i}${r.minimum.toString()} ${a.unit}` : `Tro malgranda: atendiis ke ${r.origin} estu ${i}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        let i = r;
        return i.format === "starts_with" ? `Nevalida karaktraro: devas komencii per "${i.prefix}"` : i.format === "ends_with" ? `Nevalida karaktraro: devas finii per "${i.suffix}"` : i.format === "includes" ? `Nevalida karaktraro: devas inkluzivi "${i.includes}"` : i.format === "regex" ? `Nevalida karaktraro: devas kongrui kun la modelo ${i.pattern}` : `Nevalida ${n[i.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${r.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${r.keys.length > 1 ? "j" : ""} losilo${r.keys.length > 1 ? "j" : ""}: ${v(r.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${r.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${r.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function my() {
  return { localeError: dy() };
}
var py = () => {
  let e = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } }, t = { string: "texto", number: "nmero", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "nmero grande", symbol: "smbolo", undefined: "indefinido", null: "nulo", function: "funcin", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeracin", union: "unin", literal: "literal", promise: "promesa", void: "vaco", never: "nunca", unknown: "desconocido", any: "cualquiera" };
  function n(o) {
    return e[o] ?? null;
  }
  function r(o) {
    return t[o] ?? o;
  }
  let i = (o) => {
    let s = typeof o;
    switch (s) {
      case "number":
        return Number.isNaN(o) ? "NaN" : "number";
      case "object":
        return Array.isArray(o) ? "array" : o === null ? "null" : Object.getPrototypeOf(o) !== Object.prototype ? o.constructor.name : "object";
    }
    return s;
  }, a = { regex: "entrada", email: "direccin de correo electrnico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duracin ISO", ipv4: "direccin IPv4", ipv6: "direccin IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" };
  return (o) => {
    switch (o.code) {
      case "invalid_type":
        return `Entrada invlida: se esperaba ${r(o.expected)}, recibido ${r(i(o.input))}`;
      case "invalid_value":
        return o.values.length === 1 ? `Entrada invlida: se esperaba ${w(o.values[0])}` : `Opcin invlida: se esperaba una de ${v(o.values, "|")}`;
      case "too_big": {
        let s = o.inclusive ? "<=" : "<", l = n(o.origin), u = r(o.origin);
        return l ? `Demasiado grande: se esperaba que ${u ?? "valor"} tuviera ${s}${o.maximum.toString()} ${l.unit ?? "elementos"}` : `Demasiado grande: se esperaba que ${u ?? "valor"} fuera ${s}${o.maximum.toString()}`;
      }
      case "too_small": {
        let s = o.inclusive ? ">=" : ">", l = n(o.origin), u = r(o.origin);
        return l ? `Demasiado pequeo: se esperaba que ${u} tuviera ${s}${o.minimum.toString()} ${l.unit}` : `Demasiado pequeo: se esperaba que ${u} fuera ${s}${o.minimum.toString()}`;
      }
      case "invalid_format": {
        let s = o;
        return s.format === "starts_with" ? `Cadena invlida: debe comenzar con "${s.prefix}"` : s.format === "ends_with" ? `Cadena invlida: debe terminar en "${s.suffix}"` : s.format === "includes" ? `Cadena invlida: debe incluir "${s.includes}"` : s.format === "regex" ? `Cadena invlida: debe coincidir con el patrn ${s.pattern}` : `Invlido ${a[s.format] ?? o.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${o.divisor}`;
      case "unrecognized_keys":
        return `Llave${o.keys.length > 1 ? "s" : ""} desconocida${o.keys.length > 1 ? "s" : ""}: ${v(o.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${r(o.origin)}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${r(o.origin)}`;
      default:
        return "Entrada invlida";
    }
  };
};
function fy() {
  return { localeError: py() };
}
var gy = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ", date: " ", time: " ", duration: "  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return ` :  ${i.expected}  ${n(i.input)}  `;
      case "invalid_value":
        return i.values.length === 1 ? ` :  ${w(i.values[0])} ` : ` :    ${v(i.values, "|")} `;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? ` : ${i.origin ?? ""}  ${a}${i.maximum.toString()} ${o.unit ?? ""} ` : ` : ${i.origin ?? ""}  ${a}${i.maximum.toString()} `;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? ` : ${i.origin}  ${a}${i.minimum.toString()} ${o.unit} ` : ` : ${i.origin}  ${a}${i.minimum.toString()} `;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` :   "${a.prefix}"  ` : a.format === "ends_with" ? ` :   "${a.suffix}"  ` : a.format === "includes" ? ` :   "${a.includes}" ` : a.format === "regex" ? ` :    ${a.pattern}   ` : `${r[a.format] ?? i.format} `;
      }
      case "not_multiple_of":
        return ` :   ${i.divisor} `;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "" : ""} : ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `   ${i.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${i.origin}`;
      default:
        return " ";
    }
  };
};
function hy() {
  return { localeError: gy() };
}
var vy = () => {
  let e = { string: { unit: "merkki", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "pivmrn" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "snnllinen lauseke", email: "shkpostiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-pivmr", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${i.expected}, oli ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Virheellinen syte: tytyy olla ${w(i.values[0])}` : `Virheellinen valinta: tytyy olla yksi seuraavista: ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Liian suuri: ${o.subject} tytyy olla ${a}${i.maximum.toString()} ${o.unit}`.trim() : `Liian suuri: arvon tytyy olla ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Liian pieni: ${o.subject} tytyy olla ${a}${i.minimum.toString()} ${o.unit}`.trim() : `Liian pieni: arvon tytyy olla ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Virheellinen syte: tytyy alkaa "${a.prefix}"` : a.format === "ends_with" ? `Virheellinen syte: tytyy loppua "${a.suffix}"` : a.format === "includes" ? `Virheellinen syte: tytyy sislt "${a.includes}"` : a.format === "regex" ? `Virheellinen syte: tytyy vastata snnllist lauseketta ${a.pattern}` : `Virheellinen ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${i.divisor} monikerta`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syte";
    }
  };
};
function by() {
  return { localeError: vy() };
}
var _y = () => {
  let e = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "nombre";
      case "object": {
        if (Array.isArray(i)) return "tableau";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "entre", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Entre invalide : ${i.expected} attendu, ${n(i.input)} reu`;
      case "invalid_value":
        return i.values.length === 1 ? `Entre invalide : ${w(i.values[0])} attendu` : `Option invalide : une valeur parmi ${v(i.values, "|")} attendue`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Trop grand : ${i.origin ?? "valeur"} doit ${o.verb} ${a}${i.maximum.toString()} ${o.unit ?? "lment(s)"}` : `Trop grand : ${i.origin ?? "valeur"} doit tre ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Trop petit : ${i.origin} doit ${o.verb} ${a}${i.minimum.toString()} ${o.unit}` : `Trop petit : ${i.origin} doit tre ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Chane invalide : doit commencer par "${a.prefix}"` : a.format === "ends_with" ? `Chane invalide : doit se terminer par "${a.suffix}"` : a.format === "includes" ? `Chane invalide : doit inclure "${a.includes}"` : a.format === "regex" ? `Chane invalide : doit correspondre au modle ${a.pattern}` : `${r[a.format] ?? i.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${i.divisor}`;
      case "unrecognized_keys":
        return `Cl${i.keys.length > 1 ? "s" : ""} non reconnue${i.keys.length > 1 ? "s" : ""} : ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${i.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${i.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function yy() {
  return { localeError: _y() };
}
var $y = () => {
  let e = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "entre", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Entre invalide : attendu ${i.expected}, reu ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Entre invalide : attendu ${w(i.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "" : "<", o = t(i.origin);
        return o ? `Trop grand : attendu que ${i.origin ?? "la valeur"} ait ${a}${i.maximum.toString()} ${o.unit}` : `Trop grand : attendu que ${i.origin ?? "la valeur"} soit ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? "" : ">", o = t(i.origin);
        return o ? `Trop petit : attendu que ${i.origin} ait ${a}${i.minimum.toString()} ${o.unit}` : `Trop petit : attendu que ${i.origin} soit ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Chane invalide : doit commencer par "${a.prefix}"` : a.format === "ends_with" ? `Chane invalide : doit se terminer par "${a.suffix}"` : a.format === "includes" ? `Chane invalide : doit inclure "${a.includes}"` : a.format === "regex" ? `Chane invalide : doit correspondre au motif ${a.pattern}` : `${r[a.format] ?? i.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${i.divisor}`;
      case "unrecognized_keys":
        return `Cl${i.keys.length > 1 ? "s" : ""} non reconnue${i.keys.length > 1 ? "s" : ""} : ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${i.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${i.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function Iy() {
  return { localeError: $y() };
}
var ky = () => {
  let e = { string: { label: "", gender: "f" }, number: { label: "", gender: "m" }, boolean: { label: " ", gender: "m" }, bigint: { label: "BigInt", gender: "m" }, date: { label: "", gender: "m" }, array: { label: "", gender: "m" }, object: { label: "", gender: "m" }, null: { label: "  (null)", gender: "m" }, undefined: { label: "   (undefined)", gender: "m" }, symbol: { label: " (Symbol)", gender: "m" }, function: { label: "", gender: "f" }, map: { label: " (Map)", gender: "f" }, set: { label: " (Set)", gender: "f" }, file: { label: "", gender: "m" }, promise: { label: "Promise", gender: "m" }, NaN: { label: "NaN", gender: "m" }, unknown: { label: "  ", gender: "m" }, value: { label: "", gender: "m" } }, t = { string: { unit: "", shortLabel: "", longLabel: "" }, file: { unit: "", shortLabel: "", longLabel: "" }, array: { unit: "", shortLabel: "", longLabel: "" }, set: { unit: "", shortLabel: "", longLabel: "" }, number: { unit: "", shortLabel: "", longLabel: "" } }, n = (u) => u ? e[u] : void 0, r = (u) => {
    let d = n(u);
    return d ? d.label : u ?? e.unknown.label;
  }, i = (u) => `${r(u)}`, a = (u) => (n(u)?.gender ?? "m") === "f" ? " " : " ", o = (u) => u ? t[u] ?? null : null, s = (u) => {
    let d = typeof u;
    switch (d) {
      case "number":
        return Number.isNaN(u) ? "NaN" : "number";
      case "object":
        return Array.isArray(u) ? "array" : u === null ? "null" : Object.getPrototypeOf(u) !== Object.prototype && u.constructor ? u.constructor.name : "object";
      default:
        return d;
    }
  }, l = { regex: { label: "", gender: "m" }, email: { label: " ", gender: "f" }, url: { label: " ", gender: "f" }, emoji: { label: "'", gender: "m" }, uuid: { label: "UUID", gender: "m" }, nanoid: { label: "nanoid", gender: "m" }, guid: { label: "GUID", gender: "m" }, cuid: { label: "cuid", gender: "m" }, cuid2: { label: "cuid2", gender: "m" }, ulid: { label: "ULID", gender: "m" }, xid: { label: "XID", gender: "m" }, ksuid: { label: "KSUID", gender: "m" }, datetime: { label: "  ISO", gender: "m" }, date: { label: " ISO", gender: "m" }, time: { label: " ISO", gender: "m" }, duration: { label: "  ISO", gender: "m" }, ipv4: { label: " IPv4", gender: "f" }, ipv6: { label: " IPv6", gender: "f" }, cidrv4: { label: " IPv4", gender: "m" }, cidrv6: { label: " IPv6", gender: "m" }, base64: { label: "  64", gender: "f" }, base64url: { label: "  64  ", gender: "f" }, json_string: { label: " JSON", gender: "f" }, e164: { label: " E.164", gender: "m" }, jwt: { label: "JWT", gender: "m" }, ends_with: { label: "", gender: "m" }, includes: { label: "", gender: "m" }, lowercase: { label: "", gender: "m" }, starts_with: { label: "", gender: "m" }, uppercase: { label: "", gender: "m" } };
  return (u) => {
    switch (u.code) {
      case "invalid_type": {
        let d = u.expected, f = r(d), h = s(u.input), $ = e[h]?.label ?? h;
        return `  :   ${f},  ${$}`;
      }
      case "invalid_value": {
        if (u.values.length === 1) return `  :    ${w(u.values[0])}`;
        let d = u.values.map((h) => w(h));
        if (u.values.length === 2) return `  :    ${d[0]}  ${d[1]}`;
        let f = d[d.length - 1];
        return `  :    ${d.slice(0, -1).join(", ")}  ${f}`;
      }
      case "too_big": {
        let d = o(u.origin), f = i(u.origin ?? "value");
        if (u.origin === "string") return `${d?.longLabel ?? ""} : ${f}   ${u.maximum.toString()} ${d?.unit ?? ""} ${u.inclusive ? " " : " "}`.trim();
        if (u.origin === "number") {
          let P = u.inclusive ? `   -${u.maximum}` : ` -${u.maximum}`;
          return ` : ${f}   ${P}`;
        }
        if (u.origin === "array" || u.origin === "set") {
          let P = u.origin === "set" ? "" : "", ee = u.inclusive ? `${u.maximum} ${d?.unit ?? ""}  ` : ` -${u.maximum} ${d?.unit ?? ""}`;
          return ` : ${f} ${P}  ${ee}`.trim();
        }
        let h = u.inclusive ? "<=" : "<", $ = a(u.origin ?? "value");
        return d?.unit ? `${d.longLabel} : ${f} ${$} ${h}${u.maximum.toString()} ${d.unit}` : `${d?.longLabel ?? ""} : ${f} ${$} ${h}${u.maximum.toString()}`;
      }
      case "too_small": {
        let d = o(u.origin), f = i(u.origin ?? "value");
        if (u.origin === "string") return `${d?.shortLabel ?? ""} : ${f}   ${u.minimum.toString()} ${d?.unit ?? ""} ${u.inclusive ? " " : ""}`.trim();
        if (u.origin === "number") {
          let P = u.inclusive ? `   -${u.minimum}` : ` -${u.minimum}`;
          return ` : ${f}   ${P}`;
        }
        if (u.origin === "array" || u.origin === "set") {
          let P = u.origin === "set" ? "" : "";
          if (u.minimum === 1 && u.inclusive) {
            let ve = (u.origin === "set", "  ");
            return ` : ${f} ${P}  ${ve}`;
          }
          let ee = u.inclusive ? `${u.minimum} ${d?.unit ?? ""}  ` : ` -${u.minimum} ${d?.unit ?? ""}`;
          return ` : ${f} ${P}  ${ee}`.trim();
        }
        let h = u.inclusive ? ">=" : ">", $ = a(u.origin ?? "value");
        return d?.unit ? `${d.shortLabel} : ${f} ${$} ${h}${u.minimum.toString()} ${d.unit}` : `${d?.shortLabel ?? ""} : ${f} ${$} ${h}${u.minimum.toString()}`;
      }
      case "invalid_format": {
        let d = u;
        if (d.format === "starts_with") return `    "${d.prefix}"`;
        if (d.format === "ends_with") return `    "${d.suffix}"`;
        if (d.format === "includes") return `   "${d.includes}"`;
        if (d.format === "regex") return `    ${d.pattern}`;
        let f = l[d.format], h = f?.label ?? d.format, $ = (f?.gender ?? "m") === "f" ? "" : "";
        return `${h}  ${$}`;
      }
      case "not_multiple_of":
        return `  :     ${u.divisor}`;
      case "unrecognized_keys":
        return `${u.keys.length > 1 ? "" : ""}  ${u.keys.length > 1 ? "" : ""}: ${v(u.keys, ", ")}`;
      case "invalid_key":
        return "   ";
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${i(u.origin ?? "array")}`;
      default:
        return "  ";
    }
  };
};
function wy() {
  return { localeError: ky() };
}
var Sy = () => {
  let e = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "szm";
      case "object": {
        if (Array.isArray(i)) return "tmb";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "bemenet", email: "email cm", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO idblyeg", date: "ISO dtum", time: "ISO id", duration: "ISO idintervallum", ipv4: "IPv4 cm", ipv6: "IPv6 cm", cidrv4: "IPv4 tartomny", cidrv6: "IPv6 tartomny", base64: "base64-kdolt string", base64url: "base64url-kdolt string", json_string: "JSON string", e164: "E.164 szm", jwt: "JWT", template_literal: "bemenet" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `rvnytelen bemenet: a vrt rtk ${i.expected}, a kapott rtk ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `rvnytelen bemenet: a vrt rtk ${w(i.values[0])}` : `rvnytelen opci: valamelyik rtk vrt ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Tl nagy: ${i.origin ?? "rtk"} mrete tl nagy ${a}${i.maximum.toString()} ${o.unit ?? "elem"}` : `Tl nagy: a bemeneti rtk ${i.origin ?? "rtk"} tl nagy: ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Tl kicsi: a bemeneti rtk ${i.origin} mrete tl kicsi ${a}${i.minimum.toString()} ${o.unit}` : `Tl kicsi: a bemeneti rtk ${i.origin} tl kicsi ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `rvnytelen string: "${a.prefix}" rtkkel kell kezddnie` : a.format === "ends_with" ? `rvnytelen string: "${a.suffix}" rtkkel kell vgzdnie` : a.format === "includes" ? `rvnytelen string: "${a.includes}" rtket kell tartalmaznia` : a.format === "regex" ? `rvnytelen string: ${a.pattern} mintnak kell megfelelnie` : `rvnytelen ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${i.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${i.keys.length > 1 ? "s" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${i.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${i.origin}`;
      default:
        return "rvnytelen bemenet";
    }
  };
};
function zy() {
  return { localeError: Sy() };
}
var xy = () => {
  let e = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${i.expected}, diterima ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Input tidak valid: diharapkan ${w(i.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Terlalu besar: diharapkan ${i.origin ?? "value"} memiliki ${a}${i.maximum.toString()} ${o.unit ?? "elemen"}` : `Terlalu besar: diharapkan ${i.origin ?? "value"} menjadi ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Terlalu kecil: diharapkan ${i.origin} memiliki ${a}${i.minimum.toString()} ${o.unit}` : `Terlalu kecil: diharapkan ${i.origin} menjadi ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `String tidak valid: harus dimulai dengan "${a.prefix}"` : a.format === "ends_with" ? `String tidak valid: harus berakhir dengan "${a.suffix}"` : a.format === "includes" ? `String tidak valid: harus menyertakan "${a.includes}"` : a.format === "regex" ? `String tidak valid: harus sesuai pola ${a.pattern}` : `${r[a.format] ?? i.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${i.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${i.keys.length > 1 ? "s" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${i.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${i.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function Oy() {
  return { localeError: xy() };
}
var Uy = (e) => {
  let t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "nmer";
    case "object": {
      if (Array.isArray(e)) return "fylki";
      if (e === null) return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name;
    }
  }
  return t;
}, jy = () => {
  let e = { string: { unit: "stafi", verb: "a hafa" }, file: { unit: "bti", verb: "a hafa" }, array: { unit: "hluti", verb: "a hafa" }, set: { unit: "hluti", verb: "a hafa" } };
  function t(r) {
    return e[r] ?? null;
  }
  let n = { regex: "gildi", email: "netfang", url: "vefsl", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tmi", date: "ISO dagsetning", time: "ISO tmi", duration: "ISO tmalengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tlugildi", jwt: "JWT", template_literal: "gildi" };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Rangt gildi:  slst inn ${Uy(r.input)} ar sem  a vera ${r.expected}`;
      case "invalid_value":
        return r.values.length === 1 ? `Rangt gildi: gert r fyrir ${w(r.values[0])}` : `gilt val: m vera eitt af eftirfarandi ${v(r.values, "|")}`;
      case "too_big": {
        let i = r.inclusive ? "<=" : "<", a = t(r.origin);
        return a ? `Of strt: gert er r fyrir a ${r.origin ?? "gildi"} hafi ${i}${r.maximum.toString()} ${a.unit ?? "hluti"}` : `Of strt: gert er r fyrir a ${r.origin ?? "gildi"} s ${i}${r.maximum.toString()}`;
      }
      case "too_small": {
        let i = r.inclusive ? ">=" : ">", a = t(r.origin);
        return a ? `Of lti: gert er r fyrir a ${r.origin} hafi ${i}${r.minimum.toString()} ${a.unit}` : `Of lti: gert er r fyrir a ${r.origin} s ${i}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        let i = r;
        return i.format === "starts_with" ? `gildur strengur: verur a byrja  "${i.prefix}"` : i.format === "ends_with" ? `gildur strengur: verur a enda  "${i.suffix}"` : i.format === "includes" ? `gildur strengur: verur a innihalda "${i.includes}"` : i.format === "regex" ? `gildur strengur: verur a fylgja mynstri ${i.pattern}` : `Rangt ${n[i.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${r.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${r.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${v(r.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${r.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${r.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function Py() {
  return { localeError: jy() };
}
var Ny = () => {
  let e = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "numero";
      case "object": {
        if (Array.isArray(i)) return "vettore";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Input non valido: atteso ${i.expected}, ricevuto ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Input non valido: atteso ${w(i.values[0])}` : `Opzione non valida: atteso uno tra ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Troppo grande: ${i.origin ?? "valore"} deve avere ${a}${i.maximum.toString()} ${o.unit ?? "elementi"}` : `Troppo grande: ${i.origin ?? "valore"} deve essere ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Troppo piccolo: ${i.origin} deve avere ${a}${i.minimum.toString()} ${o.unit}` : `Troppo piccolo: ${i.origin} deve essere ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Stringa non valida: deve iniziare con "${a.prefix}"` : a.format === "ends_with" ? `Stringa non valida: deve terminare con "${a.suffix}"` : a.format === "includes" ? `Stringa non valida: deve includere "${a.includes}"` : a.format === "regex" ? `Stringa non valida: deve corrispondere al pattern ${a.pattern}` : `Invalid ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${i.divisor}`;
      case "unrecognized_keys":
        return `Chiav${i.keys.length > 1 ? "i" : "e"} non riconosciut${i.keys.length > 1 ? "e" : "a"}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${i.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${i.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function Zy() {
  return { localeError: Ny() };
}
var Dy = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `: ${i.expected}${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `: ${w(i.values[0])}` : `: ${v(i.values, "")}`;
      case "too_big": {
        let a = i.inclusive ? "" : "", o = t(i.origin);
        return o ? `: ${i.origin ?? ""}${i.maximum.toString()}${o.unit ?? ""}${a}` : `: ${i.origin ?? ""}${i.maximum.toString()}${a}`;
      }
      case "too_small": {
        let a = i.inclusive ? "" : "", o = t(i.origin);
        return o ? `: ${i.origin}${i.minimum.toString()}${o.unit}${a}` : `: ${i.origin}${i.minimum.toString()}${a}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `: "${a.prefix}"` : a.format === "ends_with" ? `: "${a.suffix}"` : a.format === "includes" ? `: "${a.includes}"` : a.format === "regex" ? `: ${a.pattern}` : `${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `: ${i.divisor}`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "" : ""}: ${v(i.keys, "")}`;
      case "invalid_key":
        return `${i.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${i.origin}`;
      default:
        return "";
    }
  };
};
function Ey() {
  return { localeError: Dy() };
}
var Ay = (e) => {
  let t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "";
    case "object": {
      if (Array.isArray(e)) return "";
      if (e === null) return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name;
    }
  }
  return { string: "", boolean: "", undefined: "undefined", bigint: "bigint", symbol: "symbol", function: "" }[t] ?? t;
}, Ty = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(r) {
    return e[r] ?? null;
  }
  let n = { regex: "", email: "- ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "-", date: "", time: "", duration: "", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return ` :  ${r.expected},  ${Ay(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? ` :  ${w(r.values[0])}` : ` :  - ${v(r.values, "|")}-`;
      case "too_big": {
        let i = r.inclusive ? "<=" : "<", a = t(r.origin);
        return a ? ` :  ${r.origin ?? ""} ${a.verb} ${i}${r.maximum.toString()} ${a.unit}` : ` :  ${r.origin ?? ""}  ${i}${r.maximum.toString()}`;
      }
      case "too_small": {
        let i = r.inclusive ? ">=" : ">", a = t(r.origin);
        return a ? ` :  ${r.origin} ${a.verb} ${i}${r.minimum.toString()} ${a.unit}` : ` :  ${r.origin}  ${i}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        let i = r;
        return i.format === "starts_with" ? ` :   "${i.prefix}"-` : i.format === "ends_with" ? ` :   "${i.suffix}"-` : i.format === "includes" ? ` :   "${i.includes}"-` : i.format === "regex" ? ` :    ${i.pattern}` : ` ${n[i.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return ` :   ${r.divisor}- `;
      case "unrecognized_keys":
        return ` ${r.keys.length > 1 ? "" : ""}: ${v(r.keys, ", ")}`;
      case "invalid_key":
        return `  ${r.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${r.origin}-`;
      default:
        return " ";
    }
  };
};
function Ry() {
  return { localeError: Ty() };
}
var Cy = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? " (NaN)" : "";
      case "object": {
        if (Array.isArray(i)) return " (Array)";
        if (i === null) return " (null)";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: " base64", base64url: " base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `  ${i.expected}  ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `  ${w(i.values[0])}` : `  ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `  ${i.origin ?? ""} ${a} ${i.maximum.toString()} ${o.unit ?? ""}` : `  ${i.origin ?? ""} ${a} ${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `  ${i.origin} ${a} ${i.minimum.toString()} ${o.unit}` : `  ${i.origin} ${a} ${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `  "${a.prefix}"` : a.format === "ends_with" ? `  "${a.suffix}"` : a.format === "includes" ? `  "${a.includes}"` : a.format === "regex" ? `  ${a.pattern}` : ` ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `  ${i.divisor}`;
      case "unrecognized_keys":
        return ` ${v(i.keys, ", ")}`;
      case "invalid_key":
        return ` ${i.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return ` ${i.origin}`;
      default:
        return "";
    }
  };
};
function Rl() {
  return { localeError: Cy() };
}
function My() {
  return Rl();
}
var Ly = () => {
  let e = { string: { unit: "", verb: "to have" }, file: { unit: "", verb: "to have" }, array: { unit: "", verb: "to have" }, set: { unit: "", verb: "to have" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return ` :   ${i.expected},   ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? ` :  ${w(i.values[0])}  ` : ` : ${v(i.values, " ")}   `;
      case "too_big": {
        let a = i.inclusive ? "" : "", o = a === "" ? " " : " ", s = t(i.origin), l = s?.unit ?? "";
        return s ? `${i.origin ?? ""}  : ${i.maximum.toString()}${l} ${a}${o}` : `${i.origin ?? ""}  : ${i.maximum.toString()} ${a}${o}`;
      }
      case "too_small": {
        let a = i.inclusive ? "" : "", o = a === "" ? " " : " ", s = t(i.origin), l = s?.unit ?? "";
        return s ? `${i.origin ?? ""}  : ${i.minimum.toString()}${l} ${a}${o}` : `${i.origin ?? ""}  : ${i.minimum.toString()} ${a}${o}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` : "${a.prefix}"()  ` : a.format === "ends_with" ? ` : "${a.suffix}"()  ` : a.format === "includes" ? ` : "${a.includes}"()  ` : a.format === "regex" ? ` :  ${a.pattern}   ` : ` ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return ` : ${i.divisor}  `;
      case "unrecognized_keys":
        return `   : ${v(i.keys, ", ")}`;
      case "invalid_key":
        return ` : ${i.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return ` : ${i.origin}`;
      default:
        return " ";
    }
  };
};
function Fy() {
  return { localeError: Ly() };
}
var Jy = (e) => Qe(typeof e, e), Qe = (e, t = void 0) => {
  switch (e) {
    case "number":
      return Number.isNaN(t) ? "NaN" : "skaiius";
    case "bigint":
      return "sveikasis skaiius";
    case "string":
      return "eilut";
    case "boolean":
      return "login reikm";
    case "undefined":
    case "void":
      return "neapibrta reikm";
    case "function":
      return "funkcija";
    case "symbol":
      return "simbolis";
    case "object":
      return t === void 0 ? "neinomas objektas" : t === null ? "nulin reikm" : Array.isArray(t) ? "masyvas" : Object.getPrototypeOf(t) !== Object.prototype && t.constructor ? t.constructor.name : "objektas";
    case "null":
      return "nulin reikm";
  }
  return e;
}, Xe = (e) => e.charAt(0).toUpperCase() + e.slice(1);
function no(e) {
  let t = Math.abs(e), n = t % 10, r = t % 100;
  return r >= 11 && r <= 19 || n === 0 ? "many" : n === 1 ? "one" : "few";
}
var qy = () => {
  let e = { string: { unit: { one: "simbolis", few: "simboliai", many: "simboli" }, verb: { smaller: { inclusive: "turi bti ne ilgesn kaip", notInclusive: "turi bti trumpesn kaip" }, bigger: { inclusive: "turi bti ne trumpesn kaip", notInclusive: "turi bti ilgesn kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "bait" }, verb: { smaller: { inclusive: "turi bti ne didesnis kaip", notInclusive: "turi bti maesnis kaip" }, bigger: { inclusive: "turi bti ne maesnis kaip", notInclusive: "turi bti didesnis kaip" } } }, array: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } }, set: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } } };
  function t(r, i, a, o) {
    let s = e[r] ?? null;
    return s === null ? s : { unit: s.unit[i], verb: s.verb[o][a ? "inclusive" : "notInclusive"] };
  }
  let n = { regex: "vestis", email: "el. pato adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukm", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 ukoduota eilut", base64url: "base64url ukoduota eilut", json_string: "JSON eilut", e164: "E.164 numeris", jwt: "JWT", template_literal: "vestis" };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Gautas tipas ${Jy(r.input)}, o tiktasi - ${Qe(r.expected)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Privalo bti ${w(r.values[0])}` : `Privalo bti vienas i ${v(r.values, "|")} pasirinkim`;
      case "too_big": {
        let i = Qe(r.origin), a = t(r.origin, no(Number(r.maximum)), r.inclusive ?? !1, "smaller");
        if (a?.verb) return `${Xe(i ?? r.origin ?? "reikm")} ${a.verb} ${r.maximum.toString()} ${a.unit ?? "element"}`;
        let o = r.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${Xe(i ?? r.origin ?? "reikm")} turi bti ${o} ${r.maximum.toString()} ${a?.unit}`;
      }
      case "too_small": {
        let i = Qe(r.origin), a = t(r.origin, no(Number(r.minimum)), r.inclusive ?? !1, "bigger");
        if (a?.verb) return `${Xe(i ?? r.origin ?? "reikm")} ${a.verb} ${r.minimum.toString()} ${a.unit ?? "element"}`;
        let o = r.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${Xe(i ?? r.origin ?? "reikm")} turi bti ${o} ${r.minimum.toString()} ${a?.unit}`;
      }
      case "invalid_format": {
        let i = r;
        return i.format === "starts_with" ? `Eilut privalo prasidti "${i.prefix}"` : i.format === "ends_with" ? `Eilut privalo pasibaigti "${i.suffix}"` : i.format === "includes" ? `Eilut privalo traukti "${i.includes}"` : i.format === "regex" ? `Eilut privalo atitikti ${i.pattern}` : `Neteisingas ${n[i.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${r.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${r.keys.length > 1 ? "i" : "as"} rakt${r.keys.length > 1 ? "ai" : "as"}: ${v(r.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        let i = Qe(r.origin);
        return `${Xe(i ?? r.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function Wy() {
  return { localeError: qy() };
}
var Ky = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: "  -", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return ` :   ${i.expected},  ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Invalid input: expected ${w(i.values[0])}` : ` :    ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? ` :   ${i.origin ?? ""}   ${a}${i.maximum.toString()} ${o.unit ?? ""}` : ` :   ${i.origin ?? ""}   ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? ` :   ${i.origin}   ${a}${i.minimum.toString()} ${o.unit}` : ` :   ${i.origin}   ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` :     "${a.prefix}"` : a.format === "ends_with" ? ` :     "${a.suffix}"` : a.format === "includes" ? ` :    "${a.includes}"` : a.format === "regex" ? ` :      ${a.pattern}` : `Invalid ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return ` :      ${i.divisor}`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? " " : " "}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `   ${i.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${i.origin}`;
      default:
        return " ";
    }
  };
};
function Vy() {
  return { localeError: Ky() };
}
var Gy = () => {
  let e = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "nombor";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${i.expected}, diterima ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Input tidak sah: dijangka ${w(i.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Terlalu besar: dijangka ${i.origin ?? "nilai"} ${o.verb} ${a}${i.maximum.toString()} ${o.unit ?? "elemen"}` : `Terlalu besar: dijangka ${i.origin ?? "nilai"} adalah ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Terlalu kecil: dijangka ${i.origin} ${o.verb} ${a}${i.minimum.toString()} ${o.unit}` : `Terlalu kecil: dijangka ${i.origin} adalah ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `String tidak sah: mesti bermula dengan "${a.prefix}"` : a.format === "ends_with" ? `String tidak sah: mesti berakhir dengan "${a.suffix}"` : a.format === "includes" ? `String tidak sah: mesti mengandungi "${a.includes}"` : a.format === "regex" ? `String tidak sah: mesti sepadan dengan corak ${a.pattern}` : `${r[a.format] ?? i.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${i.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${i.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${i.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function By() {
  return { localeError: Gy() };
}
var Hy = () => {
  let e = { string: { unit: "tekens", verb: "te hebben" }, file: { unit: "bytes", verb: "te hebben" }, array: { unit: "elementen", verb: "te hebben" }, set: { unit: "elementen", verb: "te hebben" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "getal";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${i.expected}, ontving ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Ongeldige invoer: verwacht ${w(i.values[0])}` : `Ongeldige optie: verwacht n van ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Te groot: verwacht dat ${i.origin ?? "waarde"} ${o.verb} ${a}${i.maximum.toString()} ${o.unit ?? "elementen"}` : `Te groot: verwacht dat ${i.origin ?? "waarde"} ${a}${i.maximum.toString()} is`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Te klein: verwacht dat ${i.origin} ${o.verb} ${a}${i.minimum.toString()} ${o.unit}` : `Te klein: verwacht dat ${i.origin} ${a}${i.minimum.toString()} is`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Ongeldige tekst: moet met "${a.prefix}" beginnen` : a.format === "ends_with" ? `Ongeldige tekst: moet op "${a.suffix}" eindigen` : a.format === "includes" ? `Ongeldige tekst: moet "${a.includes}" bevatten` : a.format === "regex" ? `Ongeldige tekst: moet overeenkomen met patroon ${a.pattern}` : `Ongeldig: ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${i.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${i.keys.length > 1 ? "s" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${i.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${i.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function Xy() {
  return { localeError: Hy() };
}
var Yy = () => {
  let e = { string: { unit: "tegn", verb: " ha" }, file: { unit: "bytes", verb: " ha" }, array: { unit: "elementer", verb: " inneholde" }, set: { unit: "elementer", verb: " inneholde" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "tall";
      case "object": {
        if (Array.isArray(i)) return "liste";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${i.expected}, fikk ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Ugyldig verdi: forventet ${w(i.values[0])}` : `Ugyldig valg: forventet en av ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `For stor(t): forventet ${i.origin ?? "value"} til  ha ${a}${i.maximum.toString()} ${o.unit ?? "elementer"}` : `For stor(t): forventet ${i.origin ?? "value"} til  ha ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `For lite(n): forventet ${i.origin} til  ha ${a}${i.minimum.toString()} ${o.unit}` : `For lite(n): forventet ${i.origin} til  ha ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Ugyldig streng: m starte med "${a.prefix}"` : a.format === "ends_with" ? `Ugyldig streng: m ende med "${a.suffix}"` : a.format === "includes" ? `Ugyldig streng: m inneholde "${a.includes}"` : a.format === "regex" ? `Ugyldig streng: m matche mnsteret ${a.pattern}` : `Ugyldig ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${i.divisor}`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${i.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${i.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function Qy() {
  return { localeError: Yy() };
}
var e$ = () => {
  let e = { string: { unit: "harf", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "unsur", verb: "olmaldr" }, set: { unit: "unsur", verb: "olmaldr" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "numara";
      case "object": {
        if (Array.isArray(i)) return "saf";
        if (i === null) return "gayb";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "giren", email: "epostagh", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengm", date: "ISO tarihi", time: "ISO zaman", duration: "ISO mddeti", ipv4: "IPv4 nin", ipv6: "IPv6 nin", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-ifreli metin", base64url: "base64url-ifreli metin", json_string: "JSON metin", e164: "E.164 says", jwt: "JWT", template_literal: "giren" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Fsit giren: umulan ${i.expected}, alnan ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Fsit giren: umulan ${w(i.values[0])}` : `Fsit tercih: mteberler ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Fazla byk: ${i.origin ?? "value"}, ${a}${i.maximum.toString()} ${o.unit ?? "elements"} sahip olmalyd.` : `Fazla byk: ${i.origin ?? "value"}, ${a}${i.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Fazla kk: ${i.origin}, ${a}${i.minimum.toString()} ${o.unit} sahip olmalyd.` : `Fazla kk: ${i.origin}, ${a}${i.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Fsit metin: "${a.prefix}" ile balamal.` : a.format === "ends_with" ? `Fsit metin: "${a.suffix}" ile bitmeli.` : a.format === "includes" ? `Fsit metin: "${a.includes}" ihtiv etmeli.` : a.format === "regex" ? `Fsit metin: ${a.pattern} nakna uymal.` : `Fsit ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${i.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${i.keys.length > 1 ? "s" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${i.origin} iin tannmayan kymet var.`;
      default:
        return "Kymet tannamad.";
    }
  };
};
function t$() {
  return { localeError: e$() };
}
var i$ = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: "", url: "  ", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ", date: "", time: "", duration: "", ipv4: " IPv4 ", ipv6: " IPv6 ", cidrv4: " IPv4 ", cidrv6: " IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: " E.164 ", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return ` :  ${i.expected} ,  ${n(i.input)}  `;
      case "invalid_value":
        return i.values.length === 1 ? ` :  ${w(i.values[0])} ` : ` :    ${v(i.values, "|")}  `;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? ` : ${i.origin ?? ""}  ${a}${i.maximum.toString()} ${o.unit ?? ""} ` : ` : ${i.origin ?? ""}  ${a}${i.maximum.toString()} `;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? ` : ${i.origin}  ${a}${i.minimum.toString()} ${o.unit} ` : ` : ${i.origin}  ${a}${i.minimum.toString()} `;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` :   "${a.prefix}"   ` : a.format === "ends_with" ? ` :   "${a.suffix}"    ` : a.format === "includes" ? ` :  "${a.includes}" ` : a.format === "regex" ? ` :   ${a.pattern}   ` : `${r[a.format] ?? i.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${i.divisor}  `;
      case "unrecognized_keys":
        return ` ${i.keys.length > 1 ? "" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `   ${i.origin} `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${i.origin} `;
      default:
        return " ";
    }
  };
};
function n$() {
  return { localeError: i$() };
}
var r$ = () => {
  let e = { string: { unit: "znakw", verb: "mie" }, file: { unit: "bajtw", verb: "mie" }, array: { unit: "elementw", verb: "mie" }, set: { unit: "elementw", verb: "mie" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "liczba";
      case "object": {
        if (Array.isArray(i)) return "tablica";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "wyraenie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "cig znakw zakodowany w formacie base64", base64url: "cig znakw zakodowany w formacie base64url", json_string: "cig znakw w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejcie" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Nieprawidowe dane wejciowe: oczekiwano ${i.expected}, otrzymano ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Nieprawidowe dane wejciowe: oczekiwano ${w(i.values[0])}` : `Nieprawidowa opcja: oczekiwano jednej z wartoci ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Za dua warto: oczekiwano, e ${i.origin ?? "warto"} bdzie mie ${a}${i.maximum.toString()} ${o.unit ?? "elementw"}` : `Zbyt du(y/a/e): oczekiwano, e ${i.origin ?? "warto"} bdzie wynosi ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Za maa warto: oczekiwano, e ${i.origin ?? "warto"} bdzie mie ${a}${i.minimum.toString()} ${o.unit ?? "elementw"}` : `Zbyt ma(y/a/e): oczekiwano, e ${i.origin ?? "warto"} bdzie wynosi ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Nieprawidowy cig znakw: musi zaczyna si od "${a.prefix}"` : a.format === "ends_with" ? `Nieprawidowy cig znakw: musi koczy si na "${a.suffix}"` : a.format === "includes" ? `Nieprawidowy cig znakw: musi zawiera "${a.includes}"` : a.format === "regex" ? `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${a.pattern}` : `Nieprawidow(y/a/e) ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${i.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${i.keys.length > 1 ? "s" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${i.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${i.origin}`;
      default:
        return "Nieprawidowe dane wejciowe";
    }
  };
};
function a$() {
  return { localeError: r$() };
}
var o$ = () => {
  let e = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "nmero";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "nulo";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "padro", email: "endereo de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "durao ISO", ipv4: "endereo IPv4", ipv6: "endereo IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Tipo invlido: esperado ${i.expected}, recebido ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Entrada invlida: esperado ${w(i.values[0])}` : `Opo invlida: esperada uma das ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Muito grande: esperado que ${i.origin ?? "valor"} tivesse ${a}${i.maximum.toString()} ${o.unit ?? "elementos"}` : `Muito grande: esperado que ${i.origin ?? "valor"} fosse ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Muito pequeno: esperado que ${i.origin} tivesse ${a}${i.minimum.toString()} ${o.unit}` : `Muito pequeno: esperado que ${i.origin} fosse ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Texto invlido: deve comear com "${a.prefix}"` : a.format === "ends_with" ? `Texto invlido: deve terminar com "${a.suffix}"` : a.format === "includes" ? `Texto invlido: deve incluir "${a.includes}"` : a.format === "regex" ? `Texto invlido: deve corresponder ao padro ${a.pattern}` : `${r[a.format] ?? i.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${i.divisor}`;
      case "unrecognized_keys":
        return `Chave${i.keys.length > 1 ? "s" : ""} desconhecida${i.keys.length > 1 ? "s" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${i.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${i.origin}`;
      default:
        return "Campo invlido";
    }
  };
};
function s$() {
  return { localeError: o$() };
}
function ro(e, t, n, r) {
  let i = Math.abs(e), a = i % 10, o = i % 100;
  return o >= 11 && o <= 19 ? r : a === 1 ? t : a >= 2 && a <= 4 ? n : r;
}
var u$ = () => {
  let e = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return ` :  ${i.expected},  ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? ` :  ${w(i.values[0])}` : ` :    ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        if (o) {
          let s = Number(i.maximum), l = ro(s, o.unit.one, o.unit.few, o.unit.many);
          return `  : ,  ${i.origin ?? ""}   ${a}${i.maximum.toString()} ${l}`;
        }
        return `  : ,  ${i.origin ?? ""}  ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        if (o) {
          let s = Number(i.minimum), l = ro(s, o.unit.one, o.unit.few, o.unit.many);
          return `  : ,  ${i.origin}   ${a}${i.minimum.toString()} ${l}`;
        }
        return `  : ,  ${i.origin}  ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` :    "${a.prefix}"` : a.format === "ends_with" ? ` :    "${a.suffix}"` : a.format === "includes" ? ` :   "${a.includes}"` : a.format === "regex" ? ` :    ${a.pattern}` : ` ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return ` :    ${i.divisor}`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "" : ""} ${i.keys.length > 1 ? "" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `   ${i.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${i.origin}`;
      default:
        return "  ";
    }
  };
};
function l$() {
  return { localeError: u$() };
}
var c$ = () => {
  let e = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "tevilo";
      case "object": {
        if (Array.isArray(i)) return "tabela";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "vnos", email: "e-potni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in as", date: "ISO datum", time: "ISO as", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 tevilka", jwt: "JWT", template_literal: "vnos" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Neveljaven vnos: priakovano ${i.expected}, prejeto ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Neveljaven vnos: priakovano ${w(i.values[0])}` : `Neveljavna monost: priakovano eno izmed ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Preveliko: priakovano, da bo ${i.origin ?? "vrednost"} imelo ${a}${i.maximum.toString()} ${o.unit ?? "elementov"}` : `Preveliko: priakovano, da bo ${i.origin ?? "vrednost"} ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Premajhno: priakovano, da bo ${i.origin} imelo ${a}${i.minimum.toString()} ${o.unit}` : `Premajhno: priakovano, da bo ${i.origin} ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Neveljaven niz: mora se zaeti z "${a.prefix}"` : a.format === "ends_with" ? `Neveljaven niz: mora se konati z "${a.suffix}"` : a.format === "includes" ? `Neveljaven niz: mora vsebovati "${a.includes}"` : a.format === "regex" ? `Neveljaven niz: mora ustrezati vzorcu ${a.pattern}` : `Neveljaven ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${i.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${i.keys.length > 1 ? "i kljui" : " klju"}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${i.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${i.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function d$() {
  return { localeError: c$() };
}
var m$ = () => {
  let e = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehlla" }, set: { unit: "objekt", verb: "att innehlla" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "antal";
      case "object": {
        if (Array.isArray(i)) return "lista";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "reguljrt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad strng", base64url: "base64url-kodad strng", json_string: "JSON-strng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Ogiltig inmatning: frvntat ${i.expected}, fick ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Ogiltig inmatning: frvntat ${w(i.values[0])}` : `Ogiltigt val: frvntade en av ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Fr stor(t): frvntade ${i.origin ?? "vrdet"} att ha ${a}${i.maximum.toString()} ${o.unit ?? "element"}` : `Fr stor(t): frvntat ${i.origin ?? "vrdet"} att ha ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Fr lite(t): frvntade ${i.origin ?? "vrdet"} att ha ${a}${i.minimum.toString()} ${o.unit}` : `Fr lite(t): frvntade ${i.origin ?? "vrdet"} att ha ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Ogiltig strng: mste brja med "${a.prefix}"` : a.format === "ends_with" ? `Ogiltig strng: mste sluta med "${a.suffix}"` : a.format === "includes" ? `Ogiltig strng: mste innehlla "${a.includes}"` : a.format === "regex" ? `Ogiltig strng: mste matcha mnstret "${a.pattern}"` : `Ogiltig(t) ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${i.divisor}`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${i.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${i.origin ?? "vrdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function p$() {
  return { localeError: m$() };
}
var f$ = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? " " : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: " ", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO  ", date: "ISO ", time: "ISO ", duration: "ISO  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "input" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return ` :  ${i.expected},  ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? ` :  ${w(i.values[0])}` : ` :  ${v(i.values, "|")}  `;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? ` :  ${i.origin ?? ""} ${a}${i.maximum.toString()} ${o.unit ?? ""}   ` : ` :  ${i.origin ?? ""} ${a}${i.maximum.toString()}   `;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? ` :  ${i.origin} ${a}${i.minimum.toString()} ${o.unit}   ` : ` :  ${i.origin} ${a}${i.minimum.toString()}   `;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` : "${a.prefix}"   ` : a.format === "ends_with" ? ` : "${a.suffix}"   ` : a.format === "includes" ? ` : "${a.includes}"   ` : a.format === "regex" ? ` : ${a.pattern}   ` : ` ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return ` : ${i.divisor}    `;
      case "unrecognized_keys":
        return `  ${i.keys.length > 1 ? "" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${i.origin}   `;
      default:
        return " ";
    }
  };
};
function g$() {
  return { localeError: f$() };
}
var h$ = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? " (NaN)" : "";
      case "object": {
        if (Array.isArray(i)) return " (Array)";
        if (i === null) return " (null)";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: " ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IP  IPv4", cidrv6: " IP  IPv6", base64: " Base64", base64url: " Base64  URL", json_string: " JSON", e164: " (E.164)", jwt: " JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `:  ${i.expected}  ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `:  ${w(i.values[0])}` : `:  ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "" : "", o = t(i.origin);
        return o ? `: ${i.origin ?? ""} ${a} ${i.maximum.toString()} ${o.unit ?? ""}` : `: ${i.origin ?? ""} ${a} ${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? "" : "", o = t(i.origin);
        return o ? `: ${i.origin} ${a} ${i.minimum.toString()} ${o.unit}` : `: ${i.origin} ${a} ${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `:  "${a.prefix}"` : a.format === "ends_with" ? `:  "${a.suffix}"` : a.format === "includes" ? `:  "${a.includes}" ` : a.format === "regex" ? `:  ${a.pattern}` : `: ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `:  ${i.divisor} `;
      case "unrecognized_keys":
        return `: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return ` ${i.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${i.origin}`;
      default:
        return "";
    }
  };
};
function v$() {
  return { localeError: h$() };
}
var b$ = (e) => {
  let t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(e)) return "array";
      if (e === null) return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name;
    }
  }
  return t;
}, _$ = () => {
  let e = { string: { unit: "karakter", verb: "olmal" }, file: { unit: "bayt", verb: "olmal" }, array: { unit: "e", verb: "olmal" }, set: { unit: "e", verb: "olmal" } };
  function t(r) {
    return e[r] ?? null;
  }
  let n = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO sre", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aral", cidrv6: "IPv6 aral", base64: "base64 ile ifrelenmi metin", base64url: "base64url ile ifrelenmi metin", json_string: "JSON dizesi", e164: "E.164 says", jwt: "JWT", template_literal: "ablon dizesi" };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Geersiz deer: beklenen ${r.expected}, alnan ${b$(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Geersiz deer: beklenen ${w(r.values[0])}` : `Geersiz seenek: aadakilerden biri olmal: ${v(r.values, "|")}`;
      case "too_big": {
        let i = r.inclusive ? "<=" : "<", a = t(r.origin);
        return a ? `ok byk: beklenen ${r.origin ?? "deer"} ${i}${r.maximum.toString()} ${a.unit ?? "e"}` : `ok byk: beklenen ${r.origin ?? "deer"} ${i}${r.maximum.toString()}`;
      }
      case "too_small": {
        let i = r.inclusive ? ">=" : ">", a = t(r.origin);
        return a ? `ok kk: beklenen ${r.origin} ${i}${r.minimum.toString()} ${a.unit}` : `ok kk: beklenen ${r.origin} ${i}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        let i = r;
        return i.format === "starts_with" ? `Geersiz metin: "${i.prefix}" ile balamal` : i.format === "ends_with" ? `Geersiz metin: "${i.suffix}" ile bitmeli` : i.format === "includes" ? `Geersiz metin: "${i.includes}" iermeli` : i.format === "regex" ? `Geersiz metin: ${i.pattern} desenine uymal` : `Geersiz ${n[i.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${r.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${r.keys.length > 1 ? "lar" : ""}: ${v(r.keys, ", ")}`;
      case "invalid_key":
        return `${r.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${r.origin} iinde geersiz deer`;
      default:
        return "Geersiz deer";
    }
  };
};
function y$() {
  return { localeError: _$() };
}
var $$ = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: " ", email: "  ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: "   base64", base64url: "   base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: " " };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `  :  ${i.expected},  ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `  :  ${w(i.values[0])}` : ` :    ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? ` : ,  ${i.origin ?? ""} ${o.verb} ${a}${i.maximum.toString()} ${o.unit ?? ""}` : ` : ,  ${i.origin ?? ""}  ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? ` : ,  ${i.origin} ${o.verb} ${a}${i.minimum.toString()} ${o.unit}` : ` : ,  ${i.origin}  ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` :    "${a.prefix}"` : a.format === "ends_with" ? ` :    "${a.suffix}"` : a.format === "includes" ? ` :   "${a.includes}"` : a.format === "regex" ? ` :    ${a.pattern}` : ` ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return ` :    ${i.divisor}`;
      case "unrecognized_keys":
        return ` ${i.keys.length > 1 ? "" : ""}: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `   ${i.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${i.origin}`;
      default:
        return "  ";
    }
  };
};
function Cl() {
  return { localeError: $$() };
}
function I$() {
  return Cl();
}
var k$ = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: " ", email: "  ", url: "  ", emoji: "", uuid: "   ", uuidv4: "     4", uuidv6: "     6", nanoid: "  ", guid: "   ", cuid: "   ", cuid2: "    2", ulid: "   ", xid: "  ", ksuid: "    ", datetime: "    ", date: "   ", time: "   ", duration: "   ", ipv4: "   4 ", ipv6: "   6 ", cidrv4: "   4 ", cidrv6: "   6 ", base64: " 64   ", base64url: " 64      ", json_string: "    ", e164: " 164 ", jwt: "  ", template_literal: " " };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `  : ${i.expected}   ${n(i.input)}  `;
      case "invalid_value":
        return i.values.length === 1 ? `  : ${w(i.values[0])}  ` : ` : ${v(i.values, "|")}     `;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? ` : ${i.origin ?? ""}  ${a}${i.maximum.toString()} ${o.unit ?? ""}   ` : ` : ${i.origin ?? ""}  ${a}${i.maximum.toString()}   `;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? ` : ${i.origin}  ${a}${i.minimum.toString()} ${o.unit}   ` : ` : ${i.origin}  ${a}${i.minimum.toString()}   `;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` : "${a.prefix}"    ` : a.format === "ends_with" ? ` : "${a.suffix}"    ` : a.format === "includes" ? ` : "${a.includes}"   ` : a.format === "regex" ? ` :  ${a.pattern}    ` : ` ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return ` : ${i.divisor}    `;
      case "unrecognized_keys":
        return `   ${i.keys.length > 1 ? "" : ""}: ${v(i.keys, " ")}`;
      case "invalid_key":
        return `${i.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${i.origin}   `;
      default:
        return "  ";
    }
  };
};
function w$() {
  return { localeError: k$() };
}
var S$ = () => {
  let e = { string: { unit: "k t", verb: "c" }, file: { unit: "byte", verb: "c" }, array: { unit: "phn t", verb: "c" }, set: { unit: "phn t", verb: "c" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "s";
      case "object": {
        if (Array.isArray(i)) return "mng";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "u vo", email: "a ch email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngy gi ISO", date: "ngy ISO", time: "gi ISO", duration: "khong thi gian ISO", ipv4: "a ch IPv4", ipv6: "a ch IPv6", cidrv4: "di IPv4", cidrv6: "di IPv6", base64: "chui m ha base64", base64url: "chui m ha base64url", json_string: "chui JSON", e164: "s E.164", jwt: "JWT", template_literal: "u vo" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `u vo khng hp l: mong i ${i.expected}, nhn c ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `u vo khng hp l: mong i ${w(i.values[0])}` : `Ty chn khng hp l: mong i mt trong cc gi tr ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Qu ln: mong i ${i.origin ?? "gi tr"} ${o.verb} ${a}${i.maximum.toString()} ${o.unit ?? "phn t"}` : `Qu ln: mong i ${i.origin ?? "gi tr"} ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Qu nh: mong i ${i.origin} ${o.verb} ${a}${i.minimum.toString()} ${o.unit}` : `Qu nh: mong i ${i.origin} ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `Chui khng hp l: phi bt u bng "${a.prefix}"` : a.format === "ends_with" ? `Chui khng hp l: phi kt thc bng "${a.suffix}"` : a.format === "includes" ? `Chui khng hp l: phi bao gm "${a.includes}"` : a.format === "regex" ? `Chui khng hp l: phi khp vi mu ${a.pattern}` : `${r[a.format] ?? i.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${i.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${i.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${i.origin}`;
      default:
        return "u vo khng hp l";
    }
  };
};
function z$() {
  return { localeError: S$() };
}
var x$ = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "(NaN)" : "";
      case "object": {
        if (Array.isArray(i)) return "";
        if (i === null) return "(null)";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return ` ${i.expected} ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? ` ${w(i.values[0])}` : ` ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? ` ${i.origin ?? ""} ${a}${i.maximum.toString()} ${o.unit ?? ""}` : ` ${i.origin ?? ""} ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? ` ${i.origin} ${a}${i.minimum.toString()} ${o.unit}` : ` ${i.origin} ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` "${a.prefix}" ` : a.format === "ends_with" ? ` "${a.suffix}" ` : a.format === "includes" ? ` "${a.includes}"` : a.format === "regex" ? ` ${a.pattern}` : `${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return ` ${i.divisor} `;
      case "unrecognized_keys":
        return `(key): ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${i.origin} (value)`;
      default:
        return "";
    }
  };
};
function O$() {
  return { localeError: x$() };
}
var U$ = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i)) return "array";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "", email: "", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64 ", base64url: "base64url ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return ` ${i.expected} ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? ` ${w(i.values[0])}` : ` ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? ` ${i.origin ?? ""}  ${a}${i.maximum.toString()} ${o.unit ?? ""}` : ` ${i.origin ?? ""}  ${a}${i.maximum.toString()}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? ` ${i.origin}  ${a}${i.minimum.toString()} ${o.unit}` : ` ${i.origin}  ${a}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? ` "${a.prefix}" ` : a.format === "ends_with" ? ` "${a.suffix}" ` : a.format === "includes" ? ` "${a.includes}"` : a.format === "regex" ? ` ${a.pattern}` : ` ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return ` ${i.divisor} `;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "" : ""}${v(i.keys, "")}`;
      case "invalid_key":
        return `${i.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${i.origin} `;
      default:
        return "";
    }
  };
};
function j$() {
  return { localeError: U$() };
}
var P$ = () => {
  let e = { string: { unit: "mi", verb: "n" }, file: { unit: "bytes", verb: "n" }, array: { unit: "nkan", verb: "n" }, set: { unit: "nkan", verb: "n" } };
  function t(i) {
    return e[i] ?? null;
  }
  let n = (i) => {
    let a = typeof i;
    switch (a) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "nmb";
      case "object": {
        if (Array.isArray(i)) return "akop";
        if (i === null) return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor) return i.constructor.name;
      }
    }
    return a;
  }, r = { regex: "r bwl", email: "drs ml", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "kk ISO", date: "j ISO", time: "kk ISO", duration: "kk t p ISO", ipv4: "drs IPv4", ipv6: "drs IPv6", cidrv4: "gbgb IPv4", cidrv6: "gbgb IPv6", base64: "r t a k n base64", base64url: "r base64url", json_string: "r JSON", e164: "nmb E.164", jwt: "JWT", template_literal: "r bwl" };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `bwl ae: a n lti fi ${i.expected}, m a r ${n(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `bwl ae: a n lti fi ${w(i.values[0])}` : `yn ae: yan kan lra ${v(i.values, "|")}`;
      case "too_big": {
        let a = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `T p j: a n lti j p ${i.origin ?? "iye"} ${o.verb} ${a}${i.maximum} ${o.unit}` : `T p j: a n lti j ${a}${i.maximum}`;
      }
      case "too_small": {
        let a = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Kr ju: a n lti j p ${i.origin} ${o.verb} ${a}${i.minimum} ${o.unit}` : `Kr ju: a n lti j ${a}${i.minimum}`;
      }
      case "invalid_format": {
        let a = i;
        return a.format === "starts_with" ? `r ae: gbd br pl "${a.prefix}"` : a.format === "ends_with" ? `r ae: gbd par pl "${a.suffix}"` : a.format === "includes" ? `r ae: gbd n "${a.includes}"` : a.format === "regex" ? `r ae: gbd b pr mu ${a.pattern}` : `Ae: ${r[a.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${i.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${v(i.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${i.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${i.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function N$() {
  return { localeError: P$() };
}
var ao, Ml = Symbol("ZodOutput"), Ll = Symbol("ZodInput");
class Fl {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    let r = n[0];
    if (this._map.set(t, r), r && typeof r == "object" && "id" in r) {
      if (this._idmap.has(r.id)) throw Error(`ID ${r.id} already exists in the registry`);
      this._idmap.set(r.id, t);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    let n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    let n = t._zod.parent;
    if (n) {
      let r = { ...this.get(n) ?? {} };
      delete r.id;
      let i = { ...r, ...this._map.get(t) };
      return Object.keys(i).length ? i : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function tr() {
  return new Fl();
}
(ao = globalThis).__zod_globalRegistry ?? (ao.__zod_globalRegistry = tr());
var ge = globalThis.__zod_globalRegistry;
function Jl(e, t) {
  return new e({ type: "string", ...b(t) });
}
function ql(e, t) {
  return new e({ type: "string", coerce: !0, ...b(t) });
}
function ir(e, t) {
  return new e({ type: "string", format: "email", check: "string_format", abort: !1, ...b(t) });
}
function ii(e, t) {
  return new e({ type: "string", format: "guid", check: "string_format", abort: !1, ...b(t) });
}
function nr(e, t) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, ...b(t) });
}
function rr(e, t) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v4", ...b(t) });
}
function ar(e, t) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v6", ...b(t) });
}
function or(e, t) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v7", ...b(t) });
}
function bi(e, t) {
  return new e({ type: "string", format: "url", check: "string_format", abort: !1, ...b(t) });
}
function sr(e, t) {
  return new e({ type: "string", format: "emoji", check: "string_format", abort: !1, ...b(t) });
}
function ur(e, t) {
  return new e({ type: "string", format: "nanoid", check: "string_format", abort: !1, ...b(t) });
}
function lr(e, t) {
  return new e({ type: "string", format: "cuid", check: "string_format", abort: !1, ...b(t) });
}
function cr(e, t) {
  return new e({ type: "string", format: "cuid2", check: "string_format", abort: !1, ...b(t) });
}
function dr(e, t) {
  return new e({ type: "string", format: "ulid", check: "string_format", abort: !1, ...b(t) });
}
function mr(e, t) {
  return new e({ type: "string", format: "xid", check: "string_format", abort: !1, ...b(t) });
}
function pr(e, t) {
  return new e({ type: "string", format: "ksuid", check: "string_format", abort: !1, ...b(t) });
}
function fr(e, t) {
  return new e({ type: "string", format: "ipv4", check: "string_format", abort: !1, ...b(t) });
}
function gr(e, t) {
  return new e({ type: "string", format: "ipv6", check: "string_format", abort: !1, ...b(t) });
}
function Wl(e, t) {
  return new e({ type: "string", format: "mac", check: "string_format", abort: !1, ...b(t) });
}
function hr(e, t) {
  return new e({ type: "string", format: "cidrv4", check: "string_format", abort: !1, ...b(t) });
}
function vr(e, t) {
  return new e({ type: "string", format: "cidrv6", check: "string_format", abort: !1, ...b(t) });
}
function br(e, t) {
  return new e({ type: "string", format: "base64", check: "string_format", abort: !1, ...b(t) });
}
function _r(e, t) {
  return new e({ type: "string", format: "base64url", check: "string_format", abort: !1, ...b(t) });
}
function yr(e, t) {
  return new e({ type: "string", format: "e164", check: "string_format", abort: !1, ...b(t) });
}
function $r(e, t) {
  return new e({ type: "string", format: "jwt", check: "string_format", abort: !1, ...b(t) });
}
var Kl = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
function Vl(e, t) {
  return new e({ type: "string", format: "datetime", check: "string_format", offset: !1, local: !1, precision: null, ...b(t) });
}
function Gl(e, t) {
  return new e({ type: "string", format: "date", check: "string_format", ...b(t) });
}
function Bl(e, t) {
  return new e({ type: "string", format: "time", check: "string_format", precision: null, ...b(t) });
}
function Hl(e, t) {
  return new e({ type: "string", format: "duration", check: "string_format", ...b(t) });
}
function Xl(e, t) {
  return new e({ type: "number", checks: [], ...b(t) });
}
function Yl(e, t) {
  return new e({ type: "number", coerce: !0, checks: [], ...b(t) });
}
function Ql(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "safeint", ...b(t) });
}
function ec(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "float32", ...b(t) });
}
function tc(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "float64", ...b(t) });
}
function ic(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "int32", ...b(t) });
}
function nc(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "uint32", ...b(t) });
}
function rc(e, t) {
  return new e({ type: "boolean", ...b(t) });
}
function ac(e, t) {
  return new e({ type: "boolean", coerce: !0, ...b(t) });
}
function oc(e, t) {
  return new e({ type: "bigint", ...b(t) });
}
function sc(e, t) {
  return new e({ type: "bigint", coerce: !0, ...b(t) });
}
function uc(e, t) {
  return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "int64", ...b(t) });
}
function lc(e, t) {
  return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "uint64", ...b(t) });
}
function cc(e, t) {
  return new e({ type: "symbol", ...b(t) });
}
function dc(e, t) {
  return new e({ type: "undefined", ...b(t) });
}
function mc(e, t) {
  return new e({ type: "null", ...b(t) });
}
function pc(e) {
  return new e({ type: "any" });
}
function fc(e) {
  return new e({ type: "unknown" });
}
function gc(e, t) {
  return new e({ type: "never", ...b(t) });
}
function hc(e, t) {
  return new e({ type: "void", ...b(t) });
}
function vc(e, t) {
  return new e({ type: "date", ...b(t) });
}
function bc(e, t) {
  return new e({ type: "date", coerce: !0, ...b(t) });
}
function _c(e, t) {
  return new e({ type: "nan", ...b(t) });
}
function ke(e, t) {
  return new Kn({ check: "less_than", ...b(t), value: e, inclusive: !1 });
}
function le(e, t) {
  return new Kn({ check: "less_than", ...b(t), value: e, inclusive: !0 });
}
function we(e, t) {
  return new Vn({ check: "greater_than", ...b(t), value: e, inclusive: !1 });
}
function ie(e, t) {
  return new Vn({ check: "greater_than", ...b(t), value: e, inclusive: !0 });
}
function Ir(e) {
  return we(0, e);
}
function kr(e) {
  return ke(0, e);
}
function wr(e) {
  return le(0, e);
}
function Sr(e) {
  return ie(0, e);
}
function Le(e, t) {
  return new ru({ check: "multiple_of", ...b(t), value: e });
}
function St(e, t) {
  return new su({ check: "max_size", ...b(t), maximum: e });
}
function Fe(e, t) {
  return new uu({ check: "min_size", ...b(t), minimum: e });
}
function _i(e, t) {
  return new lu({ check: "size_equals", ...b(t), size: e });
}
function zt(e, t) {
  return new cu({ check: "max_length", ...b(t), maximum: e });
}
function Pe(e, t) {
  return new du({ check: "min_length", ...b(t), minimum: e });
}
function xt(e, t) {
  return new mu({ check: "length_equals", ...b(t), length: e });
}
function yi(e, t) {
  return new pu({ check: "string_format", format: "regex", ...b(t), pattern: e });
}
function $i(e) {
  return new fu({ check: "string_format", format: "lowercase", ...b(e) });
}
function Ii(e) {
  return new gu({ check: "string_format", format: "uppercase", ...b(e) });
}
function ki(e, t) {
  return new hu({ check: "string_format", format: "includes", ...b(t), includes: e });
}
function wi(e, t) {
  return new vu({ check: "string_format", format: "starts_with", ...b(t), prefix: e });
}
function Si(e, t) {
  return new bu({ check: "string_format", format: "ends_with", ...b(t), suffix: e });
}
function zr(e, t, n) {
  return new _u({ check: "property", property: e, schema: t, ...b(n) });
}
function zi(e, t) {
  return new yu({ check: "mime_type", mime: e, ...b(t) });
}
function ye(e) {
  return new $u({ check: "overwrite", tx: e });
}
function xi(e) {
  return ye((t) => t.normalize(e));
}
function Oi() {
  return ye((e) => e.trim());
}
function Ui() {
  return ye((e) => e.toLowerCase());
}
function ji() {
  return ye((e) => e.toUpperCase());
}
function Pi() {
  return ye((e) => cs(e));
}
function yc(e, t, n) {
  return new e({ type: "array", element: t, ...b(n) });
}
function Z$(e, t, n) {
  return new e({ type: "union", options: t, ...b(n) });
}
function D$(e, t, n) {
  return new e({ type: "union", options: t, inclusive: !1, ...b(n) });
}
function E$(e, t, n, r) {
  return new e({ type: "union", options: n, discriminator: t, ...b(r) });
}
function A$(e, t, n) {
  return new e({ type: "intersection", left: t, right: n });
}
function T$(e, t, n, r) {
  let i = n instanceof S;
  return new e({ type: "tuple", items: t, rest: i ? n : null, ...b(i ? r : n) });
}
function R$(e, t, n, r) {
  return new e({ type: "record", keyType: t, valueType: n, ...b(r) });
}
function C$(e, t, n, r) {
  return new e({ type: "map", keyType: t, valueType: n, ...b(r) });
}
function M$(e, t, n) {
  return new e({ type: "set", valueType: t, ...b(n) });
}
function L$(e, t, n) {
  let r = Array.isArray(t) ? Object.fromEntries(t.map((i) => [i, i])) : t;
  return new e({ type: "enum", entries: r, ...b(n) });
}
function F$(e, t, n) {
  return new e({ type: "enum", entries: t, ...b(n) });
}
function J$(e, t, n) {
  return new e({ type: "literal", values: Array.isArray(t) ? t : [t], ...b(n) });
}
function $c(e, t) {
  return new e({ type: "file", ...b(t) });
}
function q$(e, t) {
  return new e({ type: "transform", transform: t });
}
function W$(e, t) {
  return new e({ type: "optional", innerType: t });
}
function K$(e, t) {
  return new e({ type: "nullable", innerType: t });
}
function V$(e, t, n) {
  return new e({ type: "default", innerType: t, get defaultValue() {
    return typeof n == "function" ? n() : ms(n);
  } });
}
function G$(e, t, n) {
  return new e({ type: "nonoptional", innerType: t, ...b(n) });
}
function B$(e, t) {
  return new e({ type: "success", innerType: t });
}
function H$(e, t, n) {
  return new e({ type: "catch", innerType: t, catchValue: typeof n == "function" ? n : () => n });
}
function X$(e, t, n) {
  return new e({ type: "pipe", in: t, out: n });
}
function Y$(e, t) {
  return new e({ type: "readonly", innerType: t });
}
function Q$(e, t, n) {
  return new e({ type: "template_literal", parts: t, ...b(n) });
}
function eI(e, t) {
  return new e({ type: "lazy", getter: t });
}
function tI(e, t) {
  return new e({ type: "promise", innerType: t });
}
function Ic(e, t, n) {
  let r = b(n);
  return r.abort ?? (r.abort = !0), new e({ type: "custom", check: "custom", fn: t, ...r });
}
function kc(e, t, n) {
  return new e({ type: "custom", check: "custom", fn: t, ...b(n) });
}
function wc(e) {
  let t = Sc((n) => (n.addIssue = (r) => {
    if (typeof r == "string") n.issues.push(ei(r, n.value, t._zod.def));
    else {
      let i = r;
      i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = n.value), i.inst ?? (i.inst = t), i.continue ?? (i.continue = !t._zod.def.abort), n.issues.push(ei(i));
    }
  }, e(n.value, n)));
  return t;
}
function Sc(e, t) {
  let n = new F({ check: "custom", ...b(t) });
  return n._zod.check = e, n;
}
function zc(e) {
  let t = new F({ check: "describe" });
  return t._zod.onattach = [(n) => {
    let r = ge.get(n) ?? {};
    ge.add(n, { ...r, description: e });
  }], t._zod.check = () => {
  }, t;
}
function xc(e) {
  let t = new F({ check: "meta" });
  return t._zod.onattach = [(n) => {
    let r = ge.get(n) ?? {};
    ge.add(n, { ...r, ...e });
  }], t._zod.check = () => {
  }, t;
}
function Oc(e, t) {
  let n = b(t), r = n.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], i = n.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  n.case !== "sensitive" && (r = r.map((h) => typeof h == "string" ? h.toLowerCase() : h), i = i.map((h) => typeof h == "string" ? h.toLowerCase() : h));
  let a = new Set(r), o = new Set(i), s = e.Codec ?? Qn, l = e.Boolean ?? Hn, u = new (e.String ?? wt)({ type: "string", error: n.error }), d = new l({ type: "boolean", error: n.error }), f = new s({ type: "pipe", in: u, out: d, transform: (h, $) => {
    let P = h;
    return n.case !== "sensitive" && (P = P.toLowerCase()), a.has(P) ? !0 : o.has(P) ? !1 : ($.issues.push({ code: "invalid_value", expected: "stringbool", values: [...a, ...o], input: $.value, inst: f, continue: !1 }), {});
  }, reverseTransform: (h, $) => h === !0 ? r[0] || "true" : i[0] || "false", error: n.error });
  return f;
}
function Ot(e, t, n, r = {}) {
  let i = b(r), a = { ...b(r), check: "string_format", type: "string", format: t, fn: typeof n == "function" ? n : (o) => n.test(o), ...i };
  return n instanceof RegExp && (a.pattern = n), new e(a);
}
function Je(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), { processors: e.processors ?? {}, metadataRegistry: e?.metadata ?? ge, target: t, unrepresentable: e?.unrepresentable ?? "throw", override: e?.override ?? (() => {
  }), io: e?.io ?? "output", counter: 0, seen: /* @__PURE__ */ new Map(), cycles: e?.cycles ?? "ref", reused: e?.reused ?? "inline", external: e?.external ?? void 0 };
}
function D(e, t, n = { path: [], schemaPath: [] }) {
  var r;
  let i = e._zod.def, a = t.seen.get(e);
  if (a)
    return a.count++, n.schemaPath.includes(e) && (a.cycle = n.path), a.schema;
  let o = { schema: {}, count: 1, cycle: void 0, path: n.path };
  t.seen.set(e, o);
  let s = e._zod.toJSONSchema?.();
  if (s) o.schema = s;
  else {
    let u = { ...n, schemaPath: [...n.schemaPath, e], path: n.path }, d = e._zod.parent;
    if (d) o.ref = d, D(d, t, u), t.seen.get(d).isParent = !0;
    else if (e._zod.processJSONSchema) e._zod.processJSONSchema(t, o.schema, u);
    else {
      let f = o.schema, h = t.processors[i.type];
      if (!h) throw Error(`[toJSONSchema]: Non-representable type encountered: ${i.type}`);
      h(e, t, f, u);
    }
  }
  let l = t.metadataRegistry.get(e);
  return l && Object.assign(o.schema, l), t.io === "input" && te(e) && (delete o.schema.examples, delete o.schema.default), t.io === "input" && o.schema._prefault && ((r = o.schema).default ?? (r.default = o.schema._prefault)), delete o.schema._prefault, t.seen.get(e).schema;
}
function qe(e, t) {
  let n = e.seen.get(t);
  if (!n) throw Error("Unprocessed schema. This is a bug in Zod.");
  let r = (a) => {
    let o = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      let u = e.external.registry.get(a[0])?.id, d = e.external.uri ?? ((h) => h);
      if (u) return { ref: d(u) };
      let f = a[1].defId ?? a[1].schema.id ?? `schema${e.counter++}`;
      return a[1].defId = f, { defId: f, ref: `${d("__shared")}#/${o}/${f}` };
    }
    if (a[1] === n) return { ref: "#" };
    let s = `#/${o}/`, l = a[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: l, ref: s + l };
  }, i = (a) => {
    if (a[1].schema.$ref) return;
    let o = a[1], { ref: s, defId: l } = r(a);
    o.def = { ...o.schema }, l && (o.defId = l);
    let u = o.schema;
    for (let d in u) delete u[d];
    u.$ref = s;
  };
  if (e.cycles === "throw") for (let a of e.seen.entries()) {
    let o = a[1];
    if (o.cycle) throw Error(`Cycle detected: #/${o.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
  }
  for (let a of e.seen.entries()) {
    let o = a[1];
    if (t === a[0]) {
      i(a);
      continue;
    }
    if (e.external) {
      let s = e.external.registry.get(a[0])?.id;
      if (t !== a[0] && s) {
        i(a);
        continue;
      }
    }
    if (e.metadataRegistry.get(a[0])?.id) {
      i(a);
      continue;
    }
    if (o.cycle) {
      i(a);
      continue;
    }
    if (o.count > 1 && e.reused === "ref") {
      i(a);
      continue;
    }
  }
}
function We(e, t) {
  let n = e.seen.get(t);
  if (!n) throw Error("Unprocessed schema. This is a bug in Zod.");
  let r = (o) => {
    let s = e.seen.get(o), l = s.def ?? s.schema, u = { ...l };
    if (s.ref === null) return;
    let d = s.ref;
    if (s.ref = null, d) {
      r(d);
      let f = e.seen.get(d).schema;
      f.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (l.allOf = l.allOf ?? [], l.allOf.push(f)) : (Object.assign(l, f), Object.assign(l, u));
    }
    s.isParent || e.override({ zodSchema: o, jsonSchema: l, path: s.path ?? [] });
  };
  for (let o of [...e.seen.entries()].reverse()) r(o[0]);
  let i = {};
  if (e.target === "draft-2020-12" ? i.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? i.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? i.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    let o = e.external.registry.get(t)?.id;
    if (!o) throw Error("Schema is missing an `id` property");
    i.$id = e.external.uri(o);
  }
  Object.assign(i, n.def ?? n.schema);
  let a = e.external?.defs ?? {};
  for (let o of e.seen.entries()) {
    let s = o[1];
    s.def && s.defId && (a[s.defId] = s.def);
  }
  e.external || Object.keys(a).length > 0 && (e.target === "draft-2020-12" ? i.$defs = a : i.definitions = a);
  try {
    let o = JSON.parse(JSON.stringify(i));
    return Object.defineProperty(o, "~standard", { value: { ...t["~standard"], jsonSchema: { input: nt(t, "input"), output: nt(t, "output") } }, enumerable: !1, writable: !1 }), o;
  } catch {
    throw Error("Error converting schema to JSON.");
  }
}
function te(e, t) {
  let n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e)) return !1;
  n.seen.add(e);
  let r = e._zod.def;
  if (r.type === "transform") return !0;
  if (r.type === "array") return te(r.element, n);
  if (r.type === "set") return te(r.valueType, n);
  if (r.type === "lazy") return te(r.getter(), n);
  if (r.type === "promise" || r.type === "optional" || r.type === "nonoptional" || r.type === "nullable" || r.type === "readonly" || r.type === "default" || r.type === "prefault") return te(r.innerType, n);
  if (r.type === "intersection") return te(r.left, n) || te(r.right, n);
  if (r.type === "record" || r.type === "map") return te(r.keyType, n) || te(r.valueType, n);
  if (r.type === "pipe") return te(r.in, n) || te(r.out, n);
  if (r.type === "object") {
    for (let i in r.shape) if (te(r.shape[i], n)) return !0;
    return !1;
  }
  if (r.type === "union") {
    for (let i of r.options) if (te(i, n)) return !0;
    return !1;
  }
  if (r.type === "tuple") {
    for (let i of r.items) if (te(i, n)) return !0;
    return !!(r.rest && te(r.rest, n));
  }
  return !1;
}
var Uc = (e, t = {}) => (n) => {
  let r = Je({ ...n, processors: t });
  return D(e, r), qe(r, e), We(r, e);
}, nt = (e, t) => (n) => {
  let { libraryOptions: r, target: i } = n ?? {}, a = Je({ ...r ?? {}, target: i, io: t, processors: {} });
  return D(e, a), qe(a, e), We(a, e);
}, iI = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, jc = (e, t, n, r) => {
  let i = n;
  i.type = "string";
  let { minimum: a, maximum: o, format: s, patterns: l, contentEncoding: u } = e._zod.bag;
  if (typeof a == "number" && (i.minLength = a), typeof o == "number" && (i.maxLength = o), s && (i.format = iI[s] ?? s, i.format === "" && delete i.format), u && (i.contentEncoding = u), l && l.size > 0) {
    let d = [...l];
    d.length === 1 ? i.pattern = d[0].source : d.length > 1 && (i.allOf = [...d.map((f) => ({ ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {}, pattern: f.source }))]);
  }
}, Pc = (e, t, n, r) => {
  let i = n, { minimum: a, maximum: o, format: s, multipleOf: l, exclusiveMaximum: u, exclusiveMinimum: d } = e._zod.bag;
  typeof s == "string" && s.includes("int") ? i.type = "integer" : i.type = "number", typeof d == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.minimum = d, i.exclusiveMinimum = !0) : i.exclusiveMinimum = d), typeof a == "number" && (i.minimum = a, typeof d == "number" && t.target !== "draft-04" && (d >= a ? delete i.minimum : delete i.exclusiveMinimum)), typeof u == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.maximum = u, i.exclusiveMaximum = !0) : i.exclusiveMaximum = u), typeof o == "number" && (i.maximum = o, typeof u == "number" && t.target !== "draft-04" && (u <= o ? delete i.maximum : delete i.exclusiveMaximum)), typeof l == "number" && (i.multipleOf = l);
}, Nc = (e, t, n, r) => {
  n.type = "boolean";
}, Zc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
}, Dc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
}, Ec = (e, t, n, r) => {
  t.target === "openapi-3.0" ? (n.type = "string", n.nullable = !0, n.enum = [null]) : n.type = "null";
}, Ac = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("Undefined cannot be represented in JSON Schema");
}, Tc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
}, Rc = (e, t, n, r) => {
  n.not = {};
}, Cc = (e, t, n, r) => {
}, Mc = (e, t, n, r) => {
}, Lc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
}, Fc = (e, t, n, r) => {
  let i = e._zod.def, a = Nn(i.entries);
  a.every((o) => typeof o == "number") && (n.type = "number"), a.every((o) => typeof o == "string") && (n.type = "string"), n.enum = a;
}, Jc = (e, t, n, r) => {
  let i = e._zod.def, a = [];
  for (let o of i.values) if (o === void 0) {
    if (t.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema");
  } else if (typeof o == "bigint") {
    if (t.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
    a.push(Number(o));
  } else a.push(o);
  if (a.length !== 0) if (a.length === 1) {
    let o = a[0];
    n.type = o === null ? "null" : typeof o, t.target === "draft-04" || t.target === "openapi-3.0" ? n.enum = [o] : n.const = o;
  } else
    a.every((o) => typeof o == "number") && (n.type = "number"), a.every((o) => typeof o == "string") && (n.type = "string"), a.every((o) => typeof o == "boolean") && (n.type = "boolean"), a.every((o) => o === null) && (n.type = "null"), n.enum = a;
}, qc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
}, Wc = (e, t, n, r) => {
  let i = n, a = e._zod.pattern;
  if (!a) throw Error("Pattern not found in template literal");
  i.type = "string", i.pattern = a.source;
}, Kc = (e, t, n, r) => {
  let i = n, a = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: o, maximum: s, mime: l } = e._zod.bag;
  o !== void 0 && (a.minLength = o), s !== void 0 && (a.maxLength = s), l ? l.length === 1 ? (a.contentMediaType = l[0], Object.assign(i, a)) : i.anyOf = l.map((u) => ({ ...a, contentMediaType: u })) : Object.assign(i, a);
}, Vc = (e, t, n, r) => {
  n.type = "boolean";
}, Gc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
}, Bc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("Function types cannot be represented in JSON Schema");
}, Hc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
}, Xc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
}, Yc = (e, t, n, r) => {
  if (t.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
}, Qc = (e, t, n, r) => {
  let i = n, a = e._zod.def, { minimum: o, maximum: s } = e._zod.bag;
  typeof o == "number" && (i.minItems = o), typeof s == "number" && (i.maxItems = s), i.type = "array", i.items = D(a.element, t, { ...r, path: [...r.path, "items"] });
}, ed = (e, t, n, r) => {
  let i = n, a = e._zod.def;
  i.type = "object", i.properties = {};
  let o = a.shape;
  for (let u in o) i.properties[u] = D(o[u], t, { ...r, path: [...r.path, "properties", u] });
  let s = new Set(Object.keys(o)), l = new Set([...s].filter((u) => {
    let d = a.shape[u]._zod;
    return t.io === "input" ? d.optin === void 0 : d.optout === void 0;
  }));
  l.size > 0 && (i.required = Array.from(l)), a.catchall?._zod.def.type === "never" ? i.additionalProperties = !1 : a.catchall ? a.catchall && (i.additionalProperties = D(a.catchall, t, { ...r, path: [...r.path, "additionalProperties"] })) : t.io === "output" && (i.additionalProperties = !1);
}, xr = (e, t, n, r) => {
  let i = e._zod.def, a = i.inclusive === !1, o = i.options.map((s, l) => D(s, t, { ...r, path: [...r.path, a ? "oneOf" : "anyOf", l] }));
  a ? n.oneOf = o : n.anyOf = o;
}, td = (e, t, n, r) => {
  let i = e._zod.def, a = D(i.left, t, { ...r, path: [...r.path, "allOf", 0] }), o = D(i.right, t, { ...r, path: [...r.path, "allOf", 1] }), s = (u) => "allOf" in u && Object.keys(u).length === 1, l = [...s(a) ? a.allOf : [a], ...s(o) ? o.allOf : [o]];
  n.allOf = l;
}, id = (e, t, n, r) => {
  let i = n, a = e._zod.def;
  i.type = "array";
  let o = t.target === "draft-2020-12" ? "prefixItems" : "items", s = t.target === "draft-2020-12" || t.target === "openapi-3.0" ? "items" : "additionalItems", l = a.items.map((h, $) => D(h, t, { ...r, path: [...r.path, o, $] })), u = a.rest ? D(a.rest, t, { ...r, path: [...r.path, s, ...t.target === "openapi-3.0" ? [a.items.length] : []] }) : null;
  t.target === "draft-2020-12" ? (i.prefixItems = l, u && (i.items = u)) : t.target === "openapi-3.0" ? (i.items = { anyOf: l }, u && i.items.anyOf.push(u), i.minItems = l.length, !u && (i.maxItems = l.length)) : (i.items = l, u && (i.additionalItems = u));
  let { minimum: d, maximum: f } = e._zod.bag;
  typeof d == "number" && (i.minItems = d), typeof f == "number" && (i.maxItems = f);
}, nd = (e, t, n, r) => {
  let i = n, a = e._zod.def;
  i.type = "object", (t.target === "draft-07" || t.target === "draft-2020-12") && (i.propertyNames = D(a.keyType, t, { ...r, path: [...r.path, "propertyNames"] })), i.additionalProperties = D(a.valueType, t, { ...r, path: [...r.path, "additionalProperties"] });
}, rd = (e, t, n, r) => {
  let i = e._zod.def, a = D(i.innerType, t, r), o = t.seen.get(e);
  t.target === "openapi-3.0" ? (o.ref = i.innerType, n.nullable = !0) : n.anyOf = [a, { type: "null" }];
}, ad = (e, t, n, r) => {
  let i = e._zod.def;
  D(i.innerType, t, r);
  let a = t.seen.get(e);
  a.ref = i.innerType;
}, od = (e, t, n, r) => {
  let i = e._zod.def;
  D(i.innerType, t, r);
  let a = t.seen.get(e);
  a.ref = i.innerType, n.default = JSON.parse(JSON.stringify(i.defaultValue));
}, sd = (e, t, n, r) => {
  let i = e._zod.def;
  D(i.innerType, t, r);
  let a = t.seen.get(e);
  a.ref = i.innerType, t.io === "input" && (n._prefault = JSON.parse(JSON.stringify(i.defaultValue)));
}, ud = (e, t, n, r) => {
  let i = e._zod.def;
  D(i.innerType, t, r);
  let a = t.seen.get(e);
  a.ref = i.innerType;
  let o;
  try {
    o = i.catchValue(void 0);
  } catch {
    throw Error("Dynamic catch values are not supported in JSON Schema");
  }
  n.default = o;
}, ld = (e, t, n, r) => {
  let i = e._zod.def, a = t.io === "input" ? i.in._zod.def.type === "transform" ? i.out : i.in : i.out;
  D(a, t, r);
  let o = t.seen.get(e);
  o.ref = a;
}, cd = (e, t, n, r) => {
  let i = e._zod.def;
  D(i.innerType, t, r);
  let a = t.seen.get(e);
  a.ref = i.innerType, n.readOnly = !0;
}, dd = (e, t, n, r) => {
  let i = e._zod.def;
  D(i.innerType, t, r);
  let a = t.seen.get(e);
  a.ref = i.innerType;
}, md = (e, t, n, r) => {
  let i = e._zod.def;
  D(i.innerType, t, r);
  let a = t.seen.get(e);
  a.ref = i.innerType;
}, pd = (e, t, n, r) => {
  let i = e._zod.innerType;
  D(i, t, r);
  let a = t.seen.get(e);
  a.ref = i;
}, hn = { string: jc, number: Pc, boolean: Nc, bigint: Zc, symbol: Dc, null: Ec, undefined: Ac, void: Tc, never: Rc, any: Cc, unknown: Mc, date: Lc, enum: Fc, literal: Jc, nan: qc, template_literal: Wc, file: Kc, success: Vc, custom: Gc, function: Bc, transform: Hc, map: Xc, set: Yc, array: Qc, object: ed, union: xr, intersection: td, tuple: id, record: nd, nullable: rd, nonoptional: ad, default: od, prefault: sd, catch: ud, pipe: ld, readonly: cd, promise: dd, optional: md, lazy: pd };
function fd(e, t) {
  if ("_idmap" in e) {
    let r = e, i = Je({ ...t, processors: hn }), a = {};
    for (let l of r._idmap.entries()) {
      let [u, d] = l;
      D(d, i);
    }
    let o = {}, s = { registry: r, uri: t?.uri, defs: a };
    i.external = s;
    for (let l of r._idmap.entries()) {
      let [u, d] = l;
      qe(i, d), o[u] = We(i, d);
    }
    if (Object.keys(a).length > 0) {
      let l = i.target === "draft-2020-12" ? "$defs" : "definitions";
      o.__shared = { [l]: a };
    }
    return { schemas: o };
  }
  let n = Je({ ...t, processors: hn });
  return D(e, n), qe(n, e), We(n, e);
}
class nI {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(t) {
    this.ctx.counter = t;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(t) {
    let n = t?.target ?? "draft-2020-12";
    n === "draft-4" && (n = "draft-04"), n === "draft-7" && (n = "draft-07"), this.ctx = Je({ processors: hn, target: n, ...t?.metadata && { metadata: t.metadata }, ...t?.unrepresentable && { unrepresentable: t.unrepresentable }, ...t?.override && { override: t.override }, ...t?.io && { io: t.io } });
  }
  process(t, n = { path: [], schemaPath: [] }) {
    return D(t, this.ctx, n);
  }
  emit(t, n) {
    n && (n.cycles && (this.ctx.cycles = n.cycles), n.reused && (this.ctx.reused = n.reused), n.external && (this.ctx.external = n.external)), qe(this.ctx, t);
    let r = We(this.ctx, t), { "~standard": i, ...a } = r;
    return a;
  }
}
var rI = {}, gd = {};
_e(gd, { xor: () => wm, xid: () => Vd, void: () => bm, uuidv7: () => Cd, uuidv6: () => Rd, uuidv4: () => Td, uuid: () => Ad, url: () => Md, unknown: () => Ne, union: () => Yi, undefined: () => hm, ulid: () => Kd, uint64: () => fm, uint32: () => dm, tuple: () => Hr, transform: () => en, templateLiteral: () => Tm, symbol: () => gm, superRefine: () => $a, success: () => Dm, stringbool: () => qm, stringFormat: () => rm, string: () => ni, strictObject: () => Im, set: () => Um, refine: () => ya, record: () => Xr, readonly: () => fa, promise: () => Rm, preprocess: () => Km, prefault: () => sa, pipe: () => st, partialRecord: () => zm, optional: () => at, object: () => $m, number: () => Dr, nullish: () => Zm, nullable: () => ot, null: () => Cr, nonoptional: () => ua, never: () => Hi, nativeEnum: () => jm, nanoid: () => Jd, nan: () => Em, meta: () => Fm, map: () => Om, mac: () => Hd, looseRecord: () => xm, looseObject: () => km, literal: () => Pm, lazy: () => va, ksuid: () => Gd, keyof: () => ym, jwt: () => nm, json: () => Wm, ipv6: () => Xd, ipv4: () => Bd, intersection: () => Gr, int64: () => pm, int32: () => cm, int: () => ri, instanceof: () => Jm, httpUrl: () => Ld, hostname: () => am, hex: () => om, hash: () => sm, guid: () => Ed, function: () => ai, float64: () => lm, float32: () => um, file: () => Nm, enum: () => Qi, emoji: () => Fd, email: () => Dd, e164: () => im, discriminatedUnion: () => Sm, describe: () => Lm, date: () => _m, custom: () => Mm, cuid2: () => Wd, cuid: () => qd, codec: () => Am, cidrv6: () => Qd, cidrv4: () => Yd, check: () => Cm, catch: () => da, boolean: () => Er, bigint: () => mm, base64url: () => tm, base64: () => em, array: () => Dt, any: () => vm, _function: () => ai, _default: () => aa, _ZodString: () => Ni, ZodXor: () => Wr, ZodXID: () => Ci, ZodVoid: () => Jr, ZodUnknown: () => Lr, ZodUnion: () => At, ZodUndefined: () => Tr, ZodUUID: () => he, ZodURL: () => jt, ZodULID: () => Ri, ZodType: () => z, ZodTuple: () => Br, ZodTransform: () => ia, ZodTemplateLiteral: () => ga, ZodSymbol: () => Ar, ZodSuccess: () => la, ZodStringFormat: () => A, ZodString: () => Ut, ZodSet: () => Qr, ZodRecord: () => Tt, ZodReadonly: () => pa, ZodPromise: () => ba, ZodPrefault: () => oa, ZodPipe: () => rn, ZodOptional: () => tn, ZodObject: () => Et, ZodNumberFormat: () => Ae, ZodNumber: () => Pt, ZodNullable: () => na, ZodNull: () => Rr, ZodNonOptional: () => nn, ZodNever: () => Fr, ZodNanoID: () => Ei, ZodNaN: () => ma, ZodMap: () => Yr, ZodMAC: () => Zr, ZodLiteral: () => ea, ZodLazy: () => ha, ZodKSUID: () => Mi, ZodJWT: () => Gi, ZodIntersection: () => Vr, ZodIPv6: () => Fi, ZodIPv4: () => Li, ZodGUID: () => rt, ZodFunction: () => _a, ZodFile: () => ta, ZodEnum: () => Ke, ZodEmoji: () => Di, ZodEmail: () => Zi, ZodE164: () => Vi, ZodDiscriminatedUnion: () => Kr, ZodDefault: () => ra, ZodDate: () => Xi, ZodCustomStringFormat: () => Ge, ZodCustom: () => Rt, ZodCodec: () => an, ZodCatch: () => ca, ZodCUID2: () => Ti, ZodCUID: () => Ai, ZodCIDRv6: () => qi, ZodCIDRv4: () => Ji, ZodBoolean: () => Nt, ZodBigIntFormat: () => Bi, ZodBigInt: () => Zt, ZodBase64URL: () => Ki, ZodBase64: () => Wi, ZodArray: () => qr, ZodAny: () => Mr });
var hd = {};
_e(hd, { uppercase: () => Ii, trim: () => Oi, toUpperCase: () => ji, toLowerCase: () => Ui, startsWith: () => wi, slugify: () => Pi, size: () => _i, regex: () => yi, property: () => zr, positive: () => Ir, overwrite: () => ye, normalize: () => xi, nonpositive: () => wr, nonnegative: () => Sr, negative: () => kr, multipleOf: () => Le, minSize: () => Fe, minLength: () => Pe, mime: () => zi, maxSize: () => St, maxLength: () => zt, lte: () => le, lt: () => ke, lowercase: () => $i, length: () => xt, includes: () => ki, gte: () => ie, gt: () => we, endsWith: () => Si });
var Or = {};
_e(Or, { time: () => _d, duration: () => yd, datetime: () => vd, date: () => bd, ZodISOTime: () => Pr, ZodISODuration: () => Nr, ZodISODateTime: () => Ur, ZodISODate: () => jr });
var Ur = m("ZodISODateTime", (e, t) => {
  Eu.init(e, t), A.init(e, t);
});
function vd(e) {
  return Vl(Ur, e);
}
var jr = m("ZodISODate", (e, t) => {
  Au.init(e, t), A.init(e, t);
});
function bd(e) {
  return Gl(jr, e);
}
var Pr = m("ZodISOTime", (e, t) => {
  Tu.init(e, t), A.init(e, t);
});
function _d(e) {
  return Bl(Pr, e);
}
var Nr = m("ZodISODuration", (e, t) => {
  Ru.init(e, t), A.init(e, t);
});
function yd(e) {
  return Hl(Nr, e);
}
var $d = (e, t) => {
  Dn.init(e, t), e.name = "ZodError", Object.defineProperties(e, { format: { value: (n) => An(e, n) }, flatten: { value: (n) => En(e, n) }, addIssue: { value: (n) => {
    e.issues.push(n), e.message = JSON.stringify(e.issues, Yt, 2);
  } }, addIssues: { value: (n) => {
    e.issues.push(...n), e.message = JSON.stringify(e.issues, Yt, 2);
  } }, isEmpty: { get() {
    return e.issues.length === 0;
  } } });
}, aI = m("ZodError", $d), ue = m("ZodError", $d, { Parent: Error }), Id = vt(ue), kd = bt(ue), wd = _t(ue), Sd = yt(ue), zd = Tn(ue), xd = Rn(ue), Od = Cn(ue), Ud = Mn(ue), jd = Ln(ue), Pd = Fn(ue), Nd = Jn(ue), Zd = qn(ue), z = m("ZodType", (e, t) => (S.init(e, t), Object.assign(e["~standard"], { jsonSchema: { input: nt(e, "input"), output: nt(e, "output") } }), e.toJSONSchema = Uc(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(x.mergeDefs(t, { checks: [...t.checks ?? [], ...n.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)] })), e.clone = (n, r) => pe(e, n, r), e.brand = () => e, e.register = (n, r) => (n.add(e, r), e), e.parse = (n, r) => Id(e, n, r, { callee: e.parse }), e.safeParse = (n, r) => wd(e, n, r), e.parseAsync = async (n, r) => kd(e, n, r, { callee: e.parseAsync }), e.safeParseAsync = async (n, r) => Sd(e, n, r), e.spa = e.safeParseAsync, e.encode = (n, r) => zd(e, n, r), e.decode = (n, r) => xd(e, n, r), e.encodeAsync = async (n, r) => Od(e, n, r), e.decodeAsync = async (n, r) => Ud(e, n, r), e.safeEncode = (n, r) => jd(e, n, r), e.safeDecode = (n, r) => Pd(e, n, r), e.safeEncodeAsync = async (n, r) => Nd(e, n, r), e.safeDecodeAsync = async (n, r) => Zd(e, n, r), e.refine = (n, r) => e.check(ya(n, r)), e.superRefine = (n) => e.check($a(n)), e.overwrite = (n) => e.check(ye(n)), e.optional = () => at(e), e.nullable = () => ot(e), e.nullish = () => at(ot(e)), e.nonoptional = (n) => ua(e, n), e.array = () => Dt(e), e.or = (n) => Yi([e, n]), e.and = (n) => Gr(e, n), e.transform = (n) => st(e, en(n)), e.default = (n) => aa(e, n), e.prefault = (n) => sa(e, n), e.catch = (n) => da(e, n), e.pipe = (n) => st(e, n), e.readonly = () => fa(e), e.describe = (n) => {
  let r = e.clone();
  return ge.add(r, { description: n }), r;
}, Object.defineProperty(e, "description", { get() {
  return ge.get(e)?.description;
}, configurable: !0 }), e.meta = (...n) => {
  if (n.length === 0) return ge.get(e);
  let r = e.clone();
  return ge.add(r, n[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), Ni = m("_ZodString", (e, t) => {
  wt.init(e, t), z.init(e, t), e._zod.processJSONSchema = (r, i, a) => jc(e, r, i);
  let n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...r) => e.check(yi(...r)), e.includes = (...r) => e.check(ki(...r)), e.startsWith = (...r) => e.check(wi(...r)), e.endsWith = (...r) => e.check(Si(...r)), e.min = (...r) => e.check(Pe(...r)), e.max = (...r) => e.check(zt(...r)), e.length = (...r) => e.check(xt(...r)), e.nonempty = (...r) => e.check(Pe(1, ...r)), e.lowercase = (r) => e.check($i(r)), e.uppercase = (r) => e.check(Ii(r)), e.trim = () => e.check(Oi()), e.normalize = (...r) => e.check(xi(...r)), e.toLowerCase = () => e.check(Ui()), e.toUpperCase = () => e.check(ji()), e.slugify = () => e.check(Pi());
}), Ut = m("ZodString", (e, t) => {
  wt.init(e, t), Ni.init(e, t), e.email = (n) => e.check(ir(Zi, n)), e.url = (n) => e.check(bi(jt, n)), e.jwt = (n) => e.check($r(Gi, n)), e.emoji = (n) => e.check(sr(Di, n)), e.guid = (n) => e.check(ii(rt, n)), e.uuid = (n) => e.check(nr(he, n)), e.uuidv4 = (n) => e.check(rr(he, n)), e.uuidv6 = (n) => e.check(ar(he, n)), e.uuidv7 = (n) => e.check(or(he, n)), e.nanoid = (n) => e.check(ur(Ei, n)), e.guid = (n) => e.check(ii(rt, n)), e.cuid = (n) => e.check(lr(Ai, n)), e.cuid2 = (n) => e.check(cr(Ti, n)), e.ulid = (n) => e.check(dr(Ri, n)), e.base64 = (n) => e.check(br(Wi, n)), e.base64url = (n) => e.check(_r(Ki, n)), e.xid = (n) => e.check(mr(Ci, n)), e.ksuid = (n) => e.check(pr(Mi, n)), e.ipv4 = (n) => e.check(fr(Li, n)), e.ipv6 = (n) => e.check(gr(Fi, n)), e.cidrv4 = (n) => e.check(hr(Ji, n)), e.cidrv6 = (n) => e.check(vr(qi, n)), e.e164 = (n) => e.check(yr(Vi, n)), e.datetime = (n) => e.check(vd(n)), e.date = (n) => e.check(bd(n)), e.time = (n) => e.check(_d(n)), e.duration = (n) => e.check(yd(n));
});
function ni(e) {
  return Jl(Ut, e);
}
var A = m("ZodStringFormat", (e, t) => {
  E.init(e, t), Ni.init(e, t);
}), Zi = m("ZodEmail", (e, t) => {
  zu.init(e, t), A.init(e, t);
});
function Dd(e) {
  return ir(Zi, e);
}
var rt = m("ZodGUID", (e, t) => {
  wu.init(e, t), A.init(e, t);
});
function Ed(e) {
  return ii(rt, e);
}
var he = m("ZodUUID", (e, t) => {
  Su.init(e, t), A.init(e, t);
});
function Ad(e) {
  return nr(he, e);
}
function Td(e) {
  return rr(he, e);
}
function Rd(e) {
  return ar(he, e);
}
function Cd(e) {
  return or(he, e);
}
var jt = m("ZodURL", (e, t) => {
  xu.init(e, t), A.init(e, t);
});
function Md(e) {
  return bi(jt, e);
}
function Ld(e) {
  return bi(jt, { protocol: /^https?$/, hostname: Ee.domain, ...x.normalizeParams(e) });
}
var Di = m("ZodEmoji", (e, t) => {
  Ou.init(e, t), A.init(e, t);
});
function Fd(e) {
  return sr(Di, e);
}
var Ei = m("ZodNanoID", (e, t) => {
  Uu.init(e, t), A.init(e, t);
});
function Jd(e) {
  return ur(Ei, e);
}
var Ai = m("ZodCUID", (e, t) => {
  ju.init(e, t), A.init(e, t);
});
function qd(e) {
  return lr(Ai, e);
}
var Ti = m("ZodCUID2", (e, t) => {
  Pu.init(e, t), A.init(e, t);
});
function Wd(e) {
  return cr(Ti, e);
}
var Ri = m("ZodULID", (e, t) => {
  Nu.init(e, t), A.init(e, t);
});
function Kd(e) {
  return dr(Ri, e);
}
var Ci = m("ZodXID", (e, t) => {
  Zu.init(e, t), A.init(e, t);
});
function Vd(e) {
  return mr(Ci, e);
}
var Mi = m("ZodKSUID", (e, t) => {
  Du.init(e, t), A.init(e, t);
});
function Gd(e) {
  return pr(Mi, e);
}
var Li = m("ZodIPv4", (e, t) => {
  Cu.init(e, t), A.init(e, t);
});
function Bd(e) {
  return fr(Li, e);
}
var Zr = m("ZodMAC", (e, t) => {
  Lu.init(e, t), A.init(e, t);
});
function Hd(e) {
  return Wl(Zr, e);
}
var Fi = m("ZodIPv6", (e, t) => {
  Mu.init(e, t), A.init(e, t);
});
function Xd(e) {
  return gr(Fi, e);
}
var Ji = m("ZodCIDRv4", (e, t) => {
  Fu.init(e, t), A.init(e, t);
});
function Yd(e) {
  return hr(Ji, e);
}
var qi = m("ZodCIDRv6", (e, t) => {
  Ju.init(e, t), A.init(e, t);
});
function Qd(e) {
  return vr(qi, e);
}
var Wi = m("ZodBase64", (e, t) => {
  qu.init(e, t), A.init(e, t);
});
function em(e) {
  return br(Wi, e);
}
var Ki = m("ZodBase64URL", (e, t) => {
  Ku.init(e, t), A.init(e, t);
});
function tm(e) {
  return _r(Ki, e);
}
var Vi = m("ZodE164", (e, t) => {
  Vu.init(e, t), A.init(e, t);
});
function im(e) {
  return yr(Vi, e);
}
var Gi = m("ZodJWT", (e, t) => {
  Bu.init(e, t), A.init(e, t);
});
function nm(e) {
  return $r(Gi, e);
}
var Ge = m("ZodCustomStringFormat", (e, t) => {
  Hu.init(e, t), A.init(e, t);
});
function rm(e, t, n = {}) {
  return Ot(Ge, e, t, n);
}
function am(e) {
  return Ot(Ge, "hostname", Ee.hostname, e);
}
function om(e) {
  return Ot(Ge, "hex", Ee.hex, e);
}
function sm(e, t) {
  let n = t?.enc ?? "hex", r = `${e}_${n}`, i = Ee[r];
  if (!i) throw Error(`Unrecognized hash format: ${r}`);
  return Ot(Ge, r, i, t);
}
var Pt = m("ZodNumber", (e, t) => {
  Bn.init(e, t), z.init(e, t), e._zod.processJSONSchema = (r, i, a) => Pc(e, r, i), e.gt = (r, i) => e.check(we(r, i)), e.gte = (r, i) => e.check(ie(r, i)), e.min = (r, i) => e.check(ie(r, i)), e.lt = (r, i) => e.check(ke(r, i)), e.lte = (r, i) => e.check(le(r, i)), e.max = (r, i) => e.check(le(r, i)), e.int = (r) => e.check(ri(r)), e.safe = (r) => e.check(ri(r)), e.positive = (r) => e.check(we(0, r)), e.nonnegative = (r) => e.check(ie(0, r)), e.negative = (r) => e.check(ke(0, r)), e.nonpositive = (r) => e.check(le(0, r)), e.multipleOf = (r, i) => e.check(Le(r, i)), e.step = (r, i) => e.check(Le(r, i)), e.finite = () => e;
  let n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function Dr(e) {
  return Xl(Pt, e);
}
var Ae = m("ZodNumberFormat", (e, t) => {
  Xu.init(e, t), Pt.init(e, t);
});
function ri(e) {
  return Ql(Ae, e);
}
function um(e) {
  return ec(Ae, e);
}
function lm(e) {
  return tc(Ae, e);
}
function cm(e) {
  return ic(Ae, e);
}
function dm(e) {
  return nc(Ae, e);
}
var Nt = m("ZodBoolean", (e, t) => {
  Hn.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Nc(e, n, r);
});
function Er(e) {
  return rc(Nt, e);
}
var Zt = m("ZodBigInt", (e, t) => {
  Xn.init(e, t), z.init(e, t), e._zod.processJSONSchema = (r, i, a) => Zc(e, r), e.gte = (r, i) => e.check(ie(r, i)), e.min = (r, i) => e.check(ie(r, i)), e.gt = (r, i) => e.check(we(r, i)), e.gte = (r, i) => e.check(ie(r, i)), e.min = (r, i) => e.check(ie(r, i)), e.lt = (r, i) => e.check(ke(r, i)), e.lte = (r, i) => e.check(le(r, i)), e.max = (r, i) => e.check(le(r, i)), e.positive = (r) => e.check(we(BigInt(0), r)), e.negative = (r) => e.check(ke(BigInt(0), r)), e.nonpositive = (r) => e.check(le(BigInt(0), r)), e.nonnegative = (r) => e.check(ie(BigInt(0), r)), e.multipleOf = (r, i) => e.check(Le(r, i));
  let n = e._zod.bag;
  e.minValue = n.minimum ?? null, e.maxValue = n.maximum ?? null, e.format = n.format ?? null;
});
function mm(e) {
  return oc(Zt, e);
}
var Bi = m("ZodBigIntFormat", (e, t) => {
  Yu.init(e, t), Zt.init(e, t);
});
function pm(e) {
  return uc(Bi, e);
}
function fm(e) {
  return lc(Bi, e);
}
var Ar = m("ZodSymbol", (e, t) => {
  Qu.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Dc(e, n);
});
function gm(e) {
  return cc(Ar, e);
}
var Tr = m("ZodUndefined", (e, t) => {
  el.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Ac(e, n);
});
function hm(e) {
  return dc(Tr, e);
}
var Rr = m("ZodNull", (e, t) => {
  tl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Ec(e, n, r);
});
function Cr(e) {
  return mc(Rr, e);
}
var Mr = m("ZodAny", (e, t) => {
  il.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Cc();
});
function vm() {
  return pc(Mr);
}
var Lr = m("ZodUnknown", (e, t) => {
  nl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Mc();
});
function Ne() {
  return fc(Lr);
}
var Fr = m("ZodNever", (e, t) => {
  rl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Rc(e, n, r);
});
function Hi(e) {
  return gc(Fr, e);
}
var Jr = m("ZodVoid", (e, t) => {
  al.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Tc(e, n);
});
function bm(e) {
  return hc(Jr, e);
}
var Xi = m("ZodDate", (e, t) => {
  ol.init(e, t), z.init(e, t), e._zod.processJSONSchema = (r, i, a) => Lc(e, r), e.min = (r, i) => e.check(ie(r, i)), e.max = (r, i) => e.check(le(r, i));
  let n = e._zod.bag;
  e.minDate = n.minimum ? new Date(n.minimum) : null, e.maxDate = n.maximum ? new Date(n.maximum) : null;
});
function _m(e) {
  return vc(Xi, e);
}
var qr = m("ZodArray", (e, t) => {
  sl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Qc(e, n, r, i), e.element = t.element, e.min = (n, r) => e.check(Pe(n, r)), e.nonempty = (n) => e.check(Pe(1, n)), e.max = (n, r) => e.check(zt(n, r)), e.length = (n, r) => e.check(xt(n, r)), e.unwrap = () => e.element;
});
function Dt(e, t) {
  return yc(qr, e, t);
}
function ym(e) {
  let t = e._zod.def.shape;
  return Qi(Object.keys(t));
}
var Et = m("ZodObject", (e, t) => {
  dl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => ed(e, n, r, i), x.defineLazy(e, "shape", () => t.shape), e.keyof = () => Qi(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: Ne() }), e.loose = () => e.clone({ ...e._zod.def, catchall: Ne() }), e.strict = () => e.clone({ ...e._zod.def, catchall: Hi() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => x.extend(e, n), e.safeExtend = (n) => x.safeExtend(e, n), e.merge = (n) => x.merge(e, n), e.pick = (n) => x.pick(e, n), e.omit = (n) => x.omit(e, n), e.partial = (...n) => x.partial(tn, e, n[0]), e.required = (...n) => x.required(nn, e, n[0]);
});
function $m(e, t) {
  let n = { type: "object", shape: e ?? {}, ...x.normalizeParams(t) };
  return new Et(n);
}
function Im(e, t) {
  return new Et({ type: "object", shape: e, catchall: Hi(), ...x.normalizeParams(t) });
}
function km(e, t) {
  return new Et({ type: "object", shape: e, catchall: Ne(), ...x.normalizeParams(t) });
}
var At = m("ZodUnion", (e, t) => {
  vi.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => xr(e, n, r, i), e.options = t.options;
});
function Yi(e, t) {
  return new At({ type: "union", options: e, ...x.normalizeParams(t) });
}
var Wr = m("ZodXor", (e, t) => {
  At.init(e, t), ml.init(e, t), e._zod.processJSONSchema = (n, r, i) => xr(e, n, r, i), e.options = t.options;
});
function wm(e, t) {
  return new Wr({ type: "union", options: e, inclusive: !1, ...x.normalizeParams(t) });
}
var Kr = m("ZodDiscriminatedUnion", (e, t) => {
  At.init(e, t), pl.init(e, t);
});
function Sm(e, t, n) {
  return new Kr({ type: "union", options: t, discriminator: e, ...x.normalizeParams(n) });
}
var Vr = m("ZodIntersection", (e, t) => {
  fl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => td(e, n, r, i);
});
function Gr(e, t) {
  return new Vr({ type: "intersection", left: e, right: t });
}
var Br = m("ZodTuple", (e, t) => {
  Yn.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => id(e, n, r, i), e.rest = (n) => e.clone({ ...e._zod.def, rest: n });
});
function Hr(e, t, n) {
  let r = t instanceof S, i = r ? n : t;
  return new Br({ type: "tuple", items: e, rest: r ? t : null, ...x.normalizeParams(i) });
}
var Tt = m("ZodRecord", (e, t) => {
  gl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => nd(e, n, r, i), e.keyType = t.keyType, e.valueType = t.valueType;
});
function Xr(e, t, n) {
  return new Tt({ type: "record", keyType: e, valueType: t, ...x.normalizeParams(n) });
}
function zm(e, t, n) {
  let r = pe(e);
  return r._zod.values = void 0, new Tt({ type: "record", keyType: r, valueType: t, ...x.normalizeParams(n) });
}
function xm(e, t, n) {
  return new Tt({ type: "record", keyType: e, valueType: t, mode: "loose", ...x.normalizeParams(n) });
}
var Yr = m("ZodMap", (e, t) => {
  hl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Xc(e, n), e.keyType = t.keyType, e.valueType = t.valueType;
});
function Om(e, t, n) {
  return new Yr({ type: "map", keyType: e, valueType: t, ...x.normalizeParams(n) });
}
var Qr = m("ZodSet", (e, t) => {
  vl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Yc(e, n), e.min = (...n) => e.check(Fe(...n)), e.nonempty = (n) => e.check(Fe(1, n)), e.max = (...n) => e.check(St(...n)), e.size = (...n) => e.check(_i(...n));
});
function Um(e, t) {
  return new Qr({ type: "set", valueType: e, ...x.normalizeParams(t) });
}
var Ke = m("ZodEnum", (e, t) => {
  bl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (r, i, a) => Fc(e, r, i), e.enum = t.entries, e.options = Object.values(t.entries);
  let n = new Set(Object.keys(t.entries));
  e.extract = (r, i) => {
    let a = {};
    for (let o of r) if (n.has(o)) a[o] = t.entries[o];
    else throw Error(`Key ${o} not found in enum`);
    return new Ke({ ...t, checks: [], ...x.normalizeParams(i), entries: a });
  }, e.exclude = (r, i) => {
    let a = { ...t.entries };
    for (let o of r) if (n.has(o)) delete a[o];
    else throw Error(`Key ${o} not found in enum`);
    return new Ke({ ...t, checks: [], ...x.normalizeParams(i), entries: a });
  };
});
function Qi(e, t) {
  let n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new Ke({ type: "enum", entries: n, ...x.normalizeParams(t) });
}
function jm(e, t) {
  return new Ke({ type: "enum", entries: e, ...x.normalizeParams(t) });
}
var ea = m("ZodLiteral", (e, t) => {
  _l.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Jc(e, n, r), e.values = new Set(t.values), Object.defineProperty(e, "value", { get() {
    if (t.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return t.values[0];
  } });
});
function Pm(e, t) {
  return new ea({ type: "literal", values: Array.isArray(e) ? e : [e], ...x.normalizeParams(t) });
}
var ta = m("ZodFile", (e, t) => {
  yl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Kc(e, n, r), e.min = (n, r) => e.check(Fe(n, r)), e.max = (n, r) => e.check(St(n, r)), e.mime = (n, r) => e.check(zi(Array.isArray(n) ? n : [n], r));
});
function Nm(e) {
  return $c(ta, e);
}
var ia = m("ZodTransform", (e, t) => {
  $l.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Hc(e, n), e._zod.parse = (n, r) => {
    if (r.direction === "backward") throw new pi(e.constructor.name);
    n.addIssue = (a) => {
      if (typeof a == "string") n.issues.push(x.issue(a, n.value, t));
      else {
        let o = a;
        o.fatal && (o.continue = !1), o.code ?? (o.code = "custom"), o.input ?? (o.input = n.value), o.inst ?? (o.inst = e), n.issues.push(x.issue(o));
      }
    };
    let i = t.transform(n.value, n);
    return i instanceof Promise ? i.then((a) => (n.value = a, n)) : (n.value = i, n);
  };
});
function en(e) {
  return new ia({ type: "transform", transform: e });
}
var tn = m("ZodOptional", (e, t) => {
  Il.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => md(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function at(e) {
  return new tn({ type: "optional", innerType: e });
}
var na = m("ZodNullable", (e, t) => {
  kl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => rd(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function ot(e) {
  return new na({ type: "nullable", innerType: e });
}
function Zm(e) {
  return at(ot(e));
}
var ra = m("ZodDefault", (e, t) => {
  wl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => od(e, n, r, i), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function aa(e, t) {
  return new ra({ type: "default", innerType: e, get defaultValue() {
    return typeof t == "function" ? t() : x.shallowClone(t);
  } });
}
var oa = m("ZodPrefault", (e, t) => {
  Sl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => sd(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function sa(e, t) {
  return new oa({ type: "prefault", innerType: e, get defaultValue() {
    return typeof t == "function" ? t() : x.shallowClone(t);
  } });
}
var nn = m("ZodNonOptional", (e, t) => {
  zl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => ad(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function ua(e, t) {
  return new nn({ type: "nonoptional", innerType: e, ...x.normalizeParams(t) });
}
var la = m("ZodSuccess", (e, t) => {
  xl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Vc(e, n, r), e.unwrap = () => e._zod.def.innerType;
});
function Dm(e) {
  return new la({ type: "success", innerType: e });
}
var ca = m("ZodCatch", (e, t) => {
  Ol.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => ud(e, n, r, i), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function da(e, t) {
  return new ca({ type: "catch", innerType: e, catchValue: typeof t == "function" ? t : () => t });
}
var ma = m("ZodNaN", (e, t) => {
  Ul.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => qc(e, n);
});
function Em(e) {
  return _c(ma, e);
}
var rn = m("ZodPipe", (e, t) => {
  jl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => ld(e, n, r, i), e.in = t.in, e.out = t.out;
});
function st(e, t) {
  return new rn({ type: "pipe", in: e, out: t });
}
var an = m("ZodCodec", (e, t) => {
  rn.init(e, t), Qn.init(e, t);
});
function Am(e, t, n) {
  return new an({ type: "pipe", in: e, out: t, transform: n.decode, reverseTransform: n.encode });
}
var pa = m("ZodReadonly", (e, t) => {
  Pl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => cd(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function fa(e) {
  return new pa({ type: "readonly", innerType: e });
}
var ga = m("ZodTemplateLiteral", (e, t) => {
  Nl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Wc(e, n, r);
});
function Tm(e, t) {
  return new ga({ type: "template_literal", parts: e, ...x.normalizeParams(t) });
}
var ha = m("ZodLazy", (e, t) => {
  El.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => pd(e, n, r, i), e.unwrap = () => e._zod.def.getter();
});
function va(e) {
  return new ha({ type: "lazy", getter: e });
}
var ba = m("ZodPromise", (e, t) => {
  Dl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => dd(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function Rm(e) {
  return new ba({ type: "promise", innerType: e });
}
var _a = m("ZodFunction", (e, t) => {
  Zl.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Bc(e, n);
});
function ai(e) {
  return new _a({ type: "function", input: Array.isArray(e?.input) ? Hr(e?.input) : e?.input ?? Dt(Ne()), output: e?.output ?? Ne() });
}
var Rt = m("ZodCustom", (e, t) => {
  Al.init(e, t), z.init(e, t), e._zod.processJSONSchema = (n, r, i) => Gc(e, n);
});
function Cm(e) {
  let t = new F({ check: "custom" });
  return t._zod.check = e, t;
}
function Mm(e, t) {
  return Ic(Rt, e ?? (() => !0), t);
}
function ya(e, t = {}) {
  return kc(Rt, e, t);
}
function $a(e) {
  return wc(e);
}
var Lm = zc, Fm = xc;
function Jm(e, t = { error: `Input not instance of ${e.name}` }) {
  let n = new Rt({ type: "custom", check: "custom", fn: (r) => r instanceof e, abort: !0, ...x.normalizeParams(t) });
  return n._zod.bag.Class = e, n;
}
var qm = (...e) => Oc({ Codec: an, Boolean: Nt, String: Ut }, ...e);
function Wm(e) {
  let t = va(() => Yi([ni(e), Dr(), Er(), Cr(), Dt(t), Xr(ni(), t)]));
  return t;
}
function Km(e, t) {
  return st(en(e), t);
}
var oI = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" };
function sI(e) {
  Q({ customError: e });
}
function uI() {
  return Q().customError;
}
var vn;
vn || (vn = {});
var _ = { ...gd, ...hd, iso: Or };
function lI(e, t) {
  let n = e.$schema;
  return n === "https://json-schema.org/draft/2020-12/schema" ? "draft-2020-12" : n === "http://json-schema.org/draft-07/schema#" ? "draft-7" : n === "http://json-schema.org/draft-04/schema#" ? "draft-4" : t ?? "draft-2020-12";
}
function cI(e, t) {
  if (!e.startsWith("#")) throw Error("External $ref is not supported, only local refs (#/...) are allowed");
  let n = e.slice(1).split("/").filter(Boolean);
  if (n.length === 0) return t.rootSchema;
  let r = t.version === "draft-2020-12" ? "$defs" : "definitions";
  if (n[0] === r) {
    let i = n[1];
    if (!i || !t.defs[i]) throw Error(`Reference not found: ${e}`);
    return t.defs[i];
  }
  throw Error(`Reference not found: ${e}`);
}
function Vm(e, t) {
  if (e.not !== void 0) {
    if (typeof e.not == "object" && Object.keys(e.not).length === 0) return _.never();
    throw Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (e.unevaluatedItems !== void 0) throw Error("unevaluatedItems is not supported");
  if (e.unevaluatedProperties !== void 0) throw Error("unevaluatedProperties is not supported");
  if (e.if !== void 0 || e.then !== void 0 || e.else !== void 0) throw Error("Conditional schemas (if/then/else) are not supported");
  if (e.dependentSchemas !== void 0 || e.dependentRequired !== void 0) throw Error("dependentSchemas and dependentRequired are not supported");
  if (e.$ref) {
    let i = e.$ref;
    if (t.refs.has(i)) return t.refs.get(i);
    if (t.processing.has(i)) return _.lazy(() => {
      if (!t.refs.has(i)) throw Error(`Circular reference not resolved: ${i}`);
      return t.refs.get(i);
    });
    t.processing.add(i);
    let a = cI(i, t), o = Y(a, t);
    return t.refs.set(i, o), t.processing.delete(i), o;
  }
  if (e.enum !== void 0) {
    let i = e.enum;
    if (t.version === "openapi-3.0" && e.nullable === !0 && i.length === 1 && i[0] === null) return _.null();
    if (i.length === 0) return _.never();
    if (i.length === 1) return _.literal(i[0]);
    if (i.every((o) => typeof o == "string")) return _.enum(i);
    let a = i.map((o) => _.literal(o));
    return a.length < 2 ? a[0] : _.union([a[0], a[1], ...a.slice(2)]);
  }
  if (e.const !== void 0) return _.literal(e.const);
  let n = e.type;
  if (Array.isArray(n)) {
    let i = n.map((a) => {
      let o = { ...e, type: a };
      return Vm(o, t);
    });
    return i.length === 0 ? _.never() : i.length === 1 ? i[0] : _.union(i);
  }
  if (!n) return _.any();
  let r;
  switch (n) {
    case "string": {
      let i = _.string();
      if (e.format) {
        let a = e.format;
        a === "email" ? i = i.check(_.email()) : a === "uri" || a === "uri-reference" ? i = i.check(_.url()) : a === "uuid" || a === "guid" ? i = i.check(_.uuid()) : a === "date-time" ? i = i.check(_.iso.datetime()) : a === "date" ? i = i.check(_.iso.date()) : a === "time" ? i = i.check(_.iso.time()) : a === "duration" ? i = i.check(_.iso.duration()) : a === "ipv4" ? i = i.check(_.ipv4()) : a === "ipv6" ? i = i.check(_.ipv6()) : a === "mac" ? i = i.check(_.mac()) : a === "cidr" ? i = i.check(_.cidrv4()) : a === "cidr-v6" ? i = i.check(_.cidrv6()) : a === "base64" ? i = i.check(_.base64()) : a === "base64url" ? i = i.check(_.base64url()) : a === "e164" ? i = i.check(_.e164()) : a === "jwt" ? i = i.check(_.jwt()) : a === "emoji" ? i = i.check(_.emoji()) : a === "nanoid" ? i = i.check(_.nanoid()) : a === "cuid" ? i = i.check(_.cuid()) : a === "cuid2" ? i = i.check(_.cuid2()) : a === "ulid" ? i = i.check(_.ulid()) : a === "xid" ? i = i.check(_.xid()) : a === "ksuid" && (i = i.check(_.ksuid()));
      }
      typeof e.minLength == "number" && (i = i.min(e.minLength)), typeof e.maxLength == "number" && (i = i.max(e.maxLength)), e.pattern && (i = i.regex(new RegExp(e.pattern))), r = i;
      break;
    }
    case "number":
    case "integer": {
      let i = n === "integer" ? _.number().int() : _.number();
      typeof e.minimum == "number" && (i = i.min(e.minimum)), typeof e.maximum == "number" && (i = i.max(e.maximum)), typeof e.exclusiveMinimum == "number" ? i = i.gt(e.exclusiveMinimum) : e.exclusiveMinimum === !0 && typeof e.minimum == "number" && (i = i.gt(e.minimum)), typeof e.exclusiveMaximum == "number" ? i = i.lt(e.exclusiveMaximum) : e.exclusiveMaximum === !0 && typeof e.maximum == "number" && (i = i.lt(e.maximum)), typeof e.multipleOf == "number" && (i = i.multipleOf(e.multipleOf)), r = i;
      break;
    }
    case "boolean": {
      r = _.boolean();
      break;
    }
    case "null": {
      r = _.null();
      break;
    }
    case "object": {
      let i = {}, a = e.properties || {}, o = new Set(e.required || []);
      for (let [l, u] of Object.entries(a)) {
        let d = Y(u, t);
        i[l] = o.has(l) ? d : d.optional();
      }
      if (e.propertyNames) {
        let l = Y(e.propertyNames, t), u = e.additionalProperties && typeof e.additionalProperties == "object" ? Y(e.additionalProperties, t) : _.any();
        if (Object.keys(i).length === 0) {
          r = _.record(l, u);
          break;
        }
        let d = _.object(i).passthrough(), f = _.looseRecord(l, u);
        r = _.intersection(d, f);
        break;
      }
      if (e.patternProperties) {
        let l = e.patternProperties, u = Object.keys(l), d = [];
        for (let h of u) {
          let $ = Y(l[h], t), P = _.string().regex(new RegExp(h));
          d.push(_.looseRecord(P, $));
        }
        let f = [];
        if (Object.keys(i).length > 0 && f.push(_.object(i).passthrough()), f.push(...d), f.length === 0) r = _.object({}).passthrough();
        else if (f.length === 1) r = f[0];
        else {
          let h = _.intersection(f[0], f[1]);
          for (let $ = 2; $ < f.length; $++) h = _.intersection(h, f[$]);
          r = h;
        }
        break;
      }
      let s = _.object(i);
      e.additionalProperties === !1 ? r = s.strict() : typeof e.additionalProperties == "object" ? r = s.catchall(Y(e.additionalProperties, t)) : r = s.passthrough();
      break;
    }
    case "array": {
      let { prefixItems: i, items: a } = e;
      if (i && Array.isArray(i)) {
        let o = i.map((l) => Y(l, t)), s = a && typeof a == "object" && !Array.isArray(a) ? Y(a, t) : void 0;
        s ? r = _.tuple(o).rest(s) : r = _.tuple(o), typeof e.minItems == "number" && (r = r.check(_.minLength(e.minItems))), typeof e.maxItems == "number" && (r = r.check(_.maxLength(e.maxItems)));
      } else if (Array.isArray(a)) {
        let o = a.map((l) => Y(l, t)), s = e.additionalItems && typeof e.additionalItems == "object" ? Y(e.additionalItems, t) : void 0;
        s ? r = _.tuple(o).rest(s) : r = _.tuple(o), typeof e.minItems == "number" && (r = r.check(_.minLength(e.minItems))), typeof e.maxItems == "number" && (r = r.check(_.maxLength(e.maxItems)));
      } else if (a !== void 0) {
        let o = Y(a, t), s = _.array(o);
        typeof e.minItems == "number" && (s = s.min(e.minItems)), typeof e.maxItems == "number" && (s = s.max(e.maxItems)), r = s;
      } else r = _.array(_.any());
      break;
    }
    default:
      throw Error(`Unsupported type: ${n}`);
  }
  return e.description && (r = r.describe(e.description)), e.default !== void 0 && (r = r.default(e.default)), r;
}
function Y(e, t) {
  if (typeof e == "boolean") return e ? _.any() : _.never();
  let n = Vm(e, t), r = e.type || e.enum !== void 0 || e.const !== void 0;
  if (e.anyOf && Array.isArray(e.anyOf)) {
    let i = e.anyOf.map((o) => Y(o, t)), a = _.union(i);
    n = r ? _.intersection(n, a) : a;
  }
  if (e.oneOf && Array.isArray(e.oneOf)) {
    let i = e.oneOf.map((o) => Y(o, t)), a = _.xor(i);
    n = r ? _.intersection(n, a) : a;
  }
  if (e.allOf && Array.isArray(e.allOf)) if (e.allOf.length === 0) n = r ? n : _.any();
  else {
    let i = r ? n : Y(e.allOf[0], t), a = r ? 0 : 1;
    for (let o = a; o < e.allOf.length; o++) i = _.intersection(i, Y(e.allOf[o], t));
    n = i;
  }
  return e.nullable === !0 && t.version === "openapi-3.0" && (n = _.nullable(n)), e.readOnly === !0 && (n = _.readonly(n)), n;
}
function dI(e, t) {
  if (typeof e == "boolean") return e ? _.any() : _.never();
  let n = lI(e, t?.defaultTarget), r = e.$defs || e.definitions || {};
  return Y(e, { version: n, defs: r, refs: /* @__PURE__ */ new Map(), processing: /* @__PURE__ */ new Set(), rootSchema: e });
}
var Gm = {};
_e(Gm, { string: () => mI, number: () => pI, date: () => hI, boolean: () => fI, bigint: () => gI });
function mI(e) {
  return ql(Ut, e);
}
function pI(e) {
  return Yl(Pt, e);
}
function fI(e) {
  return ac(Nt, e);
}
function gI(e) {
  return sc(Zt, e);
}
function hI(e) {
  return bc(Xi, e);
}
Q(Tl());
var vI = c.union([c.literal("light"), c.literal("dark")]).describe("Color theme preference for the host environment."), Ia = c.union([c.literal("inline"), c.literal("fullscreen"), c.literal("pip")]).describe("Display mode for UI presentation."), bI = c.union([c.literal("--color-background-primary"), c.literal("--color-background-secondary"), c.literal("--color-background-tertiary"), c.literal("--color-background-inverse"), c.literal("--color-background-ghost"), c.literal("--color-background-info"), c.literal("--color-background-danger"), c.literal("--color-background-success"), c.literal("--color-background-warning"), c.literal("--color-background-disabled"), c.literal("--color-text-primary"), c.literal("--color-text-secondary"), c.literal("--color-text-tertiary"), c.literal("--color-text-inverse"), c.literal("--color-text-info"), c.literal("--color-text-danger"), c.literal("--color-text-success"), c.literal("--color-text-warning"), c.literal("--color-text-disabled"), c.literal("--color-text-ghost"), c.literal("--color-border-primary"), c.literal("--color-border-secondary"), c.literal("--color-border-tertiary"), c.literal("--color-border-inverse"), c.literal("--color-border-ghost"), c.literal("--color-border-info"), c.literal("--color-border-danger"), c.literal("--color-border-success"), c.literal("--color-border-warning"), c.literal("--color-border-disabled"), c.literal("--color-ring-primary"), c.literal("--color-ring-secondary"), c.literal("--color-ring-inverse"), c.literal("--color-ring-info"), c.literal("--color-ring-danger"), c.literal("--color-ring-success"), c.literal("--color-ring-warning"), c.literal("--font-sans"), c.literal("--font-mono"), c.literal("--font-weight-normal"), c.literal("--font-weight-medium"), c.literal("--font-weight-semibold"), c.literal("--font-weight-bold"), c.literal("--font-text-xs-size"), c.literal("--font-text-sm-size"), c.literal("--font-text-md-size"), c.literal("--font-text-lg-size"), c.literal("--font-heading-xs-size"), c.literal("--font-heading-sm-size"), c.literal("--font-heading-md-size"), c.literal("--font-heading-lg-size"), c.literal("--font-heading-xl-size"), c.literal("--font-heading-2xl-size"), c.literal("--font-heading-3xl-size"), c.literal("--font-text-xs-line-height"), c.literal("--font-text-sm-line-height"), c.literal("--font-text-md-line-height"), c.literal("--font-text-lg-line-height"), c.literal("--font-heading-xs-line-height"), c.literal("--font-heading-sm-line-height"), c.literal("--font-heading-md-line-height"), c.literal("--font-heading-lg-line-height"), c.literal("--font-heading-xl-line-height"), c.literal("--font-heading-2xl-line-height"), c.literal("--font-heading-3xl-line-height"), c.literal("--border-radius-xs"), c.literal("--border-radius-sm"), c.literal("--border-radius-md"), c.literal("--border-radius-lg"), c.literal("--border-radius-xl"), c.literal("--border-radius-full"), c.literal("--border-width-regular"), c.literal("--shadow-hairline"), c.literal("--shadow-sm"), c.literal("--shadow-md"), c.literal("--shadow-lg")]).describe("CSS variable keys available to MCP apps for theming."), _I = c.record(bI.describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`), c.union([c.string(), c.undefined()]).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`)).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`);
c.object({ method: c.literal("ui/open-link"), params: c.object({ url: c.string().describe("URL to open in the host's browser") }) });
c.object({ isError: c.boolean().optional().describe("True if the host failed to open the URL (e.g., due to security policy).") }).passthrough();
c.object({ isError: c.boolean().optional().describe("True if the host rejected or failed to deliver the message.") }).passthrough();
c.object({ method: c.literal("ui/notifications/sandbox-proxy-ready"), params: c.object({}) });
c.object({ method: c.literal("ui/notifications/sandbox-resource-ready"), params: c.object({ html: c.string().describe("HTML content to load into the inner iframe."), sandbox: c.string().optional().describe("Optional override for the inner iframe's sandbox attribute."), csp: c.object({ connectDomains: c.array(c.string()).optional().describe("Origins for network requests (fetch/XHR/WebSocket)."), resourceDomains: c.array(c.string()).optional().describe("Origins for static resources (scripts, images, styles, fonts).") }).optional().describe("CSP configuration from resource metadata.") }) });
c.object({ method: c.literal("ui/notifications/size-changed"), params: c.object({ width: c.number().optional().describe("New width in pixels."), height: c.number().optional().describe("New height in pixels.") }) });
c.object({ method: c.literal("ui/notifications/tool-input"), params: c.object({ arguments: c.record(c.string(), c.unknown().describe("Complete tool call arguments as key-value pairs.")).optional().describe("Complete tool call arguments as key-value pairs.") }) });
c.object({ method: c.literal("ui/notifications/tool-input-partial"), params: c.object({ arguments: c.record(c.string(), c.unknown().describe("Partial tool call arguments (incomplete, may change).")).optional().describe("Partial tool call arguments (incomplete, may change).") }) });
c.object({ method: c.literal("ui/notifications/tool-cancelled"), params: c.object({ reason: c.string().optional().describe('Optional reason for the cancellation (e.g., "user action", "timeout").') }) });
var yI = c.object({ fonts: c.string().optional().describe("CSS for font loading (@font-face rules or") }), $I = c.object({ variables: _I.optional().describe("CSS variables for theming the app."), css: yI.optional().describe("CSS blocks that apps can inject.") });
c.object({ method: c.literal("ui/resource-teardown"), params: c.object({}) });
c.record(c.string(), c.unknown());
var II = c.object({ experimental: c.object({}).optional().describe("Experimental features (structure TBD)."), openLinks: c.object({}).optional().describe("Host supports opening external URLs."), serverTools: c.object({ listChanged: c.boolean().optional().describe("Host supports tools/list_changed notifications.") }).optional().describe("Host can proxy tool calls to the MCP server."), serverResources: c.object({ listChanged: c.boolean().optional().describe("Host supports resources/list_changed notifications.") }).optional().describe("Host can proxy resource reads to the MCP server."), logging: c.object({}).optional().describe("Host accepts log messages.") }), kI = c.object({ experimental: c.object({}).optional().describe("Experimental features (structure TBD)."), tools: c.object({ listChanged: c.boolean().optional().describe("App supports tools/list_changed notifications.") }).optional().describe("App exposes MCP-style tools that the host can call.") });
c.object({ method: c.literal("ui/notifications/initialized"), params: c.object({}).optional() });
var wI = c.object({ connectDomains: c.array(c.string()).optional().describe("Origins for network requests (fetch/XHR/WebSocket)."), resourceDomains: c.array(c.string()).optional().describe("Origins for static resources (scripts, images, styles, fonts).") });
c.object({ csp: wI.optional().describe("Content Security Policy configuration."), domain: c.string().optional().describe("Dedicated origin for widget sandbox."), prefersBorder: c.boolean().optional().describe("Visual boundary preference - true if UI prefers a visible border.") });
c.object({ method: c.literal("ui/request-display-mode"), params: c.object({ mode: Ia.describe("The display mode being requested.") }) });
c.object({ mode: Ia.describe("The display mode that was actually set. May differ from requested if not supported.") }).passthrough();
var SI = c.union([c.literal("model"), c.literal("app")]).describe("Tool visibility scope - who can access the tool.");
c.object({ resourceUri: c.string(), visibility: c.array(SI).optional().describe(`Who can access this tool. Default: ["model", "app"]
- "model": Tool visible to and callable by the agent
- "app": Tool callable by the app from this server only`) });
c.object({ method: c.literal("ui/message"), params: c.object({ role: c.literal("user").describe('Message role, currently only "user" is supported.'), content: c.array(mi).describe("Message content blocks (text, image, etc.).") }) });
c.object({ method: c.literal("ui/notifications/tool-result"), params: Pn.describe("Standard MCP tool execution result.") });
var Bm = c.object({ toolInfo: c.object({ id: ct.describe("JSON-RPC id of the tools/call request."), tool: jn.describe("Tool definition including name, inputSchema, etc.") }).optional().describe("Metadata of the tool call that instantiated this App."), theme: vI.optional().describe("Current color theme preference."), styles: $I.optional().describe("Style configuration for theming the app."), displayMode: Ia.optional().describe("How the UI is currently displayed."), availableDisplayModes: c.array(c.string()).optional().describe("Display modes the host supports."), viewport: c.object({ width: c.number().describe("Current viewport width in pixels."), height: c.number().describe("Current viewport height in pixels."), maxHeight: c.number().optional().describe("Maximum available height in pixels (if constrained)."), maxWidth: c.number().optional().describe("Maximum available width in pixels (if constrained).") }).optional().describe("Current and maximum dimensions available to the UI."), locale: c.string().optional().describe("User's language and region preference in BCP 47 format."), timeZone: c.string().optional().describe("User's timezone in IANA format."), userAgent: c.string().optional().describe("Host application identifier."), platform: c.union([c.literal("web"), c.literal("desktop"), c.literal("mobile")]).optional().describe("Platform type for responsive design decisions."), deviceCapabilities: c.object({ touch: c.boolean().optional().describe("Whether the device supports touch input."), hover: c.boolean().optional().describe("Whether the device supports hover interactions.") }).optional().describe("Device input capabilities."), safeAreaInsets: c.object({ top: c.number().describe("Top safe area inset in pixels."), right: c.number().describe("Right safe area inset in pixels."), bottom: c.number().describe("Bottom safe area inset in pixels."), left: c.number().describe("Left safe area inset in pixels.") }).optional().describe("Mobile safe area boundaries in pixels.") }).passthrough();
c.object({ method: c.literal("ui/notifications/host-context-changed"), params: Bm.describe("Partial context update containing only changed fields.") });
c.object({ method: c.literal("ui/initialize"), params: c.object({ appInfo: di.describe("App identification (name and version)."), appCapabilities: kI.describe("Features and capabilities this app provides."), protocolVersion: c.string().describe("Protocol version this app supports.") }) });
c.object({ protocolVersion: c.string().describe('Negotiated protocol version string (e.g., "2025-11-21").'), hostInfo: di.describe("Host application identification and version."), hostCapabilities: II.describe("Features and capabilities provided by the host."), hostContext: Bm.describe("Rich context about the host environment.") }).passthrough();
var EI = "ui/resourceUri", zI = "text/html;profile=mcp-app";
const xI = "mcpui.dev/ui-", OI = `var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MCPUIAppsSdkAdapter {
  constructor(config = {}) {
    __publicField(this, "config");
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "messageIdCounter", 0);
    __publicField(this, "originalPostMessage", null);
    this.config = {
      logger: config.logger || console,
      hostOrigin: config.hostOrigin || window.location.origin,
      timeout: config.timeout || 3e4,
      intentHandling: config.intentHandling || "prompt"
    };
  }
  /**
   * Initialize the adapter and monkey-patch postMessage if Apps SDK is present
   */
  install() {
    if (!window.openai) {
      this.config.logger.warn("[MCPUI-Apps SDK Adapter] window.openai not detected. Adapter will not activate.");
      return false;
    }
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Initializing adapter...");
    this.patchPostMessage();
    this.setupAppsSdkEventListeners();
    this.sendRenderData();
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter initialized successfully");
    return true;
  }
  /**
   * Clean up pending requests and restore original postMessage
   */
  uninstall() {
    for (const request of this.pendingRequests.values()) {
      clearTimeout(request.timeoutId);
      request.reject(new Error("Adapter uninstalled"));
    }
    this.pendingRequests.clear();
    if (this.originalPostMessage) {
      try {
        const parentWindow = window.parent ?? null;
        if (parentWindow) {
          parentWindow.postMessage = this.originalPostMessage;
        }
        this.config.logger.log("[MCPUI-Apps SDK Adapter] Restored original parent.postMessage");
      } catch (error) {
        this.config.logger.error("[MCPUI-Apps SDK Adapter] Failed to restore original postMessage:", error);
      }
    }
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter uninstalled");
  }
  /**
   * Monkey-patch parent.postMessage to intercept MCP-UI messages
   * and forward non-MCP-UI messages to the original postMessage
   */
  patchPostMessage() {
    const parentWindow = window.parent ?? null;
    this.originalPostMessage = parentWindow?.postMessage?.bind(parentWindow) ?? null;
    if (!this.originalPostMessage) {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] parent.postMessage does not exist, installing shim only");
    } else {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] Monkey-patching parent.postMessage to intercept MCP-UI messages");
    }
    const postMessageInterceptor = (message, targetOriginOrOptions, transfer) => {
      if (this.isMCPUIMessage(message)) {
        const mcpMessage = message;
        this.config.logger.debug("[MCPUI-Apps SDK Adapter] Intercepted MCP-UI message:", mcpMessage.type);
        this.handleMCPUIMessage(mcpMessage);
      } else {
        if (this.originalPostMessage) {
          this.config.logger.debug("[MCPUI-Apps SDK Adapter] Forwarding non-MCP-UI message to original postMessage");
          if (typeof targetOriginOrOptions === "string" || targetOriginOrOptions === void 0) {
            const targetOrigin = targetOriginOrOptions ?? "*";
            this.originalPostMessage(message, targetOrigin, transfer);
          } else {
            this.originalPostMessage(message, targetOriginOrOptions);
          }
        } else {
          this.config.logger.warn("[MCPUI-Apps SDK Adapter] No original postMessage to forward to, ignoring message:", message);
        }
      }
    };
    try {
      if (parentWindow) {
        parentWindow.postMessage = postMessageInterceptor;
      }
    } catch (error) {
      this.config.logger.error("[MCPUI-Apps SDK Adapter] Failed to monkey-patch parent.postMessage:", error);
    }
  }
  /**
   * Check if a message is an MCP-UI protocol message
   */
  isMCPUIMessage(message) {
    if (!message || typeof message !== "object") {
      return false;
    }
    const msg = message;
    return typeof msg.type === "string" && (msg.type.startsWith("ui-") || ["tool", "prompt", "intent", "notify", "link"].includes(msg.type));
  }
  /**
   * Handle incoming MCP-UI messages and translate to Apps SDK actions
   */
  async handleMCPUIMessage(message) {
    this.config.logger.debug("[MCPUI-Apps SDK Adapter] Received MCPUI message:", message.type);
    try {
      switch (message.type) {
        case "tool":
          await this.handleToolMessage(message);
          break;
        case "prompt":
          await this.handlePromptMessage(message);
          break;
        case "intent":
          await this.handleIntentMessage(message);
          break;
        case "notify":
          await this.handleNotifyMessage(message);
          break;
        case "link":
          await this.handleLinkMessage(message);
          break;
        case "ui-lifecycle-iframe-ready":
          this.sendRenderData();
          break;
        case "ui-request-render-data":
          this.sendRenderData(message.messageId);
          break;
        case "ui-size-change":
          this.handleSizeChange(message);
          break;
        case "ui-request-data":
          this.handleRequestData(message);
          break;
        default:
          this.config.logger.warn("[MCPUI-Apps SDK Adapter] Unknown message type:", message.type);
      }
    } catch (error) {
      this.config.logger.error("[MCPUI-Apps SDK Adapter] Error handling message:", error);
      if (message.messageId) {
        this.sendErrorResponse(message.messageId, error);
      }
    }
  }
  /**
   * Handle 'tool' message - call Apps SDK tool
   */
  async handleToolMessage(message) {
    if (message.type !== "tool")
      return;
    const { toolName, params } = message.payload;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    try {
      if (!window.openai?.callTool) {
        throw new Error("Tool calling is not supported in this environment");
      }
      const result = await this.withTimeout(
        window.openai.callTool(toolName, params),
        messageId
      );
      this.sendSuccessResponse(messageId, result);
    } catch (error) {
      this.sendErrorResponse(messageId, error);
    }
  }
  /**
   * Handle 'prompt' message - send followup turn
   */
  async handlePromptMessage(message) {
    if (message.type !== "prompt")
      return;
    const prompt = message.payload.prompt;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    try {
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("Followup turns are not supported in this environment");
      }
      await this.withTimeout(
        window.openai.sendFollowUpMessage({ prompt }),
        messageId
      );
      this.sendSuccessResponse(messageId, { success: true });
    } catch (error) {
      this.sendErrorResponse(messageId, error);
    }
  }
  /**
   * Handle 'intent' message - convert to prompt or ignore based on config
   */
  async handleIntentMessage(message) {
    if (message.type !== "intent")
      return;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    if (this.config.intentHandling === "ignore") {
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Intent ignored:", message.payload.intent);
      this.sendSuccessResponse(messageId, { ignored: true });
      return;
    }
    const { intent, params } = message.payload;
    const prompt = \`\${intent}\${params ? \`: \${JSON.stringify(params)}\` : ""}\`;
    try {
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("Followup turns are not supported in this environment");
      }
      await this.withTimeout(
        window.openai.sendFollowUpMessage({ prompt }),
        messageId
      );
      this.sendSuccessResponse(messageId, { success: true });
    } catch (error) {
      this.sendErrorResponse(messageId, error);
    }
  }
  /**
   * Handle 'notify' message - log only
   */
  async handleNotifyMessage(message) {
    if (message.type !== "notify")
      return;
    const messageId = message.messageId || this.generateMessageId();
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Notification:", message.payload.message);
    this.sendAcknowledgment(messageId);
    this.sendSuccessResponse(messageId, { acknowledged: true });
  }
  /**
   * Handle 'link' message - not supported in Apps SDK environments
   */
  async handleLinkMessage(message) {
    if (message.type !== "link")
      return;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    this.sendErrorResponse(messageId, new Error("Navigation is not supported in Apps SDK environment"));
  }
  /**
   * Handle size change - no-op in Apps SDK environment
   */
  handleSizeChange(message) {
    this.config.logger.debug("[MCPUI-Apps SDK Adapter] Size change requested (no-op in Apps SDK):", message.payload);
  }
  /**
   * Handle generic data request
   */
  handleRequestData(message) {
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    this.sendErrorResponse(messageId, new Error("Generic data requests not yet implemented"));
  }
  /**
   * Setup listeners for Apps SDK events
   */
  setupAppsSdkEventListeners() {
    window.addEventListener("openai:set_globals", () => {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] Globals updated");
      this.sendRenderData();
    });
  }
  /**
   * Gather render data from Apps SDK and send to widget
   */
  sendRenderData(requestMessageId) {
    if (!window.openai)
      return;
    const renderData = {
      toolInput: window.openai.toolInput,
      toolOutput: window.openai.toolOutput,
      widgetState: window.openai.widgetState,
      locale: window.openai.locale || "en-US",
      theme: window.openai.theme || "light",
      displayMode: window.openai.displayMode || "inline",
      maxHeight: window.openai.maxHeight
    };
    this.dispatchMessageToIframe({
      type: "ui-lifecycle-iframe-render-data",
      messageId: requestMessageId,
      payload: { renderData }
    });
  }
  /**
   * Send acknowledgment for a message
   */
  sendAcknowledgment(messageId) {
    this.dispatchMessageToIframe({
      type: "ui-message-received",
      payload: { messageId }
    });
  }
  /**
   * Send success response
   */
  sendSuccessResponse(messageId, response) {
    this.dispatchMessageToIframe({
      type: "ui-message-response",
      payload: { messageId, response }
    });
  }
  /**
   * Send error response
   */
  sendErrorResponse(messageId, error) {
    const errorObj = error instanceof Error ? { message: error.message, name: error.name } : { message: String(error) };
    this.dispatchMessageToIframe({
      type: "ui-message-response",
      payload: { messageId, error: errorObj }
    });
  }
  /**
   * Dispatch a MessageEvent to the iframe (widget)
   * Simulates messages that would normally come from the parent/host
   */
  dispatchMessageToIframe(data) {
    const event = new MessageEvent("message", {
      data,
      origin: this.config.hostOrigin,
      source: null
    });
    window.dispatchEvent(event);
  }
  /**
   * Wrap a promise with timeout
   */
  async withTimeout(promise, requestId) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error(\`Request timed out after \${this.config.timeout}ms\`));
      }, this.config.timeout);
      this.pendingRequests.set(requestId, {
        messageId: requestId,
        type: "generic",
        resolve,
        reject,
        timeoutId
      });
      promise.then((result) => {
        clearTimeout(timeoutId);
        this.pendingRequests.delete(requestId);
        resolve(result);
      }).catch((error) => {
        clearTimeout(timeoutId);
        this.pendingRequests.delete(requestId);
        reject(error);
      });
    });
  }
  /**
   * Generate a unique message ID
   */
  generateMessageId() {
    return \`adapter-\${Date.now()}-\${++this.messageIdCounter}\`;
  }
}
let adapterInstance = null;
function initAdapter(config) {
  if (adapterInstance) {
    console.warn("[MCPUI-Apps SDK Adapter] Adapter already initialized");
    return true;
  }
  adapterInstance = new MCPUIAppsSdkAdapter(config);
  return adapterInstance.install();
}
function uninstallAdapter() {
  if (adapterInstance) {
    adapterInstance.uninstall();
    adapterInstance = null;
  }
}
`;
function UI(e) {
  const t = e ? JSON.stringify(e) : "{}";
  return `
<script>
(function() {
  'use strict';
  
  ${OI}
  
  // Override auto-init from runtime and initialize with provided config
  if (typeof window !== 'undefined') {
    // If the functions are not defined, just return, we can't do anything.
    if (typeof initAdapter !== 'function' || typeof uninstallAdapter !== 'function') {
      console.warn('[MCPUI-Apps SDK Adapter] Adapter runtime not found with the correct methods. Adapter will not activate.')    
      return;
    }
    
    // If auto-init is enabled, initialize with config from server 
    if (!window.MCP_APPSSDK_ADAPTER_NO_AUTO_INSTALL) {
      initAdapter(${t});
    }
    
    // Expose functions globally
    if (typeof window.MCPUIAppsSdkAdapter === 'undefined') {
      window.MCPUIAppsSdkAdapter = {
        init: initAdapter,
        initWithConfig: () => initAdapter(${t}),
        uninstall: uninstallAdapter,
      };
    }
  }
})();
<\/script>
`.trim();
}
const jI = `var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const LATEST_PROTOCOL_VERSION = "2025-11-21";
const METHODS = {
  // Lifecycle
  INITIALIZE: "ui/initialize",
  INITIALIZED: "ui/notifications/initialized",
  // Tool data (Host -> Guest)
  TOOL_INPUT: "ui/notifications/tool-input",
  TOOL_INPUT_PARTIAL: "ui/notifications/tool-input-partial",
  TOOL_RESULT: "ui/notifications/tool-result",
  TOOL_CANCELLED: "ui/notifications/tool-cancelled",
  // Context & UI
  HOST_CONTEXT_CHANGED: "ui/notifications/host-context-changed",
  SIZE_CHANGED: "ui/notifications/size-changed",
  RESOURCE_TEARDOWN: "ui/resource-teardown",
  // Standard MCP methods
  TOOLS_CALL: "tools/call",
  NOTIFICATIONS_MESSAGE: "notifications/message",
  OPEN_LINK: "ui/open-link",
  MESSAGE: "ui/message"
};
class McpAppsAdapter {
  constructor(config = {}) {
    __publicField(this, "config");
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "messageIdCounter", 0);
    __publicField(this, "originalPostMessage", null);
    __publicField(this, "parentWindow", null);
    __publicField(this, "hostCapabilities", null);
    __publicField(this, "hostContext", null);
    __publicField(this, "initialized", false);
    // Current render data state (similar to window.openai in Apps SDK)
    __publicField(this, "currentRenderData", {});
    this.config = {
      logger: config.logger || console,
      timeout: config.timeout || 3e4
    };
  }
  install() {
    this.parentWindow = window.parent;
    this.config.logger.log("[MCP Apps Adapter] Checking parent window...");
    this.config.logger.log("[MCP Apps Adapter] window.parent exists:", !!this.parentWindow);
    this.config.logger.log("[MCP Apps Adapter] window.parent === window:", this.parentWindow === window);
    if (!this.parentWindow || this.parentWindow === window) {
      this.config.logger.warn("[MCP Apps Adapter] No parent window detected. Adapter will not activate.");
      return false;
    }
    this.config.logger.log("[MCP Apps Adapter] Initializing adapter...");
    this.patchPostMessage();
    window.addEventListener("message", this.handleHostMessage.bind(this));
    this.performInitialization();
    this.config.logger.log("[MCP Apps Adapter] Adapter initialized successfully");
    return true;
  }
  /**
   * Performs the MCP Apps SEP initialization handshake:
   * 1. Send ui/initialize request with adapter info
   * 2. Receive host capabilities and context
   * 3. Send ui/notifications/initialized notification
   * 4. Dispatch ready event to MCP-UI app
   */
  async performInitialization() {
    const jsonRpcId = this.generateJsonRpcId();
    const initPromise = new Promise((resolve, reject) => {
      this.pendingRequests.set(String(jsonRpcId), {
        messageId: "init",
        type: "init",
        resolve: (result) => {
          const res = result;
          this.hostCapabilities = res?.hostCapabilities ?? null;
          this.hostContext = res?.hostContext ?? null;
          this.initialized = true;
          this.sendJsonRpcNotification(METHODS.INITIALIZED, {});
          if (this.hostContext) {
            if (this.hostContext.theme)
              this.currentRenderData.theme = this.hostContext.theme;
            if (this.hostContext.displayMode)
              this.currentRenderData.displayMode = this.hostContext.displayMode;
            if (this.hostContext.locale)
              this.currentRenderData.locale = this.hostContext.locale;
            if (this.hostContext.viewport?.maxHeight)
              this.currentRenderData.maxHeight = this.hostContext.viewport.maxHeight;
          }
          this.sendRenderData();
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-iframe-ready"
          });
          resolve();
        },
        reject: (error) => {
          this.config.logger.error("[MCP Apps Adapter] Initialization failed:", error);
          reject(error);
        },
        timeoutId: setTimeout(() => {
          this.pendingRequests.delete(String(jsonRpcId));
          this.config.logger.warn("[MCP Apps Adapter] Initialization timed out, proceeding anyway");
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-iframe-ready"
          });
          resolve();
        }, this.config.timeout)
      });
    });
    this.config.logger.log("[MCP Apps Adapter] Sending ui/initialize request with id:", jsonRpcId);
    this.sendJsonRpcRequest(jsonRpcId, METHODS.INITIALIZE, {
      appInfo: {
        name: "mcp-ui-adapter",
        version: "1.0.0"
      },
      appCapabilities: {},
      protocolVersion: LATEST_PROTOCOL_VERSION
    });
    this.config.logger.log("[MCP Apps Adapter] ui/initialize request sent");
    try {
      await initPromise;
    } catch (_error) {
      this.config.logger.warn("[MCP Apps Adapter] Continuing despite initialization error");
    }
  }
  uninstall() {
    for (const request of this.pendingRequests.values()) {
      clearTimeout(request.timeoutId);
      request.reject(new Error("Adapter uninstalled"));
    }
    this.pendingRequests.clear();
    if (this.originalPostMessage && this.parentWindow) {
      try {
        this.parentWindow.postMessage = this.originalPostMessage;
        this.config.logger.log("[MCP Apps Adapter] Restored original parent.postMessage");
      } catch (error) {
        this.config.logger.error("[MCP Apps Adapter] Failed to restore original postMessage:", error);
      }
    }
    window.removeEventListener("message", this.handleHostMessage.bind(this));
    this.config.logger.log("[MCP Apps Adapter] Adapter uninstalled");
  }
  patchPostMessage() {
    this.originalPostMessage = this.parentWindow?.postMessage.bind(this.parentWindow) ?? null;
    const postMessageInterceptor = (message, targetOriginOrOptions, transfer) => {
      if (this.isMCPUIMessage(message)) {
        const mcpMessage = message;
        this.config.logger.debug("[MCP Apps Adapter] Intercepted MCP-UI message:", mcpMessage.type);
        this.handleMCPUIMessage(mcpMessage);
      } else {
        if (this.originalPostMessage) {
          if (typeof targetOriginOrOptions === "string" || targetOriginOrOptions === void 0) {
            const targetOrigin = targetOriginOrOptions ?? "*";
            this.originalPostMessage(message, targetOrigin, transfer);
          } else {
            this.originalPostMessage(message, targetOriginOrOptions);
          }
        }
      }
    };
    try {
      if (this.parentWindow) {
        this.parentWindow.postMessage = postMessageInterceptor;
      }
    } catch (error) {
      this.config.logger.error("[MCP Apps Adapter] Failed to monkey-patch parent.postMessage:", error);
    }
  }
  isMCPUIMessage(message) {
    if (!message || typeof message !== "object") {
      return false;
    }
    const msg = message;
    return typeof msg.type === "string" && (msg.type.startsWith("ui-") || ["tool", "prompt", "intent", "notify", "link"].includes(msg.type));
  }
  /**
   * Handles messages coming from the Host (JSON-RPC) and translates them to MCP-UI messages
   * 
   * MCP Apps SEP protocol methods (from @modelcontextprotocol/ext-apps):
   * - ui/notifications/tool-input: Complete tool arguments
   * - ui/notifications/tool-input-partial: Streaming partial tool arguments
   * - ui/notifications/tool-result: Tool execution results
   * - ui/notifications/host-context-changed: Theme, viewport, locale changes
   * - ui/notifications/size-changed: Size change notifications (bidirectional)
   * - ui/notifications/tool-cancelled: Tool execution was cancelled
   * - ui/resource-teardown: Host notifies UI before teardown (request)
   */
  handleHostMessage(event) {
    const data = event.data;
    if (!data || typeof data !== "object" || !data.jsonrpc) {
      return;
    }
    this.config.logger.debug("[MCP Apps Adapter] Received JSON-RPC message:", data);
    if (data.method) {
      switch (data.method) {
        case METHODS.TOOL_INPUT:
          this.currentRenderData.toolInput = data.params?.arguments;
          this.sendRenderData();
          break;
        case METHODS.TOOL_INPUT_PARTIAL:
          this.currentRenderData.toolInput = data.params?.arguments;
          this.sendRenderData();
          break;
        case METHODS.TOOL_RESULT:
          this.currentRenderData.toolOutput = data.params;
          this.sendRenderData();
          break;
        case METHODS.HOST_CONTEXT_CHANGED:
          if (data.params?.theme)
            this.currentRenderData.theme = data.params.theme;
          if (data.params?.displayMode)
            this.currentRenderData.displayMode = data.params.displayMode;
          if (data.params?.locale)
            this.currentRenderData.locale = data.params.locale;
          if (data.params?.viewport?.maxHeight)
            this.currentRenderData.maxHeight = data.params.viewport.maxHeight;
          this.sendRenderData();
          break;
        case METHODS.SIZE_CHANGED:
          if (data.params?.height)
            this.currentRenderData.maxHeight = data.params.height;
          this.sendRenderData();
          break;
        case METHODS.TOOL_CANCELLED:
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-tool-cancelled",
            payload: {
              reason: data.params?.reason
            }
          });
          break;
        case METHODS.RESOURCE_TEARDOWN:
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-teardown",
            payload: {
              reason: data.params?.reason
            }
          });
          if (data.id) {
            this.sendJsonRpcResponse(data.id, {});
          }
          break;
      }
    } else if (data.id) {
      const pendingRequest = this.pendingRequests.get(String(data.id));
      if (pendingRequest) {
        if (data.error) {
          pendingRequest.reject(new Error(data.error.message));
        } else {
          pendingRequest.resolve(data.result);
        }
        this.pendingRequests.delete(String(data.id));
        clearTimeout(pendingRequest.timeoutId);
        this.dispatchMessageToIframe({
          type: "ui-message-response",
          messageId: pendingRequest.messageId,
          // The original message ID from the App
          payload: {
            messageId: pendingRequest.messageId,
            response: data.result,
            error: data.error
          }
        });
      }
    }
  }
  /**
   * Handles messages coming from the App (MCP-UI) and translates them to Host (JSON-RPC)
   * 
   * MCP-UI message types translated to MCP Apps SEP:
   * - 'tool' -> tools/call request
   * - 'ui-size-change' -> ui/notifications/size-changed notification
   * - 'notify' -> notifications/message notification (logging)
   * - 'link' -> ui/open-link request
   * - 'prompt' -> ui/message request
   * - 'ui-lifecycle-iframe-ready' -> ui/notifications/initialized notification
   */
  async handleMCPUIMessage(message) {
    const messageId = message.messageId || this.generateMessageId();
    this.dispatchMessageToIframe({
      type: "ui-message-received",
      payload: { messageId }
    });
    try {
      switch (message.type) {
        case "tool": {
          const { toolName, params } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "tool",
            resolve: () => {
            },
            // Handled in handleHostMessage
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, METHODS.TOOLS_CALL, {
            name: toolName,
            arguments: params
          });
          break;
        }
        case "ui-size-change": {
          const { width, height } = message.payload;
          this.sendJsonRpcNotification(METHODS.SIZE_CHANGED, { width, height });
          break;
        }
        case "notify": {
          const { message: msg } = message.payload;
          this.sendJsonRpcNotification(METHODS.NOTIFICATIONS_MESSAGE, {
            level: "info",
            data: msg
          });
          break;
        }
        case "link": {
          const { url } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "link",
            resolve: () => {
            },
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, METHODS.OPEN_LINK, { url });
          break;
        }
        case "prompt": {
          const { prompt } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "prompt",
            resolve: () => {
            },
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, METHODS.MESSAGE, {
            role: "user",
            content: [{ type: "text", text: prompt }]
          });
          break;
        }
        case "ui-lifecycle-iframe-ready": {
          this.sendJsonRpcNotification(METHODS.INITIALIZED, {});
          this.sendRenderData();
          break;
        }
        case "ui-request-render-data": {
          this.sendRenderData(messageId);
          break;
        }
        case "intent": {
          const { intent, params } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "intent",
            resolve: () => {
            },
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, METHODS.MESSAGE, {
            role: "user",
            content: [{ type: "text", text: \`Intent: \${intent}. Parameters: \${JSON.stringify(params)}\` }]
          });
          break;
        }
      }
    } catch (error) {
      this.config.logger.error("[MCP Apps Adapter] Error handling message:", error);
      this.dispatchMessageToIframe({
        type: "ui-message-response",
        messageId,
        payload: { messageId, error }
      });
    }
  }
  /**
   * Send current render data to the MCP-UI app
   * This mirrors the Apps SDK adapter's sendRenderData method
   */
  sendRenderData(requestMessageId) {
    this.dispatchMessageToIframe({
      type: "ui-lifecycle-iframe-render-data",
      messageId: requestMessageId,
      payload: {
        renderData: {
          toolInput: this.currentRenderData.toolInput,
          toolOutput: this.currentRenderData.toolOutput,
          widgetState: this.currentRenderData.widgetState,
          locale: this.currentRenderData.locale,
          theme: this.currentRenderData.theme,
          displayMode: this.currentRenderData.displayMode,
          maxHeight: this.currentRenderData.maxHeight
        }
      }
    });
  }
  sendJsonRpcRequest(id, method, params) {
    this.originalPostMessage?.({
      jsonrpc: "2.0",
      id,
      method,
      params
    }, "*");
  }
  sendJsonRpcResponse(id, result) {
    this.originalPostMessage?.({
      jsonrpc: "2.0",
      id,
      result
    }, "*");
  }
  sendJsonRpcNotification(method, params) {
    this.originalPostMessage?.({
      jsonrpc: "2.0",
      method,
      params
    }, "*");
  }
  dispatchMessageToIframe(data) {
    const event = new MessageEvent("message", {
      data,
      origin: window.location.origin,
      // Same origin since we are inside the iframe
      source: window
    });
    window.dispatchEvent(event);
  }
  generateMessageId() {
    return \`adapter-\${Date.now()}-\${++this.messageIdCounter}\`;
  }
  generateJsonRpcId() {
    return ++this.messageIdCounter;
  }
}
let adapterInstance = null;
function initAdapter(config) {
  if (adapterInstance) {
    console.warn("[MCP Apps Adapter] Adapter already initialized");
    return true;
  }
  adapterInstance = new McpAppsAdapter(config);
  return adapterInstance.install();
}
function uninstallAdapter() {
  if (adapterInstance) {
    adapterInstance.uninstall();
    adapterInstance = null;
  }
}
`;
function PI(e) {
  const t = e ? {
    timeout: e.timeout
  } : {}, n = JSON.stringify(t);
  return `
<script>
(function() {
  'use strict';
  
  ${jI}
  
  if (typeof window !== 'undefined') {
    if (typeof initAdapter !== 'function' || typeof uninstallAdapter !== 'function') {
      console.warn('[MCP Apps Adapter] Adapter runtime not found. Adapter will not activate.');
      return;
    }
    
    if (!window.MCP_APPS_ADAPTER_NO_AUTO_INSTALL) {
      initAdapter(${n});
    }
    
    window.McpAppsAdapter = {
      init: initAdapter,
      initWithConfig: () => initAdapter(${n}),
      uninstall: uninstallAdapter,
    };
  }
})();
<\/script>
`.trim();
}
function oo(e) {
  const t = { ...e.resourceProps ?? {} };
  if (e.uiMetadata || e.metadata) {
    const n = Object.fromEntries(
      Object.entries(e.uiMetadata ?? {}).map(([r, i]) => [
        `${xI}${r}`,
        i
      ])
    );
    t._meta = {
      ...n,
      ...e.metadata ?? {},
      ...t._meta ?? {}
    };
  }
  return t;
}
function NI(e) {
  if (typeof Buffer < "u")
    return Buffer.from(e, "utf-8").toString("base64");
  if (typeof TextEncoder < "u" && typeof btoa < "u") {
    const n = new TextEncoder().encode(e);
    let r = "";
    const i = 8192;
    for (let a = 0; a < n.length; a += i)
      r += String.fromCharCode(...n.slice(a, a + i));
    return btoa(r);
  } else {
    console.warn(
      "MCP-UI SDK: Buffer API and TextEncoder/btoa not available. Base64 encoding might not be UTF-8 safe."
    );
    try {
      return btoa(e);
    } catch {
      throw new Error(
        "MCP-UI SDK: Suitable UTF-8 to Base64 encoding method not found, and fallback btoa failed."
      );
    }
  }
}
function ZI(e) {
  if (e) {
    if (e.appsSdk?.enabled)
      return e.appsSdk.mimeType ?? "text/html+skybridge";
    if (e.mcpApps?.enabled)
      return zI;
  }
}
function DI(e, t) {
  if (!t)
    return e;
  const n = [];
  if (t.appsSdk?.enabled) {
    const a = UI(t.appsSdk.config);
    n.push(a);
  }
  if (t.mcpApps?.enabled) {
    const a = PI(t.mcpApps.config);
    n.push(a);
  }
  if (n.length === 0)
    return e;
  const r = n.join(`
`);
  let i;
  return e.includes("<head>") ? i = e.replace("<head>", `<head>
${r}`) : e.includes("<html>") ? i = e.replace("<html>", `<html>
<head>
${r}
</head>`) : i = `${r}
${e}`, i;
}
function AI(e) {
  let t, n;
  if (e.content.type === "rawHtml") {
    if (!e.uri.startsWith("ui://"))
      throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'rawHtml'.");
    if (t = e.content.htmlString, typeof t != "string")
      throw new Error(
        "MCP-UI SDK: content.htmlString must be provided as a string when content.type is 'rawHtml'."
      );
    e.adapters ? (t = DI(t, e.adapters), n = ZI(e.adapters) ?? "text/html") : n = "text/html";
  } else if (e.content.type === "externalUrl") {
    if (!e.uri.startsWith("ui://"))
      throw new Error(
        "MCP-UI SDK: URI must start with 'ui://' when content.type is 'externalUrl'."
      );
    const i = e.content.iframeUrl;
    if (typeof i != "string")
      throw new Error(
        "MCP-UI SDK: content.iframeUrl must be provided as a string when content.type is 'externalUrl'."
      );
    t = i, n = "text/uri-list";
  } else if (e.content.type === "remoteDom") {
    if (!e.uri.startsWith("ui://"))
      throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'remoteDom'.");
    if (t = e.content.script, typeof t != "string")
      throw new Error(
        "MCP-UI SDK: content.script must be provided as a string when content.type is 'remoteDom'."
      );
    n = `application/vnd.mcp-ui.remote-dom+javascript; framework=${e.content.framework}`;
  } else {
    const i = e.content;
    throw new Error(`MCP-UI SDK: Invalid content.type specified: ${i}`);
  }
  let r;
  switch (e.encoding) {
    case "text":
      r = {
        uri: e.uri,
        mimeType: n,
        text: t,
        ...oo(e)
      };
      break;
    case "blob":
      r = {
        uri: e.uri,
        mimeType: n,
        blob: NI(t),
        ...oo(e)
      };
      break;
    default: {
      const i = e.encoding;
      throw new Error(`MCP-UI SDK: Invalid encoding type: ${i}`);
    }
  }
  return {
    type: "resource",
    resource: r,
    ...e.embeddedResourceProps ?? {}
  };
}
function TI(e) {
  window.parent && window.parent.postMessage(e, "*");
}
const RI = {
  UI_MESSAGE_RECEIVED: "ui-message-received",
  UI_MESSAGE_RESPONSE: "ui-message-response",
  UI_SIZE_CHANGE: "ui-size-change",
  UI_LIFECYCLE_IFRAME_READY: "ui-lifecycle-iframe-ready",
  UI_LIFECYCLE_IFRAME_RENDER_DATA: "ui-lifecycle-iframe-render-data",
  UI_RAWHTML_CONTENT: "ui-html-content"
}, CI = {
  WAIT_FOR_RENDER_DATA: "waitForRenderData"
};
function MI(e, t) {
  return {
    type: "tool",
    payload: {
      toolName: e,
      params: t
    }
  };
}
function LI(e) {
  return {
    type: "prompt",
    payload: {
      prompt: e
    }
  };
}
function FI(e) {
  return {
    type: "link",
    payload: {
      url: e
    }
  };
}
function JI(e, t) {
  return {
    type: "intent",
    payload: {
      intent: e,
      params: t
    }
  };
}
function qI(e) {
  return {
    type: "notify",
    payload: {
      message: e
    }
  };
}
export {
  RI as InternalMessageType,
  zI as RESOURCE_MIME_TYPE,
  EI as RESOURCE_URI_META_KEY,
  CI as ReservedUrlParams,
  AI as createUIResource,
  ZI as getAdapterMimeType,
  UI as getAppsSdkAdapterScript,
  PI as getMcpAppsAdapterScript,
  TI as postUIActionResult,
  JI as uiActionResultIntent,
  FI as uiActionResultLink,
  qI as uiActionResultNotification,
  LI as uiActionResultPrompt,
  MI as uiActionResultToolCall,
  DI as wrapHtmlWithAdapters
};
//# sourceMappingURL=index.mjs.map
