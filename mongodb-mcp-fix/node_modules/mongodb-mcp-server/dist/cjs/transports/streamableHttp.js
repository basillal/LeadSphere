"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamableHttpRunner = void 0;
const express_1 = __importDefault(require("express"));
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const logger_js_1 = require("../common/logger.js");
const sessionStore_js_1 = require("../common/sessionStore.js");
const base_js_1 = require("./base.js");
const getRandomUUID_js_1 = require("../helpers/getRandomUUID.js");
const JSON_RPC_ERROR_CODE_PROCESSING_REQUEST_FAILED = -32000;
const JSON_RPC_ERROR_CODE_SESSION_ID_REQUIRED = -32001;
const JSON_RPC_ERROR_CODE_SESSION_ID_INVALID = -32002;
const JSON_RPC_ERROR_CODE_SESSION_NOT_FOUND = -32003;
const JSON_RPC_ERROR_CODE_INVALID_REQUEST = -32004;
const JSON_RPC_ERROR_CODE_DISALLOWED_EXTERNAL_SESSION = -32005;
class StreamableHttpRunner extends base_js_1.TransportRunnerBase {
    constructor(config) {
        super(config);
    }
    async start() {
        this.validateConfig();
        await this.startMCPServer();
        await this.startHealthCheckServer();
        this.logger.info({
            message: "Streamable HTTP Transport started",
            context: "streamableHttpTransport",
            id: logger_js_1.LogId.streamableHttpTransportStarted,
        });
    }
    async closeTransport() {
        await Promise.all([this.mcpServer?.stop(), this.healthCheckServer?.stop()]);
    }
    shouldWarnAboutHttpHost(httpHost) {
        const host = httpHost.trim();
        const safeHosts = new Set(["127.0.0.1", "localhost", "::1"]);
        return host === "0.0.0.0" || host === "::" || (!safeHosts.has(host) && host !== "");
    }
    async startMCPServer() {
        this.mcpServer = new MCPHttpServer(this.userConfig, this.setupServer.bind(this), this.logger);
        await this.mcpServer.start();
    }
    async startHealthCheckServer() {
        const { healthCheckHost, healthCheckPort } = this.userConfig;
        if (healthCheckHost && healthCheckPort !== undefined) {
            this.healthCheckServer = new HealthCheckServer(healthCheckHost, healthCheckPort, this.logger);
            await this.healthCheckServer.start();
        }
    }
    validateConfig() {
        if ((this.userConfig.healthCheckHost === undefined) !== (this.userConfig.healthCheckPort === undefined)) {
            throw new Error("Both healthCheckHost and healthCheckPort must be defined to enable health checks.");
        }
        if (this.userConfig.healthCheckHost !== undefined && this.userConfig.healthCheckPort !== undefined) {
            if (this.userConfig.healthCheckPort === this.userConfig.httpPort && this.userConfig.healthCheckPort !== 0) {
                throw new Error("healthCheckPort cannot be the same as httpPort.");
            }
        }
        if (this.shouldWarnAboutHttpHost(this.userConfig.httpHost)) {
            this.logger.warning({
                id: logger_js_1.LogId.streamableHttpTransportHttpHostWarning,
                context: "streamableHttpTransport",
                message: `Binding to ${this.userConfig.httpHost} can expose the MCP Server to the entire local network, which allows other devices on the same network to potentially access the MCP Server. This is a security risk and could allow unauthorized access to your database context.`,
                noRedaction: true,
            });
        }
    }
}
exports.StreamableHttpRunner = StreamableHttpRunner;
class ExpressBasedHttpServer {
    constructor(config) {
        this.app = (0, express_1.default)();
        this.app.enable("trust proxy"); // needed for reverse proxy support
        this.expressConfig = { port: config.port, hostname: config.hostname };
        this.logger = config.logger;
        this.logContext = config.logContext;
    }
    get serverAddress() {
        const result = this.httpServer?.address();
        if (typeof result === "string") {
            return result;
        }
        if (typeof result === "object" && result) {
            return `http://${result.address}:${result.port}`;
        }
        throw new Error("Server is not started yet");
    }
    async start() {
        await this.setupRoutes();
        const { port, hostname } = this.expressConfig;
        this.httpServer = await new Promise((resolve, reject) => {
            const result = this.app.listen(port, hostname, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(result);
                }
            });
        });
        this.logger.info({
            message: `Http server started on address: ${this.serverAddress}`,
            context: this.logContext,
            noRedaction: true,
            id: logger_js_1.LogId.httpServerStarted,
        });
    }
    async stop() {
        if (this.httpServer) {
            this.logger.info({
                message: "Stopping server...",
                context: this.logContext,
                id: logger_js_1.LogId.httpServerStopping,
            });
            const server = this.httpServer;
            await new Promise((resolve, reject) => {
                server.close((err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(undefined);
                    }
                });
            });
            this.logger.info({
                message: "Server stopped",
                context: this.logContext,
                id: logger_js_1.LogId.httpServerStopped,
            });
        }
        else {
            this.logger.info({
                message: "Server is not running",
                context: this.logContext,
                id: logger_js_1.LogId.httpServerStopped,
            });
        }
    }
}
class MCPHttpServer extends ExpressBasedHttpServer {
    constructor(userConfig, setupMcpServer, logger) {
        super({
            port: userConfig.httpPort,
            hostname: userConfig.httpHost,
            logger,
            logContext: "mcpHttpServer",
        });
        this.userConfig = userConfig;
        this.setupMcpServer = setupMcpServer;
    }
    async stop() {
        await Promise.all([this.sessionStore.closeAllSessions(), super.stop()]);
    }
    async setupRoutes() {
        const { StreamableHTTPServerTransport } = await Promise.resolve().then(() => __importStar(require("@modelcontextprotocol/sdk/server/streamableHttp.js")));
        this.sessionStore = new sessionStore_js_1.SessionStore(this.userConfig.idleTimeoutMs, this.userConfig.notificationTimeoutMs, this.logger);
        this.app.use(express_1.default.json({ limit: this.userConfig.httpBodyLimit }));
        this.app.use((req, res, next) => {
            for (const [key, value] of Object.entries(this.userConfig.httpHeaders)) {
                const header = req.headers[key.toLowerCase()];
                if (!header || header !== value) {
                    res.status(403).json({ error: `Invalid value for header "${key}"` });
                    return;
                }
            }
            next();
        });
        const reportSessionError = (res, errorCode) => {
            let message;
            let statusCode = 400;
            switch (errorCode) {
                case JSON_RPC_ERROR_CODE_SESSION_ID_REQUIRED:
                    message = "session id is required";
                    break;
                case JSON_RPC_ERROR_CODE_SESSION_ID_INVALID:
                    message = "session id is invalid";
                    break;
                case JSON_RPC_ERROR_CODE_INVALID_REQUEST:
                    message = "invalid request";
                    break;
                case JSON_RPC_ERROR_CODE_SESSION_NOT_FOUND:
                    message = "session not found";
                    statusCode = 404;
                    break;
                case JSON_RPC_ERROR_CODE_DISALLOWED_EXTERNAL_SESSION:
                    message = "cannot provide sessionId when externally managed sessions are disabled";
                    break;
                default:
                    message = "unknown error";
                    statusCode = 500;
            }
            res.status(statusCode).json({
                jsonrpc: "2.0",
                error: {
                    code: errorCode,
                    message,
                },
            });
        };
        const handleSessionRequest = async (req, res) => {
            const sessionId = req.headers["mcp-session-id"];
            if (!sessionId) {
                return reportSessionError(res, JSON_RPC_ERROR_CODE_SESSION_ID_REQUIRED);
            }
            if (typeof sessionId !== "string") {
                return reportSessionError(res, JSON_RPC_ERROR_CODE_SESSION_ID_INVALID);
            }
            const transport = this.sessionStore.getSession(sessionId);
            if (!transport) {
                if (this.userConfig.externallyManagedSessions) {
                    this.logger.debug({
                        id: logger_js_1.LogId.streamableHttpTransportSessionNotFound,
                        context: "streamableHttpTransport",
                        message: `Session with ID ${sessionId} not found, initializing new session`,
                    });
                    return await initializeServer(req, res, { sessionId, isImplicitInitialization: true });
                }
                this.logger.debug({
                    id: logger_js_1.LogId.streamableHttpTransportSessionNotFound,
                    context: "streamableHttpTransport",
                    message: `Session with ID ${sessionId} not found`,
                });
                return reportSessionError(res, JSON_RPC_ERROR_CODE_SESSION_NOT_FOUND);
            }
            await transport.handleRequest(req, res, req.body);
        };
        /**
         * Initializes a new server and session. This can be done either explicitly via an initialize request
         * or implicitly when externally managed sessions are enabled and a request is received for a session
         * that does not exist.
         */
        const initializeServer = async (req, res, { sessionId, isImplicitInitialization, }) => {
            if (isImplicitInitialization && !sessionId) {
                throw new Error("Implicit initialization requires externally-passed sessionId");
            }
            const request = {
                headers: req.headers,
                query: req.query,
            };
            const server = await this.setupMcpServer(request);
            const options = {
                enableJsonResponse: this.userConfig.httpResponseType === "json",
            };
            const sessionInitialized = (sessionId) => {
                server.session.logger.setAttribute("sessionId", sessionId);
                this.sessionStore.setSession(sessionId, transport, server.session.logger);
            };
            // When we're implicitly initializing a session, the client is not going through the initialization
            // flow. This means that it won't do proper session lifecycle management, so we should not add hooks for
            // onsessioninitialized and onsessionclosed.
            if (!isImplicitInitialization) {
                options.sessionIdGenerator = () => sessionId ?? (0, getRandomUUID_js_1.getRandomUUID)();
                options.onsessioninitialized = sessionInitialized.bind(this);
                options.onsessionclosed = async (sessionId) => {
                    try {
                        await this.sessionStore.closeSession(sessionId, false);
                    }
                    catch (error) {
                        this.logger.error({
                            id: logger_js_1.LogId.streamableHttpTransportSessionCloseFailure,
                            context: "streamableHttpTransport",
                            message: `Error closing session ${sessionId}: ${error instanceof Error ? error.message : String(error)}`,
                        });
                    }
                };
            }
            const transport = new StreamableHTTPServerTransport(options);
            if (isImplicitInitialization) {
                sessionInitialized(sessionId);
            }
            let failedPings = 0;
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            const keepAliveLoop = setInterval(async () => {
                try {
                    server.session.logger.debug({
                        id: logger_js_1.LogId.streamableHttpTransportKeepAlive,
                        context: "streamableHttpTransport",
                        message: "Sending ping",
                    });
                    await transport.send({
                        jsonrpc: "2.0",
                        method: "ping",
                    });
                    failedPings = 0;
                }
                catch (err) {
                    try {
                        failedPings++;
                        server.session.logger.warning({
                            id: logger_js_1.LogId.streamableHttpTransportKeepAliveFailure,
                            context: "streamableHttpTransport",
                            message: `Error sending ping (attempt #${failedPings}): ${err instanceof Error ? err.message : String(err)}`,
                        });
                        if (failedPings > 3) {
                            clearInterval(keepAliveLoop);
                            await transport.close();
                        }
                    }
                    catch {
                        // Ignore the error of the transport close as there's nothing else
                        // we can do at this point.
                    }
                }
            }, 30000);
            transport.onclose = () => {
                clearInterval(keepAliveLoop);
                server.close().catch((error) => {
                    this.logger.error({
                        id: logger_js_1.LogId.streamableHttpTransportCloseFailure,
                        context: "streamableHttpTransport",
                        message: `Error closing server: ${error instanceof Error ? error.message : String(error)}`,
                    });
                });
            };
            await server.connect(transport);
            await transport.handleRequest(req, res, req.body);
        };
        this.app.post("/mcp", this.withErrorHandling(async (req, res) => {
            const sessionId = req.headers["mcp-session-id"];
            if (sessionId && typeof sessionId !== "string") {
                return reportSessionError(res, JSON_RPC_ERROR_CODE_SESSION_ID_INVALID);
            }
            if ((0, types_js_1.isInitializeRequest)(req.body)) {
                if (sessionId && !this.userConfig.externallyManagedSessions) {
                    this.logger.debug({
                        id: logger_js_1.LogId.streamableHttpTransportDisallowedExternalSessionError,
                        context: "streamableHttpTransport",
                        message: `Client provided session ID ${sessionId}, but externallyManagedSessions is disabled`,
                    });
                    return reportSessionError(res, JSON_RPC_ERROR_CODE_DISALLOWED_EXTERNAL_SESSION);
                }
                return await initializeServer(req, res, { sessionId });
            }
            if (sessionId) {
                return await handleSessionRequest(req, res);
            }
            return reportSessionError(res, JSON_RPC_ERROR_CODE_INVALID_REQUEST);
        }));
        this.app.get("/mcp", this.withErrorHandling(handleSessionRequest));
        this.app.delete("/mcp", this.withErrorHandling(handleSessionRequest));
    }
    withErrorHandling(fn) {
        return (req, res, next) => {
            fn(req, res, next).catch((error) => {
                this.logger.error({
                    id: logger_js_1.LogId.streamableHttpTransportRequestFailure,
                    context: "streamableHttpTransport",
                    message: `Error handling request: ${error instanceof Error ? error.message : String(error)}`,
                });
                res.status(400).json({
                    jsonrpc: "2.0",
                    error: {
                        code: JSON_RPC_ERROR_CODE_PROCESSING_REQUEST_FAILED,
                        message: `failed to handle request`,
                        data: error instanceof Error ? error.message : String(error),
                    },
                });
            });
        };
    }
}
class HealthCheckServer extends ExpressBasedHttpServer {
    constructor(healthCheckHost, healthCheckPort, logger) {
        super({
            port: healthCheckPort,
            hostname: healthCheckHost,
            logger,
            logContext: "healthCheckServer",
        });
    }
    setupRoutes() {
        this.app.get("/health", (_req, res) => {
            res.json({
                status: "ok",
            });
        });
        return Promise.resolve();
    }
}
//# sourceMappingURL=streamableHttp.js.map