"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorSearchStage = exports.modelsSupportingAutoEmbedIndexes = exports.AnyAggregateStage = exports.zSupportedEmbeddingParameters = exports.zVoyageAPIParameters = exports.zVoyageEmbeddingParameters = exports.zVoyageModels = void 0;
const zod_1 = __importDefault(require("zod"));
const args_js_1 = require("../args.js");
exports.zVoyageModels = zod_1.default
    .enum(["voyage-3-large", "voyage-3.5", "voyage-3.5-lite", "voyage-code-3"])
    .default("voyage-3-large");
exports.zVoyageEmbeddingParameters = zod_1.default.object({
    // OpenAPI JSON Schema supports enum only as string so the public facing
    // parameters that are fed to LLM providers should expect the dimensions as
    // stringified numbers which are then transformed to actual numbers.
    outputDimension: zod_1.default
        .union([zod_1.default.literal("256"), zod_1.default.literal("512"), zod_1.default.literal("1024"), zod_1.default.literal("2048"), zod_1.default.literal("4096")])
        .default("1024")
        .transform((value) => Number.parseInt(value))
        .optional(),
    outputDtype: zod_1.default.enum(["float", "int8", "uint8", "binary", "ubinary"]).optional().default("float"),
});
exports.zVoyageAPIParameters = exports.zVoyageEmbeddingParameters
    .extend({
    // Unlike public facing parameters, `zVoyageEmbeddingParameters`, the
    // api parameters need to be correct number and because we do an
    // additional parsing before calling the API, we override the
    // outputDimension schema to expect a union of numbers.
    outputDimension: zod_1.default
        .union([zod_1.default.literal(256), zod_1.default.literal(512), zod_1.default.literal(1024), zod_1.default.literal(2048), zod_1.default.literal(4096)])
        .default(1024)
        .optional(),
    inputType: zod_1.default.enum(["query", "document"]),
})
    .strip();
exports.zSupportedEmbeddingParameters = exports.zVoyageEmbeddingParameters.extend({ model: exports.zVoyageModels });
exports.AnyAggregateStage = (0, args_js_1.zEJSON)();
const zCommonVectorSearchStageParams = zod_1.default.object({
    exact: zod_1.default
        .boolean()
        .optional()
        .default(false)
        .describe("When true, uses an ENN algorithm, otherwise uses ANN. Using ENN is not compatible with numCandidates, in that case, numCandidates must be left empty."),
    index: zod_1.default.string().describe("Name of the index, as retrieved from the `collection-indexes` tool."),
    path: zod_1.default
        .string()
        .describe("Field, in dot notation, where to search. There must be a vector search index for that field."),
    numCandidates: zod_1.default
        .number()
        .int()
        .positive()
        .optional()
        .describe("Number of candidates for the ANN algorithm. Mandatory when exact is false."),
    limit: zod_1.default.number().int().positive().optional().default(10),
    filter: (0, args_js_1.zEJSON)()
        .optional()
        .describe("MQL filter that can only use filter fields from the index definition. Note to LLM: If unsure, use the `collection-indexes` tool to learn which fields can be used for filtering."),
});
const zClassicVectorSearchStageParams = zCommonVectorSearchStageParams.extend({
    queryVector: zod_1.default
        .union([zod_1.default.string(), zod_1.default.array(zod_1.default.number())])
        .describe("The content to search for when using classic vector search indexes (type: 'vector'). Provide embeddings as an array of numbers, or provide text as a string (requires embeddingParameters). Use this for classic vector indexes. For auto-embed indexes (type: 'autoEmbed'), use 'query' instead."),
    embeddingParameters: exports.zSupportedEmbeddingParameters
        .optional()
        .describe("The embedding model and its parameters to use to generate embeddings before searching. This is mandatory if queryVector is a string. Note to LLM: Use the collection-indexes tool to check if the target field has a classic vector index before providing embeddingParameters. If unsure about which model to use, ask the user."),
});
exports.modelsSupportingAutoEmbedIndexes = [
    "voyage-4",
    "voyage-4-large",
    "voyage-4-lite",
    "voyage-code-3",
];
const zAutoEmbedVectorSearchStageParams = zCommonVectorSearchStageParams.extend({
    query: zod_1.default
        .object({
        text: zod_1.default.string().describe("The text query to search for."),
    })
        .describe("The query to search for when using auto-embed indexes (type: 'autoEmbed'). MongoDB will automatically generate embeddings for the text at query time. Use this for auto-embed indexes, not 'queryVector'."),
    model: zod_1.default
        .enum(exports.modelsSupportingAutoEmbedIndexes)
        .optional()
        .describe("The embedding model to use for generating embeddings from the query text. If not specified, defaults to the model configured in the auto-embed index definition."),
});
exports.VectorSearchStage = zod_1.default.object({
    $vectorSearch: zod_1.default.union([
        zClassicVectorSearchStageParams.describe("Classic vector search using 'queryVector'. Use this when the indexed field has a classic vector index (type: 'vector'). Note to LLM: Use the collection-indexes tool to verify the target field has a classic vector index before using 'queryVector'."),
        zAutoEmbedVectorSearchStageParams.describe("Auto-embed vector search using 'query'. Use this when the indexed field has an auto-embed index (type: 'autoEmbed'). Note to LLM: Use the collection-indexes tool to verify the target field has an auto-embed index before using 'query'."),
    ]),
});
//# sourceMappingURL=mongodbSchemas.js.map